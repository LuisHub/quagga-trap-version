diff -rupN quagga-0.99.18//include/net-snmp/agent/agent_callbacks.h quaggasnmpTrap//include/net-snmp/agent/agent_callbacks.h
--- quagga-0.99.18//include/net-snmp/agent/agent_callbacks.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/agent_callbacks.h	2005-03-02 10:56:52.000000000 -0800
@@ -0,0 +1,21 @@
+#ifndef AGENT_CALLBACKS_H
+#define AGENT_CALLBACKS_H
+
+#define SNMPD_CALLBACK_ACM_CHECK         0
+#define SNMPD_CALLBACK_REGISTER_OID      1
+#define SNMPD_CALLBACK_UNREGISTER_OID    2
+#define SNMPD_CALLBACK_REG_SYSOR         3
+#define SNMPD_CALLBACK_UNREG_SYSOR       4
+#define SNMPD_CALLBACK_ACM_CHECK_INITIAL 5
+#define SNMPD_CALLBACK_SEND_TRAP1        6
+#define SNMPD_CALLBACK_SEND_TRAP2        7
+#define SNMPD_CALLBACK_REGISTER_NOTIFICATIONS 8
+#define SNMPD_CALLBACK_PRE_UPDATE_CONFIG 9
+#define SNMPD_CALLBACK_INDEX_START	 10
+#define SNMPD_CALLBACK_INDEX_STOP	 11
+#define SNMPD_CALLBACK_ACM_CHECK_SUBTREE 12
+#define SNMPD_CALLBACK_REQ_REG_SYSOR     13
+#define SNMPD_CALLBACK_REQ_UNREG_SYSOR   14
+#define SNMPD_CALLBACK_REQ_UNREG_SYSOR_SESS 15
+
+#endif                          /* AGENT_CALLBACKS_H */
diff -rupN quagga-0.99.18//include/net-snmp/agent/agent_handler.h quaggasnmpTrap//include/net-snmp/agent/agent_handler.h
--- quagga-0.99.18//include/net-snmp/agent/agent_handler.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/agent_handler.h	2010-04-07 03:40:50.000000000 -0700
@@ -0,0 +1,272 @@
+/* Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ */
+/*
+ * Portions of this file are copyrighted by:
+ * Copyright Â© 2003 Sun Microsystems, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+#ifndef AGENT_HANDLER_H
+#define AGENT_HANDLER_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/** @file agent_handler.h
+ *
+ *  @addtogroup handler
+ *
+ * @{
+ */
+
+struct netsnmp_handler_registration_s;
+
+/*
+ * per mib handler flags.
+ * NOTE: Lower bits are reserved for the agent handler's use.
+ *       The high 4 bits (31-28) are reserved for use by the handler.
+ */
+#define MIB_HANDLER_AUTO_NEXT                   0x00000001
+#define MIB_HANDLER_AUTO_NEXT_OVERRIDE_ONCE     0x00000002
+#define MIB_HANDLER_INSTANCE                    0x00000004
+
+#define MIB_HANDLER_CUSTOM4                     0x10000000
+#define MIB_HANDLER_CUSTOM3                     0x20000000
+#define MIB_HANDLER_CUSTOM2                     0x40000000
+#define MIB_HANDLER_CUSTOM1                     0x80000000
+
+
+/** @typedef struct netsnmp_mib_handler_s netsnmp_mib_handler
+ * Typedefs the netsnmp_mib_handler_s struct into  netsnmp_mib_handler */
+
+/** @struct netsnmp_mib_handler_s
+ *  the mib handler structure to be registered
+ */
+typedef struct netsnmp_mib_handler_s {
+        char           *handler_name;
+	/** for handler's internal use */
+        void           *myvoid; 
+        /** for agent_handler's internal use */
+        int             flags;
+
+        /** if you add more members, you probably also want to update */
+        /** _clone_handler in agent_handler.c. */
+	
+        int             (*access_method) (struct netsnmp_mib_handler_s *,
+                                          struct
+                                          netsnmp_handler_registration_s *,
+                                          struct
+                                          netsnmp_agent_request_info_s *,
+                                          struct netsnmp_request_info_s *);
+        void (*data_free)(void *myvoid); /**< data free hook for myvoid */
+
+        struct netsnmp_mib_handler_s *next;
+        struct netsnmp_mib_handler_s *prev;
+} netsnmp_mib_handler;
+
+/*
+ * per registration flags
+ */
+#define HANDLER_CAN_GETANDGETNEXT     0x01       /* must be able to do both */
+#define HANDLER_CAN_SET               0x02           /* implies create, too */
+#define HANDLER_CAN_GETBULK           0x04
+#define HANDLER_CAN_NOT_CREATE        0x08         /* auto set if ! CAN_SET */
+#define HANDLER_CAN_BABY_STEP         0x10
+#define HANDLER_CAN_STASH             0x20
+
+
+#define HANDLER_CAN_RONLY   (HANDLER_CAN_GETANDGETNEXT)
+#define HANDLER_CAN_RWRITE  (HANDLER_CAN_GETANDGETNEXT | HANDLER_CAN_SET)
+#define HANDLER_CAN_SET_ONLY (HANDLER_CAN_SET | HANDLER_CAN_NOT_CREATE)
+#define HANDLER_CAN_DEFAULT (HANDLER_CAN_RONLY | HANDLER_CAN_NOT_CREATE)
+
+/** @typedef struct netsnmp_handler_registration_s netsnmp_handler_registration
+ * Typedefs the netsnmp_handler_registration_s struct into netsnmp_handler_registration  */
+
+/** @struct netsnmp_handler_registration_s
+ *  Root registration info.
+ *  The variables handlerName, contextName, and rootoid need to be allocated
+ *  on the heap, when the registration structure is unregistered using
+ *  unregister_mib_context() the code attempts to free them.
+ */
+typedef struct netsnmp_handler_registration_s {
+
+	/** for mrTable listings, and other uses */
+        char           *handlerName;
+	/** NULL = default context */
+        char           *contextName;    
+
+        /**
+         * where are we registered at? 
+         */
+        oid            *rootoid;
+        size_t          rootoid_len;
+
+        /**
+         * handler details 
+         */
+        netsnmp_mib_handler *handler;
+        int             modes;
+
+        /**
+         * more optional stuff 
+         */
+        int             priority;
+        int             range_subid;
+        oid             range_ubound;
+        int             timeout;
+        int             global_cacheid;
+
+        /**
+         * void ptr for registeree
+         */
+        void *          my_reg_void;
+
+} netsnmp_handler_registration;
+
+/*
+ * function handler definitions 
+ */
+
+typedef int (Netsnmp_Node_Handler) (netsnmp_mib_handler *handler,
+    /** pointer to registration struct */
+    netsnmp_handler_registration *reginfo,
+    /** pointer to current transaction */
+    netsnmp_agent_request_info *reqinfo,
+    netsnmp_request_info *requests);
+
+    typedef struct netsnmp_handler_args_s {
+        netsnmp_mib_handler *handler;
+        netsnmp_handler_registration *reginfo;
+        netsnmp_agent_request_info *reqinfo;
+        netsnmp_request_info *requests;
+    } netsnmp_handler_args;
+
+    typedef struct netsnmp_delegated_cache_s {
+        int             transaction_id;
+        netsnmp_mib_handler *handler;
+        netsnmp_handler_registration *reginfo;
+        netsnmp_agent_request_info *reqinfo;
+        netsnmp_request_info *requests;
+        void           *localinfo;
+    } netsnmp_delegated_cache;
+
+    /*
+     * handler API functions 
+     */
+    void            netsnmp_init_handler_conf(void);
+    int             netsnmp_register_handler(netsnmp_handler_registration
+                                             *reginfo);
+    int             netsnmp_unregister_handler(netsnmp_handler_registration
+                                               *reginfo);
+    int            
+        netsnmp_register_handler_nocallback(netsnmp_handler_registration
+                                            *reginfo);
+    int             netsnmp_inject_handler(netsnmp_handler_registration
+                                           *reginfo,
+                                           netsnmp_mib_handler *handler);
+    int
+        netsnmp_inject_handler_before(netsnmp_handler_registration *reginfo,
+                                      netsnmp_mib_handler *handler,
+                                      const char *before_what);
+    netsnmp_mib_handler
+        *netsnmp_find_handler_by_name(netsnmp_handler_registration
+                                      *reginfo, const char *name);
+    void          
+        *netsnmp_find_handler_data_by_name(netsnmp_handler_registration
+                                           *reginfo, const char *name);
+    int             netsnmp_call_handlers(netsnmp_handler_registration
+                                          *reginfo,
+                                          netsnmp_agent_request_info
+                                          *reqinfo,
+                                          netsnmp_request_info *requests);
+    int             netsnmp_call_handler(netsnmp_mib_handler *next_handler,
+                                         netsnmp_handler_registration
+                                         *reginfo,
+                                         netsnmp_agent_request_info
+                                         *reqinfo,
+                                         netsnmp_request_info *requests);
+    int             netsnmp_call_next_handler(netsnmp_mib_handler *current,
+                                              netsnmp_handler_registration
+                                              *reginfo,
+                                              netsnmp_agent_request_info
+                                              *reqinfo,
+                                              netsnmp_request_info
+                                              *requests);
+    int             netsnmp_call_next_handler_one_request(netsnmp_mib_handler *current,
+                                                          netsnmp_handler_registration *reginfo,
+                                                          netsnmp_agent_request_info *reqinfo,
+                                                          netsnmp_request_info *requests);
+    
+    netsnmp_mib_handler *netsnmp_create_handler(const char *name,
+                                                Netsnmp_Node_Handler *
+                                                handler_access_method);
+    netsnmp_handler_registration *
+    netsnmp_handler_registration_create(const char *name,
+                                        netsnmp_mib_handler *handler,
+                                        const oid * reg_oid, size_t reg_oid_len,
+                                        int modes);
+    netsnmp_handler_registration *
+    netsnmp_create_handler_registration(const char *name, Netsnmp_Node_Handler*
+                                        handler_access_method,
+                                        const oid *reg_oid, size_t reg_oid_len,
+                                        int modes);
+
+    netsnmp_delegated_cache
+        *netsnmp_create_delegated_cache(netsnmp_mib_handler *,
+                                        netsnmp_handler_registration *,
+                                        netsnmp_agent_request_info *,
+                                        netsnmp_request_info *, void *);
+    void netsnmp_free_delegated_cache(netsnmp_delegated_cache *dcache);
+    netsnmp_delegated_cache
+        *netsnmp_handler_check_cache(netsnmp_delegated_cache *dcache);
+    void            netsnmp_register_handler_by_name(const char *,
+                                                     netsnmp_mib_handler
+                                                     *);
+
+    void            netsnmp_clear_handler_list(void);
+
+    void
+        netsnmp_request_add_list_data(netsnmp_request_info *request,
+                                      netsnmp_data_list *node);
+    int netsnmp_request_remove_list_data(netsnmp_request_info *request,
+                                         const char *name);
+
+    int
+        netsnmp_request_remove_list_data(netsnmp_request_info *request,
+                                         const char *name);
+
+    void    *netsnmp_request_get_list_data(netsnmp_request_info
+                                                  *request,
+                                                  const char *name);
+
+    void
+              netsnmp_free_request_data_set(netsnmp_request_info *request);
+
+    void
+             netsnmp_free_request_data_sets(netsnmp_request_info *request);
+
+    void            netsnmp_handler_free(netsnmp_mib_handler *);
+    netsnmp_mib_handler *netsnmp_handler_dup(netsnmp_mib_handler *);
+    netsnmp_handler_registration
+        *netsnmp_handler_registration_dup(netsnmp_handler_registration *);
+    void           
+        netsnmp_handler_registration_free(netsnmp_handler_registration *);
+
+#define REQUEST_IS_DELEGATED     1
+#define REQUEST_IS_NOT_DELEGATED 0
+    void           
+        netsnmp_handler_mark_requests_as_delegated(netsnmp_request_info *,
+                                                   int);
+    void           *netsnmp_handler_get_parent_data(netsnmp_request_info *,
+                                                    const char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif                          /* AGENT_HANDLER_H */
+/** @} */
diff -rupN quagga-0.99.18//include/net-snmp/agent/agent_index.h quaggasnmpTrap//include/net-snmp/agent/agent_index.h
--- quagga-0.99.18//include/net-snmp/agent/agent_index.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/agent_index.h	2002-06-12 02:15:45.000000000 -0700
@@ -0,0 +1,46 @@
+#ifndef AGENT_INDEX_H
+#define AGENT_INDEX_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#define ALLOCATE_THIS_INDEX		0x0
+#define ALLOCATE_ANY_INDEX		0x1
+#define ALLOCATE_NEW_INDEX		0x3
+        /*
+         * N.B: it's deliberate that NEW_INDEX & ANY_INDEX == ANY_INDEX 
+         */
+
+#define ANY_INTEGER_INDEX		-1
+#define ANY_STRING_INDEX		NULL
+#define ANY_OID_INDEX			NULL
+
+#define	INDEX_ERR_GENERR		-1
+#define	INDEX_ERR_WRONG_TYPE		-2
+#define	INDEX_ERR_NOT_ALLOCATED		-3
+#define	INDEX_ERR_WRONG_SESSION		-4
+
+char           *register_string_index(oid *, size_t, char *);
+int             register_int_index(oid *, size_t, int);
+netsnmp_variable_list *register_oid_index(oid *, size_t, oid *, size_t);
+netsnmp_variable_list *register_index(netsnmp_variable_list *, int,
+                                      netsnmp_session *);
+
+int             unregister_string_index(oid *, size_t, char *);
+int             unregister_int_index(oid *, size_t, int);
+int             unregister_oid_index(oid *, size_t, oid *, size_t);
+
+int             release_index(netsnmp_variable_list *);
+int             remove_index(netsnmp_variable_list *, netsnmp_session *);
+void            unregister_index_by_session(netsnmp_session *);
+int             unregister_index(netsnmp_variable_list *, int,
+                                 netsnmp_session *);
+
+unsigned long   count_indexes(oid * name, size_t namelen,
+                              int include_unallocated);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* AGENT_INDEX_H */
diff -rupN quagga-0.99.18//include/net-snmp/agent/agent_read_config.h quaggasnmpTrap//include/net-snmp/agent/agent_read_config.h
--- quagga-0.99.18//include/net-snmp/agent/agent_read_config.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/agent_read_config.h	2010-04-01 03:00:57.000000000 -0700
@@ -0,0 +1,31 @@
+/*
+ * agent_read_config.h: reads configuration files for extensible sections.
+ *
+ */
+#ifndef _AGENT_READ_CONFIG_H
+#define _AGENT_READ_CONFIG_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    void            init_agent_read_config(const char *);
+    void            update_config(void);
+    void            snmpd_register_config_handler(const char *token,
+                                                  void (*parser) (const
+                                                                  char *,
+                                                                  char *),
+                                                  void (*releaser) (void),
+                                                  const char *help);
+    void            snmpd_register_const_config_handler(
+                                 const char *,
+                                 void (*parser) (const char *, const char *),
+                                 void (*releaser) (void),
+                                 const char *);
+    void            snmpd_unregister_config_handler(const char *);
+    void            snmpd_store_config(const char *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* _AGENT_READ_CONFIG_H */
diff -rupN quagga-0.99.18//include/net-snmp/agent/agent_registry.h quaggasnmpTrap//include/net-snmp/agent/agent_registry.h
--- quagga-0.99.18//include/net-snmp/agent/agent_registry.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/agent_registry.h	2010-01-24 06:43:57.000000000 -0800
@@ -0,0 +1,179 @@
+#ifndef AGENT_REGISTRY_H
+#define AGENT_REGISTRY_H
+
+/***********************************************************************/
+/*
+ * new version2 agent handler API structures 
+ */
+/***********************************************************************/
+
+#include <net-snmp/agent/snmp_agent.h>
+#include <net-snmp/library/fd_event_manager.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/***********************************************************************/
+    /*
+     * requests api definitions 
+     */
+/***********************************************************************/
+
+    /*
+     * the structure of parameters passed to registered ACM modules 
+     */
+struct view_parameters {
+    netsnmp_pdu    *pdu;
+    oid            *name;
+    size_t          namelen;
+    int             test;
+    int             errorcode;		/*  Do not change unless you're
+					    specifying an error, as it starts
+					    in a success state.  */
+    int             check_subtree;
+};
+
+struct register_parameters {
+    oid                          *name;
+    size_t                        namelen;
+    int                           priority;
+    int                           range_subid;
+    oid                           range_ubound;
+    int                           timeout;
+    u_char                        flags;
+    const char                   *contextName;
+    netsnmp_session              *session;
+    netsnmp_handler_registration *reginfo;
+};
+
+typedef struct subtree_context_cache_s {
+    const char				*context_name;
+    struct netsnmp_subtree_s		*first_subtree;
+    struct subtree_context_cache_s	*next;
+} subtree_context_cache;
+
+
+
+void             setup_tree		  (void);
+void             shutdown_tree    (void);
+
+
+netsnmp_subtree *netsnmp_subtree_find	  (oid *, size_t, netsnmp_subtree *,
+					   const char *context_name);
+
+netsnmp_subtree *netsnmp_subtree_find_next(oid *, size_t, netsnmp_subtree *,
+					   const char *context_name);
+
+netsnmp_subtree *netsnmp_subtree_find_prev(oid *, size_t,netsnmp_subtree *,
+					   const char *context_name);
+
+netsnmp_subtree *netsnmp_subtree_find_first(const char *context_name);
+
+netsnmp_session *get_session_for_oid	   (oid *, size_t, 
+					    const char *context_name);
+
+subtree_context_cache *get_top_context_cache(void);
+
+void netsnmp_set_lookup_cache_size(int newsize);
+int netsnmp_get_lookup_cache_size(void);
+
+#define MIB_REGISTERED_OK		 0
+#define MIB_DUPLICATE_REGISTRATION	-1
+#define MIB_REGISTRATION_FAILED		-2
+#define MIB_UNREGISTERED_OK		 0
+#define MIB_NO_SUCH_REGISTRATION	-1
+#define MIB_UNREGISTRATION_FAILED	-2
+#define DEFAULT_MIB_PRIORITY		127
+
+int             register_mib		   (const char *, struct variable *,
+					    size_t, size_t, oid *, size_t);
+
+int             register_mib_priority	   (const char *, struct variable *,
+					    size_t, size_t, oid *, size_t,
+					    int);
+
+int             register_mib_range	   (const char *, struct variable *,
+					    size_t, size_t, oid *, size_t, 
+					    int, int, oid, netsnmp_session *);
+
+int		register_mib_context	   (const char *, struct variable *,
+					    size_t, size_t, oid *, size_t,
+					    int, int, oid, netsnmp_session *,
+					    const char *, int, int);
+
+int	netsnmp_register_mib_table_row	   (const char *, struct variable *,
+					    size_t, size_t, oid *, size_t, 
+					    int, int, netsnmp_session *,
+					    const char *, int, int);
+
+int		unregister_mib		   (oid *, size_t);
+
+int             unregister_mib_priority	   (oid *, size_t, int);
+int             unregister_mib_range	   (oid *, size_t, int, int, oid);
+int             unregister_mib_context	   (oid *, size_t, int, int, oid,
+					    const char *);
+void            clear_context              (void);
+void            unregister_mibs_by_session (netsnmp_session *);
+int     netsnmp_unregister_mib_table_row   (oid *mibloc, size_t mibloclen,
+					    int priority, int var_subid,
+					    oid range_ubound,
+					    const char *context);
+
+int             compare_tree		   (const oid *, size_t, 
+					    const oid *, size_t);
+int             in_a_view		   (oid *, size_t *, 
+					    netsnmp_pdu *, int);
+int             check_access		   (netsnmp_pdu *pdu);
+int             netsnmp_acm_check_subtree  (netsnmp_pdu *, oid *, size_t);
+void            register_mib_reattach	   (void);
+void            register_mib_detach	   (void);
+
+/*
+ * REGISTER_MIB(): This macro simply loads register_mib with less pain:
+ * 
+ * descr:   A short description of the mib group being loaded.
+ * var:     The variable structure to load.
+ * vartype: The variable structure used to define it (variable[2, 4, ...])
+ * theoid:  An *initialized* *exact length* oid pointer.
+ *          (sizeof(theoid) *must* return the number of elements!) 
+ */
+
+#define REGISTER_MIB(descr, var, vartype, theoid)                      \
+  if (register_mib(descr, (struct variable *) var, sizeof(struct vartype), \
+               sizeof(var)/sizeof(struct vartype),                     \
+               theoid, sizeof(theoid)/sizeof(oid)) != MIB_REGISTERED_OK ) \
+	DEBUGMSGTL(("register_mib", "%s registration failed\n", descr));
+
+
+#define NUM_EXTERNAL_SIGS 32
+#define SIG_REGISTERED_OK		 0
+#define SIG_REGISTRATION_FAILED		-2
+#define SIG_UNREGISTERED_OK		 0
+
+extern int      external_signal_scheduled[NUM_EXTERNAL_SIGS];
+extern void     (*external_signal_handler[NUM_EXTERNAL_SIGS])(int);
+
+int             register_signal(int, void (*func)(int));
+int             unregister_signal(int);
+
+
+
+/*
+ * internal API.  Don't use this.  Use netsnmp_register_handler instead 
+ */
+
+struct netsnmp_handler_registration_s;
+
+int             netsnmp_register_mib(const char *, struct variable *,
+				     size_t, size_t, oid *, size_t,
+				     int, int, oid, netsnmp_session *,
+				     const char *, int, int,
+				     struct netsnmp_handler_registration_s *,
+				     int);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif                          /* AGENT_REGISTRY_H */
diff -rupN quagga-0.99.18//include/net-snmp/agent/agent_sysORTable.h quaggasnmpTrap//include/net-snmp/agent/agent_sysORTable.h
--- quagga-0.99.18//include/net-snmp/agent/agent_sysORTable.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/agent_sysORTable.h	2008-05-10 02:40:55.000000000 -0700
@@ -0,0 +1,28 @@
+#ifndef AGENT_SYSORTABLE_H
+#define AGENT_SYSORTABLE_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+struct sysORTable;
+
+extern void     init_agent_sysORTable(void);
+extern void     shutdown_agent_sysORTable(void);
+
+extern void     netsnmp_sysORTable_foreach(void (*)(const struct sysORTable*,
+                                                    void*),
+                                           void*);
+
+extern int      register_sysORTable(oid *, size_t, const char *);
+extern int      unregister_sysORTable(oid *, size_t);
+extern int      register_sysORTable_sess(oid *, size_t, const char *,
+                                         netsnmp_session *);
+extern int      unregister_sysORTable_sess(oid *, size_t, netsnmp_session *);
+extern void     unregister_sysORTable_by_session(netsnmp_session *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* AGENT_SYSORTABLE_H */
diff -rupN quagga-0.99.18//include/net-snmp/agent/agent_trap.h quaggasnmpTrap//include/net-snmp/agent/agent_trap.h
--- quagga-0.99.18//include/net-snmp/agent/agent_trap.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/agent_trap.h	2010-01-26 13:27:50.000000000 -0800
@@ -0,0 +1,54 @@
+#ifndef AGENT_TRAP_H
+#define AGENT_TRAP_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+struct agent_add_trap_args {
+    netsnmp_session *ss;
+    int             confirm;
+};
+
+void            init_traps(void);
+void            send_easy_trap(int, int);
+void            send_trap_pdu(netsnmp_pdu *);
+void            send_v2trap(netsnmp_variable_list *);
+void            send_v3trap(netsnmp_variable_list *vars, const char *context);
+void            send_trap_vars(int, int, netsnmp_variable_list *);
+void            send_trap_vars_with_context(int trap, int specific, 
+                                            netsnmp_variable_list *vars,
+                                            const char *context);
+void            send_enterprise_trap_vars(int trap, int specific,
+                                          const oid * enterprise,
+                                          int enterprise_length,
+                                          netsnmp_variable_list * vars);
+int             netsnmp_send_traps(int trap, int specific,
+                          const oid * enterprise, int enterprise_length,
+                          netsnmp_variable_list * vars,
+                          /* flags are currently unused */
+                          const char * context, int flags);
+void            snmpd_parse_config_authtrap(const char *, char *);
+void            snmpd_parse_config_trapsink(const char *, char *);
+void            snmpd_parse_config_trap2sink(const char *, char *);
+void            snmpd_parse_config_informsink(const char *, char *);
+void            snmpd_parse_config_trapsess(const char *, char *);
+void            snmpd_free_trapsinks(void);
+void            snmpd_parse_config_trapcommunity(const char *, char *);
+void            snmpd_free_trapcommunity(void);
+void            send_trap_to_sess(netsnmp_session * sess,
+                                  netsnmp_pdu *template_pdu);
+
+int             create_trap_session(char *, u_short, char *, int, int);
+int             add_trap_session(netsnmp_session *, int, int, int);
+int             remove_trap_session(netsnmp_session *);
+
+void                   convert_v2_to_v1(netsnmp_variable_list *, netsnmp_pdu *);
+netsnmp_variable_list *convert_v1_to_v2(netsnmp_pdu *);
+netsnmp_pdu    *convert_v2pdu_to_v1(netsnmp_pdu *);
+netsnmp_pdu    *convert_v1pdu_to_v2(netsnmp_pdu *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* AGENT_TRAP_H */
diff -rupN quagga-0.99.18//include/net-snmp/agent/all_helpers.h quaggasnmpTrap//include/net-snmp/agent/all_helpers.h
--- quagga-0.99.18//include/net-snmp/agent/all_helpers.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/all_helpers.h	2010-01-25 08:01:45.000000000 -0800
@@ -0,0 +1,43 @@
+#ifndef ALL_HANDLERS_H
+#define ALL_HANDLERS_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#include <net-snmp/agent/instance.h>
+#include <net-snmp/agent/baby_steps.h>
+#include <net-snmp/agent/scalar.h>
+#include <net-snmp/agent/scalar_group.h>
+#include <net-snmp/agent/watcher.h>
+#include <net-snmp/agent/multiplexer.h>
+#include <net-snmp/agent/null.h>
+#include <net-snmp/agent/debug_handler.h>
+#include <net-snmp/agent/cache_handler.h>
+#include <net-snmp/agent/old_api.h>
+#include <net-snmp/agent/read_only.h>
+#include <net-snmp/agent/row_merge.h>
+#include <net-snmp/agent/serialize.h>
+#include <net-snmp/agent/bulk_to_next.h>
+#include <net-snmp/agent/mode_end_call.h>
+/*
+ * #include <net-snmp/agent/set_helper.h> 
+ */
+#include <net-snmp/agent/table.h>
+#include <net-snmp/agent/table_data.h>
+#include <net-snmp/agent/table_dataset.h>
+#include <net-snmp/agent/table_tdata.h>
+#include <net-snmp/agent/table_iterator.h>
+#include <net-snmp/agent/table_container.h>
+#include <net-snmp/agent/table_array.h> 
+
+#include <net-snmp/agent/mfd.h>
+#include <net-snmp/agent/snmp_get_statistic.h>
+
+
+void            netsnmp_init_helpers(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* ALL_HANDLERS_H */
diff -rupN quagga-0.99.18//include/net-snmp/agent/auto_nlist.h quaggasnmpTrap//include/net-snmp/agent/auto_nlist.h
--- quagga-0.99.18//include/net-snmp/agent/auto_nlist.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/auto_nlist.h	2006-09-14 17:48:50.000000000 -0700
@@ -0,0 +1,28 @@
+/*
+ * auto_nlist.h
+ */
+#ifndef AUTO_NLIST_H
+#define AUTO_NLIST_H
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#if defined(irix6) && defined(IRIX64)
+#define nlist nlist64
+#endif
+
+#ifdef NETSNMP_CAN_USE_NLIST
+int             auto_nlist(const char *, char *, int);
+long            auto_nlist_value(const char *);
+int             KNLookup(struct nlist *, int, char *, int);
+#else
+int             auto_nlist_noop(void);
+#	define auto_nlist(x,y,z) auto_nlist_noop()
+#	define auto_nlist_value(z) auto_nlist_noop()
+#	define KNLookup(w,x,y,z) auto_nlist_noop()
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/agent/baby_steps.h quaggasnmpTrap//include/net-snmp/agent/baby_steps.h
--- quagga-0.99.18//include/net-snmp/agent/baby_steps.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/baby_steps.h	2004-09-13 19:29:16.000000000 -0700
@@ -0,0 +1,109 @@
+/*
+ * $Id: baby_steps.h 11068 2004-09-14 02:29:16Z rstory $
+ */
+#ifndef BABY_STEPS_H
+#define BABY_STEPS_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#include <net-snmp/agent/agent_handler.h>
+
+    /*
+     * Flags for baby step modes
+     */
+#define BABY_STEP_NONE                  0
+#define BABY_STEP_PRE_REQUEST           (0x1 <<  1)
+#define BABY_STEP_OBJECT_LOOKUP         (0x1 <<  2)
+#define BABY_STEP_CHECK_VALUE           (0x1 <<  3)
+#define BABY_STEP_ROW_CREATE            (0x1 <<  4)
+#define BABY_STEP_UNDO_SETUP            (0x1 <<  5)
+#define BABY_STEP_SET_VALUE             (0x1 <<  6)
+#define BABY_STEP_CHECK_CONSISTENCY     (0x1 <<  7)
+#define BABY_STEP_UNDO_SET              (0x1 <<  8)
+#define BABY_STEP_COMMIT                (0x1 <<  9)
+#define BABY_STEP_UNDO_COMMIT           (0x1 << 10)
+#define BABY_STEP_IRREVERSIBLE_COMMIT   (0x1 << 11)
+#define BABY_STEP_UNDO_CLEANUP          (0x1 << 12)
+#define BABY_STEP_POST_REQUEST          (0x1 << 13)
+
+#define BABY_STEP_ALL                   (0xffffffff)
+
+
+#define BABY_STEP_CHECK_OBJECT          BABY_STEP_CHECK_VALUE
+#define BABY_STEP_SET_VALUES            BABY_STEP_SET_VALUE
+#define BABY_STEP_UNDO_SETS             BABY_STEP_UNDO_SET
+
+/** @name baby_steps
+ *
+ * This helper expands the original net-snmp set modes into the newer, finer
+ * grained modes.
+ *
+ *  @{ */
+
+    typedef struct netsnmp_baby_steps_modes_s {
+       u_int       registered;
+       u_int       completed;
+    } netsnmp_baby_steps_modes;
+
+void                 netsnmp_baby_steps_init(void);
+
+netsnmp_mib_handler *netsnmp_baby_steps_handler_get(u_long modes);
+
+/** @} */
+
+
+/** @name access_multiplexer
+ *
+ * This helper calls individual access methods based on the mode. All
+ * access methods share the same handler, and the same myvoid pointer.
+ * If you need individual myvoid pointers, check out the multiplexer
+ * handler (though it currently only works for traditional modes).
+ *
+ *  @{ */
+
+/** @struct netsnmp_mib_handler_access_methods
+ *  Defines the access methods to be called by the access_multiplexer helper
+ */
+typedef struct netsnmp_baby_steps_access_methods_s {
+      
+   /*
+    * baby step modes
+    */
+   Netsnmp_Node_Handler *pre_request;
+   Netsnmp_Node_Handler *object_lookup;
+   Netsnmp_Node_Handler *get_values;
+   Netsnmp_Node_Handler *object_syntax_checks;
+   Netsnmp_Node_Handler *row_creation;
+   Netsnmp_Node_Handler *undo_setup;
+   Netsnmp_Node_Handler *set_values;
+   Netsnmp_Node_Handler *consistency_checks;
+   Netsnmp_Node_Handler *commit;
+   Netsnmp_Node_Handler *undo_sets;
+   Netsnmp_Node_Handler *undo_cleanup;
+   Netsnmp_Node_Handler *undo_commit;
+   Netsnmp_Node_Handler *irreversible_commit;
+   Netsnmp_Node_Handler *post_request;
+
+   void                 *my_access_void;
+
+} netsnmp_baby_steps_access_methods;
+
+    netsnmp_mib_handler * netsnmp_baby_steps_access_multiplexer_get(
+        netsnmp_baby_steps_access_methods *);
+
+    int netsnmp_baby_step_mode2flag( u_int mode );
+
+/** @} */
+
+
+/** backwards compatability. don't use in new code */
+#define netsnmp_get_baby_steps_handler netsnmp_baby_steps_handler_get
+#define netsnmp_init_baby_steps_helper netsnmp_baby_steps_handler_init
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* baby_steps */
diff -rupN quagga-0.99.18//include/net-snmp/agent/bulk_to_next.h quaggasnmpTrap//include/net-snmp/agent/bulk_to_next.h
--- quagga-0.99.18//include/net-snmp/agent/bulk_to_next.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/bulk_to_next.h	2002-06-12 02:15:45.000000000 -0700
@@ -0,0 +1,28 @@
+/*
+ * bulk_to_next.h 
+ */
+#ifndef BULK_TO_NEXT_H
+#define BULK_TO_NEXT_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+
+/*
+ * The helper merely intercepts GETBULK requests and converts them to
+ * * GETNEXT reequests.
+ */
+
+
+netsnmp_mib_handler *netsnmp_get_bulk_to_next_handler(void);
+void            netsnmp_init_bulk_to_next_helper(void);
+void            netsnmp_bulk_to_next_fix_requests(netsnmp_request_info
+                                                  *requests);
+
+Netsnmp_Node_Handler netsnmp_bulk_to_next_helper;
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/agent/cache_handler.h quaggasnmpTrap//include/net-snmp/agent/cache_handler.h
--- quagga-0.99.18//include/net-snmp/agent/cache_handler.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/cache_handler.h	2010-03-09 20:17:26.000000000 -0800
@@ -0,0 +1,126 @@
+/* Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ */
+/*
+ * Portions of this file are copyrighted by:
+ * Copyright (C) 2007 Apple, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+#ifndef NETSNMP_CACHE_HANDLER_H
+#define NETSNMP_CACHE_HANDLER_H
+
+/*
+ * This caching helper provides a generalised (SNMP-manageable) caching
+ * mechanism.  Individual SNMP table and scalar/scalar group MIB
+ * implementations can use data caching in a consistent manner, without
+ * needing to handle the generic caching details themselves.
+ */
+
+#include <net-snmp/library/tools.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#define CACHE_NAME "cache_info"
+
+    typedef struct netsnmp_cache_s netsnmp_cache;
+
+    typedef int  (NetsnmpCacheLoad)(netsnmp_cache *, void*);
+    typedef void (NetsnmpCacheFree)(netsnmp_cache *, void*);
+
+    struct netsnmp_cache_s {
+        /*
+	 * For operation of the data caches
+	 */
+        int      flags;
+        int      enabled;
+        int      valid;
+        char     expired;
+        int      timeout;	/* Length of time the cache is valid (in s) */
+        marker_t timestamp;	/* When the cache was last loaded */
+        u_long   timer_id;      /* periodic timer id */
+
+        NetsnmpCacheLoad *load_cache;
+        NetsnmpCacheFree *free_cache;
+
+       /*
+        * void pointer for the user that created the cache.
+        * You never know when it might not come in useful ....
+        */
+        void             *magic;
+
+       /*
+        * hint from the cache helper. contains the standard
+        * handler arguments.
+        */
+       netsnmp_handler_args          *cache_hint;
+
+        /*
+	 * For SNMP-management of the data caches
+	 */
+	netsnmp_cache *next, *prev;
+        oid *rootoid;
+        int  rootoid_len;
+
+    };
+
+
+    void netsnmp_cache_reqinfo_insert(netsnmp_cache* cache,
+                                      netsnmp_agent_request_info * reqinfo,
+                                      const char *name);
+    netsnmp_cache  *
+       netsnmp_cache_reqinfo_extract(netsnmp_agent_request_info * reqinfo,
+                                     const char *name);
+    netsnmp_cache* netsnmp_extract_cache_info(netsnmp_agent_request_info *);
+
+    int            netsnmp_cache_check_and_reload(netsnmp_cache * cache);
+    int            netsnmp_cache_check_expired(netsnmp_cache *cache);
+    int            netsnmp_cache_is_valid(    netsnmp_agent_request_info *,
+                                              const char *name);
+    /** for backwards compat */
+    int            netsnmp_is_cache_valid(    netsnmp_agent_request_info *);
+    netsnmp_mib_handler *netsnmp_get_cache_handler(int, NetsnmpCacheLoad *,
+                                                        NetsnmpCacheFree *,
+                                                        const oid*, int);
+    int   netsnmp_register_cache_handler(netsnmp_handler_registration *reginfo,
+                                         int, NetsnmpCacheLoad *,
+                                              NetsnmpCacheFree *);
+
+    Netsnmp_Node_Handler netsnmp_cache_helper_handler;
+
+    netsnmp_cache *
+    netsnmp_cache_create(int timeout, NetsnmpCacheLoad * load_hook,
+                         NetsnmpCacheFree * free_hook,
+                         const oid * rootoid, int rootoid_len);
+    int netsnmp_cache_remove(netsnmp_cache *cache);
+    int netsnmp_cache_free(netsnmp_cache *cache);
+
+    netsnmp_mib_handler *
+    netsnmp_cache_handler_get(netsnmp_cache* cache);
+
+    netsnmp_cache * netsnmp_cache_find_by_oid(const oid * rootoid,
+                                              int rootoid_len);
+
+    unsigned int netsnmp_cache_timer_start(netsnmp_cache *cache);
+    void netsnmp_cache_timer_stop(netsnmp_cache *cache);
+
+/*
+ * Flags affecting cache handler operation
+ */
+#define NETSNMP_CACHE_DONT_INVALIDATE_ON_SET                0x0001
+#define NETSNMP_CACHE_DONT_FREE_BEFORE_LOAD                 0x0002
+#define NETSNMP_CACHE_DONT_FREE_EXPIRED                     0x0004
+#define NETSNMP_CACHE_DONT_AUTO_RELEASE                     0x0008
+#define NETSNMP_CACHE_PRELOAD                               0x0010
+#define NETSNMP_CACHE_AUTO_RELOAD                           0x0020
+
+#define NETSNMP_CACHE_HINT_HANDLER_ARGS                     0x1000
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* NETSNMP_CACHE_HANDLER_H */
diff -rupN quagga-0.99.18//include/net-snmp/agent/debug_handler.h quaggasnmpTrap//include/net-snmp/agent/debug_handler.h
--- quagga-0.99.18//include/net-snmp/agent/debug_handler.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/debug_handler.h	2002-06-12 02:15:45.000000000 -0700
@@ -0,0 +1,16 @@
+#ifndef DEBUG_HANDLER_H
+#define DEBUG_HANDLER_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+netsnmp_mib_handler *netsnmp_get_debug_handler(void);
+void            netsnmp_init_debug_helper(void);
+
+Netsnmp_Node_Handler netsnmp_debug_helper;
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* DEBUG_HANDLER_H */
diff -rupN quagga-0.99.18//include/net-snmp/agent/ds_agent.h quaggasnmpTrap//include/net-snmp/agent/ds_agent.h
--- quagga-0.99.18//include/net-snmp/agent/ds_agent.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/ds_agent.h	2008-06-25 10:39:42.000000000 -0700
@@ -0,0 +1,66 @@
+#ifndef NETSNMP_DS_AGENT_H
+#define NETSNMP_DS_AGENT_H
+/*
+ * defines agent's default store registrations 
+ */
+/*
+ * Note:
+ *    If new ds_agent entries are added to this header file,
+ *    then remember to run 'perl/agent/default_store/gen' to
+ *    update the corresponding perl interface.
+ */
+
+/*
+ * booleans 
+ */
+#define NETSNMP_DS_AGENT_VERBOSE        0       /* 1 if verbose output desired */
+#define NETSNMP_DS_AGENT_ROLE           1       /* 0 if master, 1 if client */
+#define NETSNMP_DS_AGENT_NO_ROOT_ACCESS 2       /* 1 if we can't get root access */
+#define NETSNMP_DS_AGENT_AGENTX_MASTER  3       /* 1 if AgentX desired */
+#define NETSNMP_DS_AGENT_QUIT_IMMEDIATELY 4     /* 1 to never start the agent */
+#define NETSNMP_DS_AGENT_DISABLE_PERL   5       /* 1 to never enable perl */
+#define NETSNMP_DS_AGENT_NO_CONNECTION_WARNINGS 6 /* 1 = !see !connect msgs */
+#define NETSNMP_DS_AGENT_LEAVE_PIDFILE  7       /* 1 = leave PID file on exit */
+#define NETSNMP_DS_AGENT_NO_CACHING     8       /* 1 = disable netsnmp_cache */
+#define NETSNMP_DS_AGENT_STRICT_DISMAN  9       /* 1 = "correct" object ordering */
+#define NETSNMP_DS_AGENT_DONT_RETAIN_NOTIFICATIONS 10   /* 1 = disable trap logging */
+#define NETSNMP_DS_AGENT_DONT_LOG_TCPWRAPPERS_CONNECTS 12   /* 1 = disable logging */
+#define NETSNMP_DS_APP_DONT_LOG         NETSNMP_DS_AGENT_DONT_RETAIN_NOTIFICATIONS /* compat */
+#define NETSNMP_DS_AGENT_SKIPNFSINHOSTRESOURCES    13   /* 1 = don't store NFS entries in hrStorageTable */
+
+/* WARNING: The trap receiver uses DS flags and must not conflict with
+   these!  If you use a value above 15, change the minimimum DS bool
+   value in snmptrapd_log.h */
+
+/*
+ * strings 
+ */
+#define NETSNMP_DS_AGENT_PROGNAME 0     /* argv[0] */
+#define NETSNMP_DS_AGENT_X_SOCKET 1     /* AF_UNIX or ip:port socket addr */
+#define NETSNMP_DS_AGENT_PORTS    2     /* localhost:9161,tcp:localhost:9161... */
+#define NETSNMP_DS_AGENT_INTERNAL_SECNAME  3    /* used by disman/mteTriggerTable. */
+#define NETSNMP_DS_AGENT_PERL_INIT_FILE    4    /* used by embedded perl */
+#define NETSNMP_DS_SMUX_SOCKET    5     /* ip:port socket addr */
+#define NETSNMP_DS_NOTIF_LOG_CTX  6     /* "" | "snmptrapd" */
+#define NETSNMP_DS_AGENT_TRAP_ADDR      7     /* used as v1 trap agent address */
+
+/*
+ * integers 
+ */
+#define NETSNMP_DS_AGENT_FLAGS    0     /* session.flags */
+#define NETSNMP_DS_AGENT_USERID   1
+#define NETSNMP_DS_AGENT_GROUPID  2
+#define NETSNMP_DS_AGENT_AGENTX_PING_INTERVAL 3 /* ping master every SECONDS */
+#define NETSNMP_DS_AGENT_AGENTX_TIMEOUT  4
+#define NETSNMP_DS_AGENT_AGENTX_RETRIES  5
+#define NETSNMP_DS_AGENT_X_SOCK_PERM     6      /* permissions for the */
+#define NETSNMP_DS_AGENT_X_DIR_PERM      7      /*     AgentX socket   */
+#define NETSNMP_DS_AGENT_X_SOCK_USER     8      /* ownership for the   */
+#define NETSNMP_DS_AGENT_X_SOCK_GROUP    9      /*     AgentX socket   */
+#define NETSNMP_DS_AGENT_CACHE_TIMEOUT  10      /* default cache timeout */
+#define NETSNMP_DS_AGENT_INTERNAL_VERSION  11   /* used by internal queries */
+#define NETSNMP_DS_AGENT_INTERNAL_SECLEVEL 12   /* used by internal queries */
+#define NETSNMP_DS_AGENT_MAX_GETBULKREPEATS 13 /* max getbulk repeats */
+#define NETSNMP_DS_AGENT_MAX_GETBULKRESPONSES 14   /* max getbulk respones */
+
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/agent/hardware/cpu.h quaggasnmpTrap//include/net-snmp/agent/hardware/cpu.h
--- quagga-0.99.18//include/net-snmp/agent/hardware/cpu.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/hardware/cpu.h	2006-08-27 09:43:39.000000000 -0700
@@ -0,0 +1,65 @@
+typedef struct netsnmp_cpu_info_s netsnmp_cpu_info;
+extern int cpu_num;
+
+                 /* For rolling averages */
+struct netsnmp_cpu_history {
+     long user_hist;
+     long sys_hist;
+     long idle_hist;
+     long nice_hist;
+     long total_hist;
+
+     long ctx_hist;
+     long intr_hist;
+     long swpi_hist;
+     long swpo_hist;
+     long pagei_hist;
+     long pageo_hist;
+};
+
+struct netsnmp_cpu_info_s {
+     int  idx;
+                 /* For hrDeviceTable */
+     char name[  SNMP_MAXBUF ];
+     char descr[ SNMP_MAXBUF ];
+     int  status;
+
+                 /* For UCD cpu stats */
+     long user_ticks;
+     long nice_ticks;
+     long sys_ticks;
+     long idle_ticks;
+     long wait_ticks;
+     long kern_ticks;
+     long intrpt_ticks;
+     long sirq_ticks;
+
+     long total_ticks;
+     long sys2_ticks;  /* For non-atomic system counts */
+
+                 /* For paging-related UCD stats */
+              /* XXX - Do these belong elsewhere ?? */
+              /* XXX - Do Not Use - Subject to Change */
+     long pageIn;
+     long pageOut;
+     long swapIn;
+     long swapOut;
+     long nInterrupts;
+     long nCtxSwitches;
+
+     struct netsnmp_cpu_history *history;
+
+     netsnmp_cpu_info *next;
+};
+
+
+    /*
+     * Possibly not all needed ??
+     */
+netsnmp_cpu_info *netsnmp_cpu_get_first(  void );
+netsnmp_cpu_info *netsnmp_cpu_get_next( netsnmp_cpu_info* );
+netsnmp_cpu_info *netsnmp_cpu_get_byIdx(  int,   int );
+netsnmp_cpu_info *netsnmp_cpu_get_byName( char*, int );
+
+netsnmp_cache *netsnmp_cpu_get_cache( void );
+int netsnmp_cpu_load( void );
diff -rupN quagga-0.99.18//include/net-snmp/agent/hardware/fsys.h quaggasnmpTrap//include/net-snmp/agent/hardware/fsys.h
--- quagga-0.99.18//include/net-snmp/agent/hardware/fsys.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/hardware/fsys.h	2010-06-08 00:11:35.000000000 -0700
@@ -0,0 +1,101 @@
+typedef struct netsnmp_fsys_info_s netsnmp_fsys_info;
+
+#define _NETSNMP_FS_TYPE_SKIP_BIT   0x2000
+#define _NETSNMP_FS_TYPE_LOCAL      0x1000
+
+   /*
+    * Enumeration from HOST-RESOURCES-TYPES mib
+    */
+#define NETSNMP_FS_TYPE_OTHER	   1
+#define NETSNMP_FS_TYPE_UNKNOWN	   2
+#define NETSNMP_FS_TYPE_BERKELEY   3
+#define NETSNMP_FS_TYPE_SYSV	   4
+#define NETSNMP_FS_TYPE_FAT	   5
+#define NETSNMP_FS_TYPE_HPFS	   6
+#define NETSNMP_FS_TYPE_HFS	   7
+#define NETSNMP_FS_TYPE_MFS	   8
+#define NETSNMP_FS_TYPE_NTFS	   9
+#define NETSNMP_FS_TYPE_VNODE	   10
+#define NETSNMP_FS_TYPE_JFS	   11
+#define NETSNMP_FS_TYPE_ISO9660	   12
+#define NETSNMP_FS_TYPE_ROCKRIDGE  13
+#define NETSNMP_FS_TYPE_NFS	   14
+#define NETSNMP_FS_TYPE_NETWARE	   15
+#define NETSNMP_FS_TYPE_AFS	   16
+#define NETSNMP_FS_TYPE_DFS	   17
+#define NETSNMP_FS_TYPE_APPLESHARE 18
+#define NETSNMP_FS_TYPE_RFS	   19
+#define NETSNMP_FS_TYPE_DGCS	   20
+#define NETSNMP_FS_TYPE_BOOTFS	   21
+#define NETSNMP_FS_TYPE_FAT32	   22
+#define NETSNMP_FS_TYPE_EXT2	   23
+
+   /*
+    * Additional enumerationis - not listed in that MIB
+    */
+#define NETSNMP_FS_TYPE_IGNORE	   1 | _NETSNMP_FS_TYPE_LOCAL | _NETSNMP_FS_TYPE_SKIP_BIT
+
+#define NETSNMP_FS_TYPE_PROC	   2 | _NETSNMP_FS_TYPE_LOCAL | _NETSNMP_FS_TYPE_SKIP_BIT
+
+#define NETSNMP_FS_TYPE_DEVPTS	   3 | _NETSNMP_FS_TYPE_LOCAL | _NETSNMP_FS_TYPE_SKIP_BIT
+#define NETSNMP_FS_TYPE_SYSFS	   4 | _NETSNMP_FS_TYPE_LOCAL | _NETSNMP_FS_TYPE_SKIP_BIT
+#define NETSNMP_FS_TYPE_TMPFS	   5 | _NETSNMP_FS_TYPE_LOCAL
+#define NETSNMP_FS_TYPE_USBFS	   6 | _NETSNMP_FS_TYPE_LOCAL
+
+#define NETSNMP_FS_FLAG_ACTIVE   0x01
+#define NETSNMP_FS_FLAG_REMOTE   0x02
+#define NETSNMP_FS_FLAG_RONLY    0x04
+#define NETSNMP_FS_FLAG_BOOTABLE 0x08
+#define NETSNMP_FS_FLAG_REMOVE   0x10
+#define NETSNMP_FS_FLAG_UCD      0x20
+
+#define NETSNMP_FS_FIND_CREATE     1   /* or use one of the type values */
+#define NETSNMP_FS_FIND_EXIST      0
+
+struct netsnmp_fsys_info_s {
+     netsnmp_index  idx;
+  /* int  idx; */
+ 
+     char path[  SNMP_MAXPATH+1];
+     char device[SNMP_MAXPATH+1];
+     int  type;
+
+     long size;
+     long used;
+     long avail;
+     long units;
+
+     long inums_total;
+     long inums_avail;
+
+     int  minspace;
+     int  minpercent;
+
+     long flags;
+
+     netsnmp_fsys_info *next;
+};
+
+
+    /*
+     * Possibly not all needed ??
+     */
+netsnmp_fsys_info *netsnmp_fsys_get_first( void );
+netsnmp_fsys_info *netsnmp_fsys_get_next( netsnmp_fsys_info* );
+netsnmp_fsys_info *netsnmp_fsys_get_byIdx(  int,   int );
+netsnmp_fsys_info *netsnmp_fsys_get_next_byIdx(int,int );
+
+netsnmp_fsys_info *netsnmp_fsys_by_device(  char*, int );
+netsnmp_fsys_info *netsnmp_fsys_by_path(    char*, int );
+
+netsnmp_cache *netsnmp_fsys_get_cache( void );
+int  netsnmp_fsys_load( netsnmp_cache *cache, void *data );
+void netsnmp_fsys_free( netsnmp_cache *cache, void *data );
+
+int netsnmp_fsys_size( netsnmp_fsys_info* );
+int netsnmp_fsys_used( netsnmp_fsys_info* );
+int netsnmp_fsys_avail(netsnmp_fsys_info* );
+
+unsigned long long netsnmp_fsys_size_ull( netsnmp_fsys_info* );
+unsigned long long netsnmp_fsys_used_ull( netsnmp_fsys_info* );
+unsigned long long netsnmp_fsys_avail_ull(netsnmp_fsys_info* );
diff -rupN quagga-0.99.18//include/net-snmp/agent/hardware/memory.h quaggasnmpTrap//include/net-snmp/agent/hardware/memory.h
--- quagga-0.99.18//include/net-snmp/agent/hardware/memory.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/hardware/memory.h	2006-03-06 08:23:52.000000000 -0800
@@ -0,0 +1,39 @@
+typedef struct netsnmp_memory_info_s netsnmp_memory_info;
+
+#define NETSNMP_MEM_TYPE_PHYSMEM  1
+#define NETSNMP_MEM_TYPE_USERMEM  2
+#define NETSNMP_MEM_TYPE_VIRTMEM  3
+#define NETSNMP_MEM_TYPE_STEXT    4
+#define NETSNMP_MEM_TYPE_RTEXT    5
+#define NETSNMP_MEM_TYPE_MBUF     6
+#define NETSNMP_MEM_TYPE_CACHED   7
+#define NETSNMP_MEM_TYPE_SHARED   8
+#define NETSNMP_MEM_TYPE_SHARED2  9
+#define NETSNMP_MEM_TYPE_SWAP    10
+    /* Leave space for individual swap devices */
+#define NETSNMP_MEM_TYPE_MAX     30
+
+struct netsnmp_memory_info_s {
+     int  idx;
+     int  type;
+     char *descr;
+
+     long units;
+     long size;
+     long free;
+     long other;
+
+     netsnmp_memory_info *next;
+};
+
+
+    /*
+     * Possibly not all needed ??
+     */
+netsnmp_memory_info *netsnmp_memory_get_first(  int );
+netsnmp_memory_info *netsnmp_memory_get_next( netsnmp_memory_info*, int );
+netsnmp_memory_info *netsnmp_memory_get_byIdx(  int,   int );
+netsnmp_memory_info *netsnmp_memory_get_next_byIdx(int,int );
+
+netsnmp_cache *netsnmp_memory_get_cache( void );
+int netsnmp_memory_load( void );
diff -rupN quagga-0.99.18//include/net-snmp/agent/hardware/sensors.h quaggasnmpTrap//include/net-snmp/agent/hardware/sensors.h
--- quagga-0.99.18//include/net-snmp/agent/hardware/sensors.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/hardware/sensors.h	2010-10-11 13:31:45.000000000 -0700
@@ -0,0 +1,48 @@
+/*
+ * Hardware Abstraction Layer - Sensors module
+ *
+ * Public interface
+ */
+
+#define NETSNMP_SENSOR_TYPE_OTHER       1
+#define NETSNMP_SENSOR_TYPE_VOLTAGE_AC  3
+#define NETSNMP_SENSOR_TYPE_VOLTAGE_DC  4
+#define NETSNMP_SENSOR_TYPE_CURRENT     5
+#define NETSNMP_SENSOR_TYPE_POWER       6
+#define NETSNMP_SENSOR_TYPE_FREQUENCY   7
+#define NETSNMP_SENSOR_TYPE_TEMPERATURE 8
+#define NETSNMP_SENSOR_TYPE_HUMIDITY    9
+#define NETSNMP_SENSOR_TYPE_RPM        10
+#define NETSNMP_SENSOR_TYPE_VOLUME     11
+#define NETSNMP_SENSOR_TYPE_BOOLEAN    12
+
+
+#define NETSNMP_SENSOR_FLAG_ACTIVE     0x01
+#define NETSNMP_SENSOR_FLAG_NAVAIL     0x02
+#define NETSNMP_SENSOR_FLAG_BROKEN     0x04
+#define NETSNMP_SENSOR_FLAG_DISABLE    0x08
+
+#define NETSNMP_SENSOR_MASK_STATUS     0x06  /* NAVAIL|BROKEN */
+
+
+#define NETSNMP_SENSOR_FIND_CREATE     1   /* or use one of the sensor type values */
+#define NETSNMP_SENSOR_FIND_EXIST      0
+
+typedef struct netsnmp_sensor_info_s netsnmp_sensor_info;
+struct netsnmp_sensor_info_s {
+
+    netsnmp_index  idx;
+    /* int  idx; */
+    char  name[256];
+    
+    int   type;
+    float value;
+    char  descr[256];
+    long  flags;
+};
+
+netsnmp_container   *get_sensor_container( void );
+netsnmp_cache       *get_sensor_cache( void );
+netsnmp_sensor_info *sensor_by_name( const char *, int );
+NetsnmpCacheLoad     netsnmp_sensor_load;
+NetsnmpCacheFree     netsnmp_sensor_free;
diff -rupN quagga-0.99.18//include/net-snmp/agent/instance.h quaggasnmpTrap//include/net-snmp/agent/instance.h
--- quagga-0.99.18//include/net-snmp/agent/instance.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/instance.h	2009-11-25 01:47:40.000000000 -0800
@@ -0,0 +1,152 @@
+/*
+ * instance.h 
+ */
+#ifndef NETSNMP_INSTANCE_H
+#define NETSNMP_INSTANCE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * The instance helper is designed to simplify the task of adding simple
+ * * instances to the mib tree.
+ */
+
+/*
+ * GETNEXTs are auto-converted to a GET.
+ * * non-valid GETs are dropped.
+ * * The client can assume that if you're called for a GET, it shouldn't
+ * * have to check the oid at all.  Just answer.
+ */
+
+int
+netsnmp_register_instance(netsnmp_handler_registration * reginfo);
+
+int            
+netsnmp_register_read_only_instance(netsnmp_handler_registration *reginfo);
+
+#define INSTANCE_HANDLER_NAME "instance"
+
+netsnmp_mib_handler *netsnmp_get_instance_handler(void);
+
+int
+netsnmp_register_read_only_ulong_instance(const char * name,
+                                          const oid * reg_oid,
+                                          size_t reg_oid_len,
+                                          u_long * it,
+                                          Netsnmp_Node_Handler * subhandler);
+int
+netsnmp_register_ulong_instance(const char * name,
+                                const oid * reg_oid,
+                                size_t reg_oid_len,
+                                u_long * it,
+                                Netsnmp_Node_Handler * subhandler);
+int
+netsnmp_register_read_only_counter32_instance(const char *name,
+                                              const oid * reg_oid,
+                                              size_t reg_oid_len,
+                                              u_long * it,
+                                              Netsnmp_Node_Handler *subhandler);
+int
+netsnmp_register_read_only_long_instance(const char *name,
+                                         const oid * reg_oid,
+                                         size_t reg_oid_len,
+                                         long *it,
+                                         Netsnmp_Node_Handler * subhandler);
+int
+netsnmp_register_long_instance(const char *name,
+                               const oid * reg_oid,
+                               size_t reg_oid_len,
+                               long *it,
+                               Netsnmp_Node_Handler * subhandler);
+
+int
+netsnmp_register_read_only_int_instance(const char *name,
+                                        const oid * reg_oid,
+                                        size_t reg_oid_len, int *it,
+                                        Netsnmp_Node_Handler * subhandler);
+
+int
+netsnmp_register_int_instance(const char *name,
+                              const oid * reg_oid,
+                              size_t reg_oid_len, int *it,
+                              Netsnmp_Node_Handler * subhandler);
+
+/* identical functions that register a in a particular context */
+int
+netsnmp_register_read_only_ulong_instance_context(const char *name,
+                                                  const oid * reg_oid,
+                                                  size_t reg_oid_len,
+                                                  u_long * it,
+                                                  Netsnmp_Node_Handler
+                                                  * subhandler,
+                                                  const char *contextName);
+int
+netsnmp_register_ulong_instance_context(const char *name,
+                                        const oid * reg_oid,
+                                        size_t reg_oid_len,
+                                        u_long * it,
+                                        Netsnmp_Node_Handler * subhandler,
+                                        const char *contextName);
+int
+netsnmp_register_read_only_counter32_instance_context(const char *name,
+                                                      const oid * reg_oid,
+                                                      size_t reg_oid_len,
+                                                      u_long * it,
+                                                      Netsnmp_Node_Handler
+                                                      * subhandler,
+                                                      const char *contextName);
+int
+netsnmp_register_read_only_long_instance_context(const char *name,
+                                                 const oid * reg_oid,
+                                                 size_t reg_oid_len,
+                                                 long *it,
+                                                 Netsnmp_Node_Handler
+                                                 * subhandler,
+                                                 const char *contextName);
+int
+netsnmp_register_long_instance_context(const char *name,
+                                       const oid * reg_oid,
+                                       size_t reg_oid_len,
+                                       long *it,
+                                       Netsnmp_Node_Handler * subhandler,
+                                       const char *contextName);
+
+int
+netsnmp_register_read_only_int_instance_context(const char *name,
+                                                const oid * reg_oid,
+                                                size_t reg_oid_len, int *it,
+                                                Netsnmp_Node_Handler *
+                                                subhandler,
+                                                const char *contextName);
+
+int
+netsnmp_register_int_instance_context(const char *name,
+                                      const oid * reg_oid,
+                                      size_t reg_oid_len, int *it,
+                                      Netsnmp_Node_Handler * subhandler,
+                                      const char *contextName);
+
+int
+netsnmp_register_num_file_instance(const char *name,
+                                   const oid * reg_oid, size_t reg_oid_len,
+                                   const char *file_name, int asn_type, int mode,
+                                   Netsnmp_Node_Handler * subhandler,
+                                   const char *contextName);
+
+Netsnmp_Node_Handler netsnmp_instance_helper_handler;
+#ifndef NETSNMP_NO_DEPRECATED_FUNCTIONS
+Netsnmp_Node_Handler netsnmp_instance_ulong_handler;
+Netsnmp_Node_Handler netsnmp_instance_long_handler;
+Netsnmp_Node_Handler netsnmp_instance_int_handler;
+Netsnmp_Node_Handler netsnmp_instance_uint_handler;
+Netsnmp_Node_Handler netsnmp_instance_counter32_handler;
+#endif
+Netsnmp_Node_Handler netsnmp_instance_num_file_handler;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /** NETSNMP_INSTANCE_H */
diff -rupN quagga-0.99.18//include/net-snmp/agent/mfd.h quaggasnmpTrap//include/net-snmp/agent/mfd.h
--- quagga-0.99.18//include/net-snmp/agent/mfd.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/mfd.h	2005-08-29 17:47:11.000000000 -0700
@@ -0,0 +1,84 @@
+/*
+ * MIBs For Dummies header
+ *
+ * $Id: mfd.h 12707 2005-08-30 00:47:11Z rstory $
+ */
+#ifndef NETSNMP_MFD_H
+#define NETSNMP_MFD_H
+
+/***********************************************************************
+ *
+ * return codes
+ *
+ **********************************************************************/
+
+/*----------------------------------------------------------------------
+ * general success/failure
+ */
+#define MFD_SUCCESS              SNMP_ERR_NOERROR
+#define MFD_ERROR                SNMP_ERR_GENERR
+
+/*
+ * object not currently available
+ */
+#define MFD_SKIP                 SNMP_NOSUCHINSTANCE
+
+/*
+ * no more data in table (get-next)
+ */
+#define MFD_END_OF_DATA          SNMP_ENDOFMIBVIEW
+
+/*----------------------------------------------------------------------
+ * set processing errors
+ */
+/*
+ * row creation errors
+ */
+#define MFD_CANNOT_CREATE_NOW    SNMP_ERR_INCONSISTENTNAME
+#define MFD_CANNOT_CREATE_EVER   SNMP_ERR_NOCREATION
+
+/*
+ * not writable or resource unavailable
+ */
+#define MFD_NOT_WRITABLE         SNMP_ERR_NOTWRITABLE
+#define MFD_RESOURCE_UNAVAILABLE SNMP_ERR_RESOURCEUNAVAILABLE
+
+/*
+ * new value errors
+ */
+#define MFD_NOT_VALID_NOW        SNMP_ERR_INCONSISTENTVALUE
+#define MFD_NOT_VALID_EVER       SNMP_ERR_WRONGVALUE
+
+
+/***********************************************************************
+ *
+ * rowreq flags
+ *
+ **********************************************************************/
+
+/*----------------------------------------------------------------------
+ * 8 flags resevered for the user
+ */
+#define MFD_ROW_FLAG_USER_1            0x00000001 /* user flag 1 */
+#define MFD_ROW_FLAG_USER_2            0x00000002 /* user flag 2 */
+#define MFD_ROW_FLAG_USER_3            0x00000004 /* user flag 3 */
+#define MFD_ROW_FLAG_USER_4            0x00000008 /* user flag 4 */
+#define MFD_ROW_FLAG_USER_5            0x00000010 /* user flag 5 */
+#define MFD_ROW_FLAG_USER_6            0x00000020 /* user flag 6 */
+#define MFD_ROW_FLAG_USER_7            0x00000040 /* user flag 7 */
+#define MFD_ROW_FLAG_USER_8            0x00000080 /* user flag 8 */
+#define MFD_ROW_FLAG_USER_MASK         0x000000ff /* user flag mask */
+
+/*----------------------------------------------------------------------
+ * MFD flags
+ *
+ * grow left to right, in case we want to add more user flags later
+ */
+#define MFD_ROW_MASK                   0xffffff00 /* mask to clear user flags */
+#define MFD_ROW_CREATED                0x80000000 /* newly created row */
+#define MFD_ROW_DATA_FROM_USER         0x40000000 /* we didn't allocate data */
+#define MFD_ROW_DELETED                0x20000000 /* deleted row */
+#define MFD_ROW_DIRTY                  0x10000000 /* changed row */
+
+
+#endif                          /* NETSNMP_MFD_H */
diff -rupN quagga-0.99.18//include/net-snmp/agent/mib_modules.h quaggasnmpTrap//include/net-snmp/agent/mib_modules.h
--- quagga-0.99.18//include/net-snmp/agent/mib_modules.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/mib_modules.h	2002-11-09 07:06:41.000000000 -0800
@@ -0,0 +1,23 @@
+#ifndef MIB_MODULES_H
+#define MIB_MODULES_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#define DO_INITIALIZE   1
+#define DONT_INITIALIZE 0
+
+struct module_init_list {
+    char           *module_name;
+    struct module_init_list *next;
+};
+
+void            add_to_init_list(char *module_list);
+int             should_init(const char *module_name);
+void            init_mib_modules(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/agent/mode_end_call.h quaggasnmpTrap//include/net-snmp/agent/mode_end_call.h
--- quagga-0.99.18//include/net-snmp/agent/mode_end_call.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/mode_end_call.h	2003-01-09 15:37:17.000000000 -0800
@@ -0,0 +1,39 @@
+/*
+ * mode_end_call.h 
+ */
+#ifndef MODE_END_CALL_H
+#define MODE_END_CALL_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#define NETSNMP_MODE_END_ALL_MODES -999
+
+typedef struct netsnmp_mode_handler_list_s {
+   struct netsnmp_mode_handler_list_s *next;
+   int mode;
+   netsnmp_mib_handler *callback_handler;
+} netsnmp_mode_handler_list;
+
+/*
+ * The helper calls another handler after each mode has been
+ * processed.
+ */
+
+/* public functions */
+netsnmp_mib_handler *
+netsnmp_get_mode_end_call_handler(netsnmp_mode_handler_list *endlist);
+
+netsnmp_mode_handler_list *
+netsnmp_mode_end_call_add_mode_callback(netsnmp_mode_handler_list *endlist,
+                                        int mode,
+                                        netsnmp_mib_handler *callbackh);
+
+/* internal */
+Netsnmp_Node_Handler netsnmp_mode_end_call_helper;
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/agent/multiplexer.h quaggasnmpTrap//include/net-snmp/agent/multiplexer.h
--- quagga-0.99.18//include/net-snmp/agent/multiplexer.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/multiplexer.h	2002-06-12 02:15:45.000000000 -0700
@@ -0,0 +1,39 @@
+#ifndef NETSNMP_MULTIPLEXER_H
+#define NETSNMP_MULTIPLEXER_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/*
+ * The multiplexer helper 
+ */
+
+/** @name multiplexer
+ *  @{ */
+
+/** @struct netsnmp_mib_handler_methods
+ *  Defines the subhandlers to be called by the multiplexer helper
+ */
+typedef struct netsnmp_mib_handler_methods_s {
+   /** called when a GET request is received */
+    netsnmp_mib_handler *get_handler;
+   /** called when a GETNEXT request is received */
+    netsnmp_mib_handler *getnext_handler;
+   /** called when a GETBULK request is received */
+    netsnmp_mib_handler *getbulk_handler;
+   /** called when a SET request is received */
+    netsnmp_mib_handler *set_handler;
+} netsnmp_mib_handler_methods;
+
+/** @} */
+
+netsnmp_mib_handler
+    *netsnmp_get_multiplexer_handler(netsnmp_mib_handler_methods *);
+
+Netsnmp_Node_Handler netsnmp_multiplexer_helper_handler;
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* NETSNMP_MULTIPLEXER_H */
diff -rupN quagga-0.99.18//include/net-snmp/agent/net-snmp-agent-includes.h quaggasnmpTrap//include/net-snmp/agent/net-snmp-agent-includes.h
--- quagga-0.99.18//include/net-snmp/agent/net-snmp-agent-includes.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/net-snmp-agent-includes.h	2007-08-16 01:55:53.000000000 -0700
@@ -0,0 +1,22 @@
+/*
+ * A simple helpful wrapper to include lots of agent specific include
+ * * files for people wanting to embed and snmp agent into an external
+ * * application
+ */
+#ifndef NET_SNMP_AGENT_INCLUDES_H
+#define NET_SNMP_AGENT_INCLUDES_H
+
+#include <net-snmp/agent/mib_module_config.h>
+#include <net-snmp/agent/agent_module_config.h>
+
+#include <net-snmp/agent/snmp_agent.h>
+#include <net-snmp/agent/snmp_vars.h>
+#include <net-snmp/agent/ds_agent.h>
+#include <net-snmp/agent/agent_handler.h>
+#include <net-snmp/agent/agent_read_config.h>
+#include <net-snmp/agent/agent_trap.h>
+#include <net-snmp/agent/agent_handler.h>
+#include <net-snmp/agent/all_helpers.h>
+#include <net-snmp/agent/var_struct.h>
+
+#endif                          /* NET_SNMP_AGENT_INCLUDES_H */
diff -rupN quagga-0.99.18//include/net-snmp/agent/null.h quaggasnmpTrap//include/net-snmp/agent/null.h
--- quagga-0.99.18//include/net-snmp/agent/null.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/null.h	2004-07-30 17:21:36.000000000 -0700
@@ -0,0 +1,26 @@
+#ifndef AGENT_NULL_H
+#define AGENT_NULL_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/*
+ * null.h 
+ */
+
+/*
+ * literally does nothing and is used as a final handler for
+ * "do-nothing" nodes that must exist solely for mib tree storage
+ * usage..
+ */
+
+int      netsnmp_register_null(oid *, size_t);
+int      netsnmp_register_null_context(oid *, size_t, const char *contextName);
+
+Netsnmp_Node_Handler netsnmp_null_handler;
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/agent/object_monitor.h quaggasnmpTrap//include/net-snmp/agent/object_monitor.h
--- quagga-0.99.18//include/net-snmp/agent/object_monitor.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/object_monitor.h	2006-01-25 08:28:12.000000000 -0800
@@ -0,0 +1,186 @@
+/**************************************************************************
+ * object_monitor.h
+ *
+ * Contributed by: Robert Story <rstory@freesnmp.com>
+ *
+ * $Id: object_monitor.h 14169 2006-01-25 16:28:12Z dts12 $
+ *
+ * functions and data structures for cooperating code to monitor objects.
+ *
+ * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
+ * WARNING!                                                       WARNING!
+ * WARNING!                                                       WARNING!
+ * WARNING!         This code is under active development         WARNING!
+ * WARNING!         and is subject to change at any time.         WARNING!
+ * WARNING!                                                       WARNING!
+ * WARNING!                                                       WARNING!
+ * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
+ */
+#ifndef OBJECT_MONITOR_H
+#define OBJECT_MONITOR_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    /*
+     * notification types
+     */
+    enum {
+        /*
+         * cooperative notification from the object being watched
+         */
+        NOTIFICATION_COOPERATIVE = 1,
+        /*
+         * notification that an object has been set vi SNMP-SET
+         */
+        NOTIFICATION_SET_REQUEST,
+        /*
+         * end of current notification types
+         */
+        NOTIFICATION_END
+    };
+
+    /*
+     * COOPERATIVE event types
+     */
+    enum {
+        EVENT_ROW_ADD = 1,
+        EVENT_ROW_MOD,
+        EVENT_ROW_DEL,
+        EVENT_COL_MOD,
+        EVENT_OBJ_MOD,
+        EVENT_END
+    };
+
+    /*
+     * data structures
+     */
+
+
+    /**
+     * callback header
+     */
+    typedef struct netsnmp_monitor_callback_header_s {
+
+   /** callback type */
+        unsigned int    event;
+
+   /** registered oid */
+        netsnmp_index   monitored_object;
+
+   /** priority */
+        int             priority;
+
+   /** pointer given by watcher at registration */
+        void           *watcher_data;
+
+   /** pointer passed from the monitored object */
+        void           *object_info;
+
+   /** DO NOT USE, INTERNAL USE ONLY */
+        struct netsnmp_monitor_callback_header_s *private;
+        int             refs;
+
+
+    } netsnmp_monitor_callback_header;
+
+    /*
+     *
+     */
+    typedef struct netsnmp_monitor_callback_set_request_s {
+
+    /** header */
+        netsnmp_monitor_callback_header hdr;
+
+    /** handler that registered to handle this object */
+        netsnmp_mib_handler *handler;
+
+    /** pdu containing the set request */
+        netsnmp_pdu    *pdu;
+
+    /** the set request */
+        netsnmp_request_info *request;
+
+    } netsnmp_monitor_set_request_data;
+
+    /*
+     *
+     */
+    typedef struct netsnmp_monitor_callback_cooperative_s {
+
+   /** header */
+        netsnmp_monitor_callback_header hdr;
+
+    } netsnmp_monitor_callback_cooperative;
+
+
+
+    typedef void   
+        (netsnmp_object_monitor_callback) (netsnmp_monitor_callback_header
+                                           *);
+
+
+
+
+    /**********************************************************************
+     * Registration function prototypes
+     */
+
+    /*
+     * Register a callback for the specified object.
+     */
+    int             netsnmp_monitor_register(oid * object, size_t oid_len,
+                                             int priority,
+                                             unsigned int events,
+                                             void *watcher_data,
+                                             netsnmp_object_monitor_callback
+                                             * cb);
+
+    /*
+     * Unregister a callback for the specified object.
+     */
+    int             netsnmp_monitor_unregister(oid * object,
+                                               size_t oid_len,
+                                               int priority,
+                                               void *watcher_data,
+                                               netsnmp_object_monitor_callback
+                                               * cb);
+
+    /*
+     * check to see if a registration exists for an object/event combination
+     */
+    int             netsnmp_monitor_check_registered(int event, oid * oid,
+                                                     int oid_len);
+
+
+    /**********************************************************************
+     * function prototypes
+     */
+
+    /*
+     * Notifies the object monitor of an event.
+     */
+    void            netsnmp_notify_monitor(netsnmp_monitor_callback_header
+                                           * cbh);
+
+
+
+
+    /**********************************************************************
+     * function prototypes
+     */
+
+    /*
+     * Notifies the object monitor of a cooperative event.
+     */
+    void            netsnmp_notify_cooperative(int event, oid * object,
+                                               size_t len, char oid_steal,
+                                               void *object_info);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /** OBJECT_MONITOR_H */
diff -rupN quagga-0.99.18//include/net-snmp/agent/old_api.h quaggasnmpTrap//include/net-snmp/agent/old_api.h
--- quagga-0.99.18//include/net-snmp/agent/old_api.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/old_api.h	2002-06-12 02:15:45.000000000 -0700
@@ -0,0 +1,49 @@
+#ifndef OLD_API_H
+#define OLD_API_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#define OLD_API_NAME "old_api"
+
+typedef struct netsnmp_old_api_info_s {
+    struct variable *var;
+    size_t          varsize;
+    size_t          numvars;
+
+    /*
+     * old stuff 
+     */
+    netsnmp_session *ss;
+    int             flags;
+} netsnmp_old_api_info;
+
+typedef struct old_opi_cache_s {
+    u_char         *data;
+    WriteMethod    *write_method;
+} netsnmp_old_api_cache;
+
+int             netsnmp_register_old_api(const char *moduleName,
+                                         struct variable *var,
+                                         size_t varsize,
+                                         size_t numvars,
+                                         oid * mibloc,
+                                         size_t mibloclen,
+                                         int priority,
+                                         int range_subid,
+                                         oid range_ubound,
+                                         netsnmp_session * ss,
+                                         const char *context,
+                                         int timeout, int flags);
+Netsnmp_Node_Handler netsnmp_old_api_helper;
+
+/*
+ * really shouldn't be used 
+ */
+netsnmp_agent_session *netsnmp_get_current_agent_session(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* OLD_API_H */
diff -rupN quagga-0.99.18//include/net-snmp/agent/read_only.h quaggasnmpTrap//include/net-snmp/agent/read_only.h
--- quagga-0.99.18//include/net-snmp/agent/read_only.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/read_only.h	2002-06-12 02:15:45.000000000 -0700
@@ -0,0 +1,29 @@
+#ifndef READ_ONLY_H
+#define READ_ONLY_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/*
+ * read_only.h 
+ */
+
+/*
+ * The helper merely intercepts SET requests and handles them early on
+ * making everything read-only (no SETs are actually permitted).
+ * Useful as a helper to handlers that are implementing MIBs with no
+ * SET support.
+ */
+
+
+netsnmp_mib_handler *netsnmp_get_read_only_handler(void);
+void            netsnmp_init_read_only_helper(void);
+
+Netsnmp_Node_Handler netsnmp_read_only_helper;
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/agent/row_merge.h quaggasnmpTrap//include/net-snmp/agent/row_merge.h
--- quagga-0.99.18//include/net-snmp/agent/row_merge.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/row_merge.h	2005-03-03 16:11:55.000000000 -0800
@@ -0,0 +1,38 @@
+#ifndef ROW_MERGE_H
+#define ROW_MERGE_H
+
+/*
+ * This row_merge helper splits a whole bunch of requests into chunks
+ * based on the row index that they refer to, and passes all requests
+ * for a given row to the lower handlers.
+ */
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    typedef struct netsnmp_row_merge_status_x {
+       char                  count;    /* number of requests */
+       char                  rows;     /* number of rows (unique indexes) */
+       char                  current;  /* current row number */
+       char                  reserved; /* reserver for future use */
+
+       netsnmp_request_info  **saved_requests; /* internal use */
+       char                  *saved_status;    /* internal use */
+    } netsnmp_row_merge_status;
+
+    netsnmp_mib_handler *netsnmp_get_row_merge_handler(int);
+    int   netsnmp_register_row_merge(netsnmp_handler_registration *reginfo);
+    void  netsnmp_init_row_merge(void);
+
+    int netsnmp_row_merge_status_first(netsnmp_handler_registration *reginfo,
+                                       netsnmp_agent_request_info *reqinfo);
+    int netsnmp_row_merge_status_last(netsnmp_handler_registration *reginfo,
+                                      netsnmp_agent_request_info *reqinfo);
+
+    Netsnmp_Node_Handler netsnmp_row_merge_helper_handler;
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/agent/scalar_group.h quaggasnmpTrap//include/net-snmp/agent/scalar_group.h
--- quagga-0.99.18//include/net-snmp/agent/scalar_group.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/scalar_group.h	2004-09-13 19:29:16.000000000 -0700
@@ -0,0 +1,36 @@
+/*
+ * scalar.h 
+ */
+#ifndef NETSNMP_SCALAR_GROUP_H
+#define NETSNMP_SCALAR_GROUP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * The scalar group helper is designed to implement a group of
+ * scalar objects all in one go, making use of the scalar and
+ * instance helpers.
+ *
+ * GETNEXTs are auto-converted to a GET.  Non-valid GETs are dropped.
+ * The client-provided handler just needs to check the OID name to
+ * see which object is being requested, but can otherwise assume that
+ * things are fine.
+ */
+
+typedef struct netsnmp_scalar_group_s {
+    oid lbound;		/* XXX - or do we need a more flexible arrangement? */
+    oid ubound;
+} netsnmp_scalar_group;
+
+int netsnmp_register_scalar_group(netsnmp_handler_registration *reginfo,
+	                          oid first, oid last);
+netsnmp_mib_handler *netsnmp_get_scalar_group_handler(oid first, oid last);
+Netsnmp_Node_Handler netsnmp_scalar_group_helper_handler;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /** NETSNMP_SCALAR_GROUP_H */
diff -rupN quagga-0.99.18//include/net-snmp/agent/scalar.h quaggasnmpTrap//include/net-snmp/agent/scalar.h
--- quagga-0.99.18//include/net-snmp/agent/scalar.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/scalar.h	2004-09-13 19:29:16.000000000 -0700
@@ -0,0 +1,36 @@
+/*
+ * scalar.h 
+ */
+#ifndef NETSNMP_SCALAR_H
+#define NETSNMP_SCALAR_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * The scalar helper is designed to simplify the task of adding simple
+ * scalar objects to the mib tree.
+ */
+
+/*
+ * GETNEXTs are auto-converted to a GET.
+ * * non-valid GETs are dropped.
+ * * The client can assume that if you're called for a GET, it shouldn't
+ * * have to check the oid at all.  Just answer.
+ */
+
+int netsnmp_register_scalar(netsnmp_handler_registration *reginfo);
+int netsnmp_register_read_only_scalar(netsnmp_handler_registration *reginfo);
+
+#define SCALAR_HANDLER_NAME "scalar"
+
+netsnmp_mib_handler *netsnmp_get_scalar_handler(void);
+
+Netsnmp_Node_Handler netsnmp_scalar_helper_handler;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /** NETSNMP_SCALAR_H */
diff -rupN quagga-0.99.18//include/net-snmp/agent/serialize.h quaggasnmpTrap//include/net-snmp/agent/serialize.h
--- quagga-0.99.18//include/net-snmp/agent/serialize.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/serialize.h	2004-09-13 19:29:16.000000000 -0700
@@ -0,0 +1,24 @@
+#ifndef SERIALIZE_H
+#define SERIALIZE_H
+
+/*
+ * The serialized helper merely calls its clients multiple times for a
+ * * given request set, so they don't have to loop through the requests
+ * * themselves.
+ */
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    netsnmp_mib_handler *netsnmp_get_serialize_handler(void);
+    int             netsnmp_register_serialize(netsnmp_handler_registration
+                                               *reginfo);
+    void            netsnmp_init_serialize(void);
+
+    Netsnmp_Node_Handler netsnmp_serialize_helper_handler;
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/agent/set_helper.h quaggasnmpTrap//include/net-snmp/agent/set_helper.h
--- quagga-0.99.18//include/net-snmp/agent/set_helper.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/set_helper.h	2002-06-12 02:15:45.000000000 -0700
@@ -0,0 +1,25 @@
+#ifndef SET_HELPER_H
+#define SET_HELPER_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+typedef struct netsnmp_set_info_s {
+    int             action;
+    void           *stateRef;
+
+    /*
+     * don't use yet: 
+     */
+    void          **oldData;
+    int             setCleanupFlags;    /* XXX: client sets this to: */
+#define AUTO_FREE_STATEREF 0x01 /* calls free(stateRef) */
+#define AUTO_FREE_OLDDATA  0x02 /* calls free(*oldData) */
+#define AUTO_UNDO          0x04 /* ... */
+} netsnmp_set_info;
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/agent/snmp_agent.h quaggasnmpTrap//include/net-snmp/agent/snmp_agent.h
--- quagga-0.99.18//include/net-snmp/agent/snmp_agent.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/snmp_agent.h	2009-12-22 04:02:31.000000000 -0800
@@ -0,0 +1,313 @@
+/* Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ */
+/*
+ * Portions of this file are copyrighted by:
+ * Copyright Â© 2003 Sun Microsystems, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+/*
+ * @file snmp_agent.h
+ *
+ * @addtogroup agent
+ * @addtogroup table
+ * External definitions for functions and variables in snmp_agent.c.
+ *
+ * @{
+ */
+
+#ifndef SNMP_AGENT_H
+#define SNMP_AGENT_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#include <net-snmp/library/snmp_impl.h>
+#include <net-snmp/library/tools.h>
+#include <net-snmp/library/data_list.h>
+
+#define SNMP_MAX_PDU_SIZE 64000 /* local constraint on PDU size sent by agent
+                                 * (see also SNMP_MAX_MSG_SIZE in snmp_api.h) */
+
+    /*
+     * If non-zero, causes the addresses of peers to be logged when receptions
+     * occur.  
+     */
+
+    extern int      log_addresses;
+
+    /*
+     * How many ticks since we last aged the address cache entries.  
+     */
+
+    extern int      lastAddrAge;
+
+    /** @typedef struct netsnmp_request_info_s netsnmp_request_info
+     * Typedefs the netsnmp_request_info_s struct into
+     * netsnmp_request_info*/
+    /** @struct netsnmp_request_info_s
+     * The netsnmp request info structure.
+     */
+    typedef struct netsnmp_request_info_s {
+	/**
+	 * variable bindings
+ 	 */
+        netsnmp_variable_list *requestvb;
+
+ 	/**
+ 	 * can be used to pass information on a per-request basis from a
+ 	 * helper to the later handlers 
+ 	 */
+        netsnmp_data_list *parent_data;
+
+       /*
+        * pointer to the agent_request_info for this request
+        */
+       struct netsnmp_agent_request_info_s *agent_req_info;
+
+ 	/** don't free, reference to (struct tree)->end */
+        oid            *range_end;
+        size_t          range_end_len;
+
+       /*
+        * flags
+        */
+        int             delegated;
+        int             processed;
+        int             inclusive;
+
+        int             status;
+ 	/** index in original pdu */
+        int             index;
+ 
+       /** get-bulk */
+        int             repeat;
+        int             orig_repeat;
+        netsnmp_variable_list *requestvb_start;
+
+       /* internal use */
+        struct netsnmp_request_info_s *next;
+        struct netsnmp_request_info_s *prev;
+        struct netsnmp_subtree_s      *subtree;
+    } netsnmp_request_info;
+
+    typedef struct netsnmp_set_info_s {
+        int             action;
+        void           *stateRef;
+
+        /*
+         * don't use yet: 
+         */
+        void          **oldData;
+        int             setCleanupFlags;
+#define AUTO_FREE_STATEREF 0x01 /* calls free(stateRef) */
+#define AUTO_FREE_OLDDATA  0x02 /* calls free(*oldData) */
+#define AUTO_UNDO          0x03 /* ... */
+    } netsnmp_set_info;
+
+    typedef struct netsnmp_tree_cache_s {
+        struct netsnmp_subtree_s *subtree;
+        netsnmp_request_info *requests_begin;
+        netsnmp_request_info *requests_end;
+    } netsnmp_tree_cache;
+
+#define MODE_GET              SNMP_MSG_GET
+#define MODE_GETNEXT          SNMP_MSG_GETNEXT
+#define MODE_GETBULK          SNMP_MSG_GETBULK
+#define MODE_GET_STASH        SNMP_MSG_INTERNAL_GET_STASH
+#define MODE_IS_GET(x)        ((x >= 128) && (x != -1)  && (x != SNMP_MSG_SET))
+    /* #define MODE_IS_GET(x)        ((x == SNMP_MSG_GET) || (x == SNMP_MSG_GETNEXT) || (x == SNMP_MSG_GETBULK) || (x == SNMP_MSG_INTERNAL_GET_STASH)) */
+
+#define MODE_SET_BEGIN        SNMP_MSG_INTERNAL_SET_BEGIN
+#define MODE_SET_RESERVE1     SNMP_MSG_INTERNAL_SET_RESERVE1
+#define MODE_SET_RESERVE2     SNMP_MSG_INTERNAL_SET_RESERVE2
+#define MODE_SET_ACTION       SNMP_MSG_INTERNAL_SET_ACTION
+#define MODE_SET_COMMIT       SNMP_MSG_INTERNAL_SET_COMMIT
+#define MODE_SET_FREE         SNMP_MSG_INTERNAL_SET_FREE
+#define MODE_SET_UNDO         SNMP_MSG_INTERNAL_SET_UNDO
+#define MODE_IS_SET(x)         ((x < 128) || (x == -1) || (x == SNMP_MSG_SET))
+    /* #define MODE_IS_SET(x)         (!MODE_IS_GET(x)) */
+
+#define MODE_BSTEP_PRE_REQUEST   SNMP_MSG_INTERNAL_PRE_REQUEST
+#define MODE_BSTEP_POST_REQUEST  SNMP_MSG_INTERNAL_POST_REQUEST
+
+#define MODE_BSTEP_OBJECT_LOOKUP       SNMP_MSG_INTERNAL_OBJECT_LOOKUP
+#define MODE_BSTEP_CHECK_VALUE         SNMP_MSG_INTERNAL_CHECK_VALUE
+#define MODE_BSTEP_ROW_CREATE          SNMP_MSG_INTERNAL_ROW_CREATE
+#define MODE_BSTEP_UNDO_SETUP          SNMP_MSG_INTERNAL_UNDO_SETUP
+#define MODE_BSTEP_SET_VALUE           SNMP_MSG_INTERNAL_SET_VALUE
+#define MODE_BSTEP_CHECK_CONSISTENCY   SNMP_MSG_INTERNAL_CHECK_CONSISTENCY
+#define MODE_BSTEP_UNDO_SET            SNMP_MSG_INTERNAL_UNDO_SET
+#define MODE_BSTEP_COMMIT              SNMP_MSG_INTERNAL_COMMIT
+#define MODE_BSTEP_UNDO_COMMIT         SNMP_MSG_INTERNAL_UNDO_COMMIT
+#define MODE_BSTEP_IRREVERSIBLE_COMMIT SNMP_MSG_INTERNAL_IRREVERSIBLE_COMMIT
+#define MODE_BSTEP_UNDO_CLEANUP        SNMP_MSG_INTERNAL_UNDO_CLEANUP
+
+
+/** @typedef struct netsnmp_agent_request_info_s netsnmp_agent_request_info
+ * Typedefs the netsnmp_agent_request_info_s struct into
+ * netsnmp_agent_request_info
+ */
+
+/** @struct netsnmp_agent_request_info_s
+ * The agent transaction request structure
+ */
+    typedef struct netsnmp_agent_request_info_s {
+        int             mode;
+ 	/** pdu contains authinfo, eg */
+/*        netsnmp_pdu    *pdu;    */
+        struct netsnmp_agent_session_s *asp;    /* may not be needed */
+        /*
+         * can be used to pass information on a per-pdu basis from a
+         * helper to the later handlers 
+         */
+        netsnmp_data_list *agent_data;
+    } netsnmp_agent_request_info;
+
+    typedef struct netsnmp_cachemap_s {
+        int             globalid;
+        int             cacheid;
+        struct netsnmp_cachemap_s *next;
+    } netsnmp_cachemap;
+
+    typedef struct netsnmp_agent_session_s {
+        int             mode;
+        netsnmp_session *session;
+        netsnmp_pdu    *pdu;
+        netsnmp_pdu    *orig_pdu;
+        int             rw;
+        int             exact;
+        int             status;
+        int             index;
+        int             oldmode;
+
+        struct netsnmp_agent_session_s *next;
+
+        /*
+         * new API pointers 
+         */
+        netsnmp_agent_request_info *reqinfo;
+        netsnmp_request_info *requests;
+        netsnmp_tree_cache *treecache;
+        netsnmp_variable_list **bulkcache;
+        int             treecache_len;  /* length of cache array */
+        int             treecache_num;  /* number of current cache entries */
+        netsnmp_cachemap *cache_store;
+        int             vbcount;
+    } netsnmp_agent_session;
+
+    /*
+     * Address cache handling functions.  
+     */
+
+    void            netsnmp_addrcache_initialise(void);
+    void            netsnmp_addrcache_destroy(void);
+    void            netsnmp_addrcache_age(void);
+
+
+    /*
+     * config file parsing routines 
+     */
+    int             handle_snmp_packet(int, netsnmp_session *, int,
+                                       netsnmp_pdu *, void *);
+    void            snmp_agent_parse_config(char *, char *);
+    netsnmp_agent_session *init_agent_snmp_session(netsnmp_session *,
+                                                   netsnmp_pdu *);
+    void            free_agent_snmp_session(netsnmp_agent_session *);
+    void           
+        netsnmp_remove_and_free_agent_snmp_session(netsnmp_agent_session
+                                                   *asp);
+#ifdef SNMP_NEED_REQUEST_LIST
+    void           
+        netsnmp_free_agent_snmp_session_by_session(netsnmp_session * sess,
+                                                   void (*free_request)
+                                                   (netsnmp_request_list
+                                                    *));
+#endif
+    int             getNextSessID(void);
+    void            dump_sess_list(void);
+    int             init_master_agent(void);
+    void            shutdown_master_agent(void);
+    int             agent_check_and_process(int block);
+    void            netsnmp_check_outstanding_agent_requests(void);
+
+    int             netsnmp_request_set_error(netsnmp_request_info *request,
+                                              int error_value);
+    int             netsnmp_check_requests_error(netsnmp_request_info *reqs);
+    int             netsnmp_check_all_requests_error(netsnmp_agent_session *asp,
+                                                     int look_for_specific);
+    int
+        netsnmp_set_all_requests_error(netsnmp_agent_request_info *reqinfo,
+                                       netsnmp_request_info *requests,
+                                       int error_value);
+    int netsnmp_request_set_error_idx(netsnmp_request_info *requests,
+                                       int error_value, int idx);
+    int
+        netsnmp_request_set_error_all(netsnmp_request_info *requests,
+                                       int error_value);
+    
+    /** deprecated, use netsnmp_request_set_error instead */
+    int             netsnmp_set_request_error(netsnmp_agent_request_info
+                                              *reqinfo,
+                                              netsnmp_request_info
+                                              *request, int error_value);
+    /** deprecated, use netsnmp_request_set_error instead */
+    int             netsnmp_set_mode_request_error(int mode,
+                                                   netsnmp_request_info
+                                                   *request,
+                                                   int error_value);
+
+    u_long          netsnmp_marker_uptime(marker_t pm);
+    u_long          netsnmp_timeval_uptime(struct timeval *tv);
+    const_marker_t  netsnmp_get_agent_starttime(void);
+    void            netsnmp_set_agent_starttime(marker_t s);
+    u_long          netsnmp_get_agent_uptime(void);
+    void            netsnmp_set_agent_uptime(u_long hsec);
+    int             netsnmp_check_transaction_id(int transaction_id);
+    int             netsnmp_agent_check_packet(netsnmp_session *,
+                                               struct netsnmp_transport_s
+                                               *, void *, int);
+    int             netsnmp_agent_check_parse(netsnmp_session *,
+                                              netsnmp_pdu *, int);
+    int             netsnmp_allocate_globalcacheid(void);
+
+    int netsnmp_remove_delegated_requests_for_session(netsnmp_session *sess);
+
+    /*
+     * Register and de-register agent NSAPs.  
+     */
+
+    struct netsnmp_transport_s;
+
+    int             netsnmp_register_agent_nsap(struct netsnmp_transport_s
+                                                *t);
+    void            netsnmp_deregister_agent_nsap(int handle);
+
+    void
+        netsnmp_agent_add_list_data(netsnmp_agent_request_info *agent,
+                                    netsnmp_data_list *node);
+
+    int
+        netsnmp_agent_remove_list_data(netsnmp_agent_request_info *ari,
+                                       const char * name);
+
+    void *
+            netsnmp_agent_get_list_data(netsnmp_agent_request_info
+                                        *agent, const char *name);
+
+    void
+            netsnmp_free_agent_data_set(netsnmp_agent_request_info *agent);
+
+    void
+           netsnmp_free_agent_data_sets(netsnmp_agent_request_info *agent);
+    void
+        netsnmp_free_agent_request_info(netsnmp_agent_request_info *ari);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+/** @} */
diff -rupN quagga-0.99.18//include/net-snmp/agent/snmp_get_statistic.h quaggasnmpTrap//include/net-snmp/agent/snmp_get_statistic.h
--- quagga-0.99.18//include/net-snmp/agent/snmp_get_statistic.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/snmp_get_statistic.h	2010-01-25 08:01:45.000000000 -0800
@@ -0,0 +1,20 @@
+#ifndef SNMP_GET_STATISTIC_H
+#define SNMP_GET_STATISTIC_H
+
+/** Registers a scalar group with statistics from @ref snmp_get_statistic.
+ *  as reginfo.[start, start + end - begin].
+ *  @param reginfo registration to register the items under
+ *  @param start offset to the begin item
+ *  @param begin first snmp_get_statistic key to return
+ *  @param end last snmp_get_statistic key to return
+ */
+int
+netsnmp_register_statistic_handler(netsnmp_handler_registration *reginfo,
+                                   oid start, int begin, int end);
+
+#define NETSNMP_REGISTER_STATISTIC_HANDLER(reginfo, start, stat)        \
+  netsnmp_register_statistic_handler(reginfo, start,                    \
+                                     STAT_ ## stat ## _STATS_START,     \
+                                     STAT_ ## stat ## _STATS_END)
+
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/agent/snmp_vars.h quaggasnmpTrap//include/net-snmp/agent/snmp_vars.h
--- quagga-0.99.18//include/net-snmp/agent/snmp_vars.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/snmp_vars.h	2005-06-21 14:33:55.000000000 -0700
@@ -0,0 +1,121 @@
+/*
+ * Definitions for SNMP (RFC 1067) agent variable finder.
+ *
+ */
+
+#ifndef _SNMP_VARS_H_
+#define _SNMP_VARS_H_
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/* Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ */
+/***********************************************************
+	Copyright 1988, 1989 by Carnegie Mellon University
+	Copyright 1989	TGV, Incorporated
+
+		      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of CMU and TGV not be used
+in advertising or publicity pertaining to distribution of the software
+without specific, written prior permission.
+
+CMU AND TGV DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
+INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
+EVENT SHALL CMU OR TGV BE LIABLE FOR ANY SPECIAL, INDIRECT OR
+CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
+USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
+OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
+PERFORMANCE OF THIS SOFTWARE.
+******************************************************************/
+/*
+ * Portions of this file are copyrighted by:
+ * Copyright Â© 2003 Sun Microsystems, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
+    struct variable;
+
+    /*
+     * Function pointer called by the master agent for writes. 
+     */
+    typedef int     (WriteMethod) (int action,
+                                   u_char * var_val,
+                                   u_char var_val_type,
+                                   size_t var_val_len,
+                                   u_char * statP,
+                                   oid * name, size_t length);
+
+    /*
+     * Function pointer called by the master agent for mib information retrieval 
+     */
+    typedef u_char *(FindVarMethod) (struct variable * vp,
+                                     oid * name,
+                                     size_t * length,
+                                     int exact,
+                                     size_t * var_len,
+                                     WriteMethod ** write_method);
+
+    /*
+     * Function pointer called by the master agent for setting up subagent requests 
+     */
+    typedef int     (AddVarMethod) (netsnmp_agent_session *asp,
+                                    netsnmp_variable_list * vbp);
+
+    struct nlist;
+
+    extern long     long_return;
+    extern u_char   return_buf[];
+
+    extern oid      nullOid[];
+    extern int      nullOidLen;
+
+#define INST	0xFFFFFFFF      /* used to fill out the instance field of the variables table */
+
+    struct variable {
+        u_char          magic;  /* passed to function as a hint */
+        char            type;   /* type of variable */
+        /*
+         * See important comment in snmp_vars.c relating to acl 
+         */
+        u_short         acl;    /* access control list for variable */
+        FindVarMethod  *findVar;        /* function that finds variable */
+        u_char          namelen;        /* length of above */
+        oid             name[MAX_OID_LEN];      /* object identifier of variable */
+    };
+
+    int             init_agent(const char *);
+    void            shutdown_agent(void);
+
+    int             should_init(const char *module_name);
+    void            add_to_init_list(char *module_list);
+
+#ifdef USING_AGENTX_SUBAGENT_MODULE
+    void            netsnmp_enable_subagent(void);
+#endif
+
+#ifndef _AGENT_REGISTRY_H
+#include <net-snmp/agent/agent_handler.h>
+#include <net-snmp/agent/var_struct.h>
+#include <net-snmp/agent/agent_registry.h>
+#endif
+
+    /*
+     * fail overloads non-negative integer value. it must be -1 ! 
+     */
+#define MATCH_FAILED	(-1)
+#define MATCH_SUCCEEDED	0
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* _SNMP_VARS_H_ */
diff -rupN quagga-0.99.18//include/net-snmp/agent/stash_cache.h quaggasnmpTrap//include/net-snmp/agent/stash_cache.h
--- quagga-0.99.18//include/net-snmp/agent/stash_cache.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/stash_cache.h	2008-05-10 02:40:55.000000000 -0700
@@ -0,0 +1,35 @@
+#ifndef STASH_CACHE_H
+#define STASH_CACHE_H
+
+#include <net-snmp/library/oid_stash.h>
+#include <net-snmp/library/tools.h>
+
+#define STASH_CACHE_NAME "stash_cache"
+
+typedef struct netsnmp_stash_cache_info_s {
+   int                      cache_valid;
+   marker_t                 cache_time;
+   netsnmp_oid_stash_node  *cache;
+   int                      cache_length;
+} netsnmp_stash_cache_info;
+
+typedef struct netsnmp_stash_cache_data_s {
+   void              *data;
+   size_t             data_len;
+   u_char             data_type;
+} netsnmp_stash_cache_data;
+
+/* function prototypes */
+void netsnmp_init_stash_cache_helper(void);
+netsnmp_mib_handler *netsnmp_get_bare_stash_cache_handler(void);
+netsnmp_mib_handler *netsnmp_get_stash_cache_handler(void);
+netsnmp_mib_handler *netsnmp_get_timed_bare_stash_cache_handler(int timeout,
+                                           oid *rootoid, size_t rootoid_len);
+netsnmp_mib_handler *netsnmp_get_timed_stash_cache_handler(int timeout,
+                                           oid *rootoid, size_t rootoid_len);
+Netsnmp_Node_Handler netsnmp_stash_cache_helper;
+netsnmp_oid_stash_node  **netsnmp_extract_stash_cache(netsnmp_agent_request_info *reqinfo);
+int netsnmp_stash_cache_update(netsnmp_mib_handler *handler, netsnmp_handler_registration *reginfo, netsnmp_agent_request_info *reqinfo, netsnmp_request_info *requests, netsnmp_stash_cache_info *cinfo);
+
+
+#endif /* STASH_CACHE_H */
diff -rupN quagga-0.99.18//include/net-snmp/agent/stash_to_next.h quaggasnmpTrap//include/net-snmp/agent/stash_to_next.h
--- quagga-0.99.18//include/net-snmp/agent/stash_to_next.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/stash_to_next.h	2005-01-07 04:22:58.000000000 -0800
@@ -0,0 +1,24 @@
+/*
+ * stash_to_next.h 
+ */
+#ifndef STASH_TO_NEXT_H
+#define STASH_TO_NEXT_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+
+/*
+ * The helper merely intercepts GETSTASH requests and converts them to
+ * GETNEXT reequests.
+ */
+
+
+netsnmp_mib_handler *netsnmp_get_stash_to_next_handler(void);
+Netsnmp_Node_Handler netsnmp_stash_to_next_helper;
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/agent/sysORTable.h quaggasnmpTrap//include/net-snmp/agent/sysORTable.h
--- quagga-0.99.18//include/net-snmp/agent/sysORTable.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/sysORTable.h	2010-01-07 04:19:05.000000000 -0800
@@ -0,0 +1,62 @@
+#ifndef NETSNMP_SYSORTABLE_H
+#define NETSNMP_SYSORTABLE_H
+
+struct sysORTable {
+    char            *OR_descr;
+    oid             *OR_oid;
+    size_t           OR_oidlen;
+    netsnmp_session *OR_sess;
+    u_long           OR_uptime;
+};
+
+struct register_sysOR_parameters {
+    char            *descr;
+    oid             *name;
+    size_t           namelen;
+};
+
+#define SYS_ORTABLE_REGISTERED_OK              0
+#define SYS_ORTABLE_REGISTRATION_FAILED       -1
+#define SYS_ORTABLE_UNREGISTERED_OK            0
+#define SYS_ORTABLE_NO_SUCH_REGISTRATION      -1
+
+#include <net-snmp/agent/agent_callbacks.h>
+
+#define REGISTER_SYSOR_TABLE(theoid, len, descr)           \
+  do {                                                     \
+    struct sysORTable t;                                   \
+    t.OR_descr = NETSNMP_REMOVE_CONST(char *, descr);      \
+    t.OR_oid = theoid;                                     \
+    t.OR_oidlen = len;                                     \
+    t.OR_sess = NULL;                                      \
+    t.OR_uptime = 0;                                       \
+    snmp_call_callbacks(SNMP_CALLBACK_APPLICATION,         \
+                        SNMPD_CALLBACK_REQ_REG_SYSOR, &t); \
+  } while(0);
+
+#define REGISTER_SYSOR_ENTRY(theoid, descr)                     \
+  REGISTER_SYSOR_TABLE(theoid, sizeof(theoid) / sizeof(oid),    \
+                       descr)
+
+#define UNREGISTER_SYSOR_TABLE(theoid, len)                     \
+  do {                                                          \
+    struct sysORTable t;                                        \
+    t.OR_descr = NULL;                                          \
+    t.OR_oid = theoid;                                          \
+    t.OR_oidlen = len;                                          \
+    t.OR_sess = NULL;                                           \
+    t.OR_uptime = 0;                                            \
+    snmp_call_callbacks(SNMP_CALLBACK_APPLICATION,              \
+                        SNMPD_CALLBACK_REQ_UNREG_SYSOR, &t);    \
+  } while(0);
+
+#define UNREGISTER_SYSOR_ENTRY(theoid)                          \
+  UNREGISTER_SYSOR_TABLE(theoid, sizeof(theoid) / sizeof(oid))
+
+#define UNREGISTER_SYSOR_SESS(sess)                             \
+  snmp_call_callbacks(SNMP_CALLBACK_APPLICATION,                \
+                      SNMPD_CALLBACK_REQ_UNREG_SYSOR_SESS,      \
+                      sess);
+
+
+#endif /* NETSNMP_SYSORTABLE_H */
diff -rupN quagga-0.99.18//include/net-snmp/agent/table_array.h quaggasnmpTrap//include/net-snmp/agent/table_array.h
--- quagga-0.99.18//include/net-snmp/agent/table_array.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/table_array.h	2005-09-12 08:24:16.000000000 -0700
@@ -0,0 +1,158 @@
+/*
+ * table_array.h
+ * $Id: table_array.h 12757 2005-09-12 15:24:16Z dts12 $
+ */
+#ifndef _TABLE_ARRAY_HANDLER_H_
+#define _TABLE_ARRAY_HANDLER_H_
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    /*
+     * The table array helper is designed to simplify the task of
+     * writing a table handler for the net-snmp agent when the data being
+     * accessed is in an oid sorted form and must be accessed externally.
+     * 
+     * Functionally, it is a specialized version of the more
+     * generic table helper but easies the burden of GETNEXT processing by
+     * retrieving the appropriate row for ead index through
+     * function calls which should be supplied by the module that wishes
+     * help.  The module the table_array helps should, afterwards,
+     * never be called for the case of "MODE_GETNEXT" and only for the GET
+     * and SET related modes instead.
+     */
+
+#include <net-snmp/library/container.h>
+#include <net-snmp/agent/table.h>
+
+#define TABLE_ARRAY_NAME "table_array"
+
+    /*
+     * group_item is to allow us to keep a list of requests without
+     * disrupting the actual netsnmp_request_info list.
+     */
+    typedef struct netsnmp_request_group_item_s {
+        netsnmp_request_info *ri;
+        netsnmp_table_request_info *tri;
+        struct netsnmp_request_group_item_s *next;
+    } netsnmp_request_group_item;
+
+    /*
+     * structure to keep a list of requests for each unique index
+     */
+    typedef struct netsnmp_request_group_s {
+       /*
+        * index for this row. points to someone else's memory, so
+        * don't free it!
+        */
+        netsnmp_index               index;
+
+       /*
+        * container in which rows belong
+        */
+        netsnmp_container           *table;
+
+       /*
+        * actual old and new rows
+        */
+        netsnmp_index               *existing_row;
+        netsnmp_index               *undo_info;
+
+       /*
+        * flags
+        */
+       char                          row_created;
+       char                          row_deleted;
+       char                          fill1;
+       char                          fill2;
+
+       /*
+        * requests for this row
+        */
+        netsnmp_request_group_item  *list;
+
+        int                          status;
+
+        void                        *rg_void;
+
+    } netsnmp_request_group;
+
+    typedef int     (Netsnmp_User_Row_Operation_c) (const void *lhs,
+                                                    const void *rhs);
+    typedef int     (Netsnmp_User_Row_Operation) (void *lhs, void *rhs);
+    typedef int     (Netsnmp_User_Get_Processor) (netsnmp_request_info *,
+                                                  netsnmp_index
+                                                  *,
+                                                  netsnmp_table_request_info
+                                                  *);
+    typedef netsnmp_index
+        *(UserRowMethod) (netsnmp_index *);
+    typedef int     (Netsnmp_User_Row_Action) (netsnmp_index *,
+                                               netsnmp_index *,
+                                               netsnmp_request_group *);
+    typedef void    (Netsnmp_User_Group_Method) (netsnmp_request_group *);
+
+    /*
+     * structure for array callbacks
+     */
+    typedef struct netsnmp_table_array_callbacks_s {
+
+        Netsnmp_User_Row_Operation   *row_copy;
+        Netsnmp_User_Row_Operation_c *row_compare;
+
+        Netsnmp_User_Get_Processor *get_value;
+
+
+        Netsnmp_User_Row_Action *can_activate;
+        Netsnmp_User_Row_Action *activated;
+        Netsnmp_User_Row_Action *can_deactivate;
+        Netsnmp_User_Row_Action *deactivated;
+        Netsnmp_User_Row_Action *can_delete;
+
+        UserRowMethod  *create_row;
+        UserRowMethod  *duplicate_row;
+        UserRowMethod  *delete_row;    /* always returns NULL */
+
+        Netsnmp_User_Group_Method *set_reserve1;
+        Netsnmp_User_Group_Method *set_reserve2;
+        Netsnmp_User_Group_Method *set_action;
+        Netsnmp_User_Group_Method *set_commit;
+        Netsnmp_User_Group_Method *set_free;
+        Netsnmp_User_Group_Method *set_undo;
+
+       /** not callbacks, but this is a useful place for them... */
+       netsnmp_container* container;
+       char can_set;
+
+    } netsnmp_table_array_callbacks;
+
+
+    int            
+        netsnmp_table_container_register(netsnmp_handler_registration *reginfo,
+                                     netsnmp_table_registration_info
+                                     *tabreq,
+                                     netsnmp_table_array_callbacks *cb,
+                                     netsnmp_container *container,
+                                     int group_rows);
+
+    int netsnmp_table_array_register(netsnmp_handler_registration *reginfo,
+                                     netsnmp_table_registration_info *tabreq,
+                                     netsnmp_table_array_callbacks *cb,
+                                     netsnmp_container *container,
+                                     int group_rows);
+
+    netsnmp_container * netsnmp_extract_array_context(netsnmp_request_info *);
+
+    Netsnmp_Node_Handler netsnmp_table_array_helper_handler;
+
+    int
+    netsnmp_table_array_check_row_status(netsnmp_table_array_callbacks *cb,
+                                         netsnmp_request_group *ag,
+                                         long *rs_new, long *rs_old);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif                          /* _TABLE_ARRAY_HANDLER_H_ */
diff -rupN quagga-0.99.18//include/net-snmp/agent/table_container.h quaggasnmpTrap//include/net-snmp/agent/table_container.h
--- quagga-0.99.18//include/net-snmp/agent/table_container.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/table_container.h	2010-04-07 03:40:50.000000000 -0700
@@ -0,0 +1,108 @@
+/*
+ * table_container.h
+ * $Id: table_container.h 18463 2010-04-07 10:40:50Z rstory $
+ */
+#ifndef _TABLE_CONTAINER_HANDLER_H_
+#define _TABLE_CONTAINER_HANDLER_H_
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    /*
+     * The table container helper is designed to simplify the task of
+     * writing a table handler for the net-snmp agent when the data being
+     * accessed is accessible via a netsnmp_container.
+     * 
+     * Functionally, it is a specialized version of the more
+     * generic table helper but easies the burden of GETNEXT processing by
+     * retrieving the appropriate row for each index through
+     * function calls which should be supplied by the module that wishes
+     * help.  The module the table_container helps should, afterwards,
+     * never be called for the case of "MODE_GETNEXT" and only for the GET
+     * and SET related modes instead.
+     */
+    
+#include <net-snmp/library/container.h>
+#include <net-snmp/agent/table.h>
+    
+#define TABLE_CONTAINER_ROW       "table_container:row"
+#define TABLE_CONTAINER_CONTAINER "table_container:container"
+    
+#define TABLE_CONTAINER_KEY_NETSNMP_INDEX         1 /* default */
+#define TABLE_CONTAINER_KEY_VARBIND_INDEX         2
+#define TABLE_CONTAINER_KEY_VARBIND_RAW           3
+
+/* ====================================
+ * Container Table API: MIB maintenance
+ * ==================================== */
+
+    /*
+     * get an injectable container table handler
+     */
+    netsnmp_mib_handler *
+    netsnmp_container_table_handler_get(netsnmp_table_registration_info *tabreq,
+                                        netsnmp_container *container,
+                                        char key_type);
+    /*
+     * register a container table
+     */
+    int            
+    netsnmp_container_table_register(netsnmp_handler_registration *reginfo,
+                                     netsnmp_table_registration_info *tabreq,
+                                     netsnmp_container *container,
+                                     char key_type);
+    int            
+    netsnmp_container_table_unregister(netsnmp_handler_registration *reginfo);
+    
+    /** retrieve the container used by the table_container helper */
+    netsnmp_container*
+    netsnmp_container_table_container_extract(netsnmp_request_info *request);
+
+    /** find the context data used by the table_container helper */
+#ifdef NETSNMP_USE_INLINE
+    NETSNMP_STATIC_INLINE void *
+    netsnmp_container_table_row_extract(netsnmp_request_info *request)
+    {
+        /*
+         * NOTE: this function must match in table_container.c and table_container.h.
+         *       if you change one, change them both!
+         */
+        return netsnmp_request_get_list_data(request, TABLE_CONTAINER_ROW);
+    }
+
+    NETSNMP_STATIC_INLINE void *
+    netsnmp_container_table_extract_context(netsnmp_request_info *request)
+    {
+        /*
+         * NOTE: this function must match in table_container.c and table_container.h.
+         *       if you change one, change them both!
+         */
+        return netsnmp_request_get_list_data(request, TABLE_CONTAINER_ROW);
+    }
+#else
+    void *
+    netsnmp_container_table_row_extract(netsnmp_request_info *request);
+    void *
+    netsnmp_container_table_extract_context(netsnmp_request_info *request);
+#endif /* inline */
+
+    void netsnmp_container_table_row_insert(netsnmp_request_info *request,
+                                            netsnmp_index *row);
+    void netsnmp_container_table_row_remove(netsnmp_request_info *request,
+                                            netsnmp_index        *row);
+
+/* ===================================
+ * Container Table API: Row operations
+ * =================================== */
+
+    void *
+    netsnmp_container_table_find_next_row(netsnmp_request_info *request,
+                                          netsnmp_table_request_info *tblreq,
+                                          netsnmp_container *container,
+                                          char key_type );
+#ifdef __cplusplus
+}
+#endif
+
+#endif                          /* _TABLE_CONTAINER_HANDLER_H_ */
diff -rupN quagga-0.99.18//include/net-snmp/agent/table_data.h quaggasnmpTrap//include/net-snmp/agent/table_data.h
--- quagga-0.99.18//include/net-snmp/agent/table_data.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/table_data.h	2010-10-15 05:53:19.000000000 -0700
@@ -0,0 +1,124 @@
+/*
+ * table_iterator.h 
+ */
+#ifndef _TABLE_DATA_HANDLER_H_
+#define _TABLE_DATA_HANDLER_H_
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    /*
+     * This helper is designed to completely automate the task of storing
+     * tables of data within the agent that are not tied to external data
+     * sources (like the kernel, hardware, or other processes, etc).  IE,
+     * all rows within a table are expected to be added manually using
+     * functions found below.
+     */
+
+#define TABLE_DATA_NAME "table_data"
+#define TABLE_DATA_ROW  "table_data"
+#define TABLE_DATA_TABLE "table_data_table"
+
+    typedef struct netsnmp_table_row_s {
+        netsnmp_variable_list *indexes; /* stored permanently if store_indexes = 1 */
+        oid            *index_oid;
+        size_t          index_oid_len;
+        void           *data;   /* the data to store */
+
+        struct netsnmp_table_row_s *next, *prev;        /* if used in a list */
+    } netsnmp_table_row;
+
+    typedef struct netsnmp_table_data_s {
+        netsnmp_variable_list *indexes_template;        /* containing only types */
+        char           *name;   /* if !NULL, it's registered globally */
+        int             flags;  /* not currently used */
+        int             store_indexes;
+        netsnmp_table_row *first_row;
+        netsnmp_table_row *last_row;
+    } netsnmp_table_data;
+
+/* =================================
+ * Table Data API: Table maintenance
+ * ================================= */
+
+    void       netsnmp_table_data_generate_index_oid( netsnmp_table_row  *row);
+
+    netsnmp_table_data *netsnmp_create_table_data(const char *name);
+    netsnmp_table_row  *netsnmp_create_table_data_row(void);
+    netsnmp_table_row  *netsnmp_table_data_clone_row( netsnmp_table_row  *row);
+    void               *netsnmp_table_data_delete_row(netsnmp_table_row  *row);
+    int                 netsnmp_table_data_add_row(   netsnmp_table_data *table,
+                                                      netsnmp_table_row  *row);
+    void
+       netsnmp_table_data_replace_row(netsnmp_table_data *table,
+                                      netsnmp_table_row *origrow,
+                                      netsnmp_table_row *newrow);
+    netsnmp_table_row *netsnmp_table_data_remove_row(netsnmp_table_data *table,
+                                                     netsnmp_table_row  *row);
+    void   *netsnmp_table_data_remove_and_delete_row(netsnmp_table_data *table,
+                                                     netsnmp_table_row  *row);
+    void    netsnmp_table_data_delete_table( netsnmp_table_data *table );
+
+/* =================================
+ * Table Data API: MIB maintenance
+ * ================================= */
+
+    netsnmp_mib_handler *
+        netsnmp_get_table_data_handler(netsnmp_table_data           *table);
+
+    int netsnmp_register_table_data(netsnmp_handler_registration    *reginfo,
+                                    netsnmp_table_data              *table,
+                                    netsnmp_table_registration_info *table_info);
+    int netsnmp_register_read_only_table_data(
+                                    netsnmp_handler_registration    *reginfo,
+                                    netsnmp_table_data              *table,
+                                    netsnmp_table_registration_info *table_info);
+    Netsnmp_Node_Handler netsnmp_table_data_helper_handler;
+
+    netsnmp_table_data *netsnmp_extract_table(    netsnmp_request_info *);
+    netsnmp_table_row  *netsnmp_extract_table_row(netsnmp_request_info *);
+    void          *netsnmp_extract_table_row_data(netsnmp_request_info *);
+    void netsnmp_insert_table_row(netsnmp_request_info *, netsnmp_table_row *);
+
+    int netsnmp_table_data_build_result(netsnmp_handler_registration *reginfo,
+                                        netsnmp_agent_request_info   *reqinfo,
+                                        netsnmp_request_info         *request,
+                                        netsnmp_table_row *row, int column,
+                                        u_char type, u_char * result_data,
+                                        size_t result_data_len);
+
+/* =================================
+ * Table Data API: Row operations
+ * ================================= */
+
+    netsnmp_table_row *netsnmp_table_data_get_first_row(
+                                              netsnmp_table_data    *table);
+    netsnmp_table_row *netsnmp_table_data_get_next_row(
+                                              netsnmp_table_data    *table,
+                                              netsnmp_table_row     *row);
+
+    netsnmp_table_row *netsnmp_table_data_get(netsnmp_table_data    *table,
+                                              netsnmp_variable_list *indexes);
+
+    netsnmp_table_row *netsnmp_table_data_get_from_oid(
+                                              netsnmp_table_data    *table,
+                                              oid *  searchfor,
+                                              size_t searchfor_len);
+
+    int netsnmp_table_data_num_rows(netsnmp_table_data *table);
+
+
+/* =================================
+ * Table Data API: Index operations
+ * ================================= */
+
+#define netsnmp_table_data_add_index(thetable, type) snmp_varlist_add_variable(&thetable->indexes_template, NULL, 0, type, NULL, 0)
+#define netsnmp_table_row_add_index(row, type, value, value_len) snmp_varlist_add_variable(&row->indexes, NULL, 0, type, (const u_char *) value, value_len)
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif                          /* _TABLE_DATA_HANDLER_H_ */
diff -rupN quagga-0.99.18//include/net-snmp/agent/table_dataset.h quaggasnmpTrap//include/net-snmp/agent/table_dataset.h
--- quagga-0.99.18//include/net-snmp/agent/table_dataset.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/table_dataset.h	2010-10-15 05:53:19.000000000 -0700
@@ -0,0 +1,194 @@
+/*
+ * table_iterator.h 
+ */
+#ifndef _TABLE_DATA_SET_HANDLER_H_
+#define _TABLE_DATA_SET_HANDLER_H_
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    /*
+     * This helper is designed to completely automate the task of storing
+     * tables of data within the agent that are not tied to external data
+     * sources (like the kernel, hardware, or other processes, etc).  IE,
+     * all rows within a table are expected to be added manually using
+     * functions found below.
+     */
+
+    void netsnmp_init_table_dataset(void);
+
+#define TABLE_DATA_SET_NAME "netsnmp_table_data_set"
+
+    /*
+     * return SNMP_ERR_NOERROR or some SNMP specific protocol error id 
+     */
+    typedef int     (Netsnmp_Value_Change_Ok) (char *old_value,
+                                               size_t old_value_len,
+                                               char *new_value,
+                                               size_t new_value_len,
+                                               void *mydata);
+
+    /*
+     * stored within a given row 
+     */
+    typedef struct netsnmp_table_data_set_storage_s {
+        unsigned int    column;
+
+        /*
+         * info about it? 
+         */
+        char            writable;
+        Netsnmp_Value_Change_Ok *change_ok_fn;
+        void           *my_change_data;
+
+        /*
+         * data actually stored 
+         */
+        u_char          type;
+        union {                 /* value of variable */
+            void           *voidp;
+            long           *integer;
+            u_char         *string;
+            oid            *objid;
+            u_char         *bitstring;
+            struct counter64 *counter64;
+#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES
+            float          *floatVal;
+            double         *doubleVal;
+#endif                          /* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */
+        } data;
+        u_long          data_len;
+
+        struct netsnmp_table_data_set_storage_s *next;
+    } netsnmp_table_data_set_storage;
+
+    typedef struct netsnmp_table_data_set_s {
+        netsnmp_table_data *table;
+        netsnmp_table_data_set_storage *default_row;
+        int             allow_creation; /* set to 1 to allow creation of new rows */
+        unsigned int    rowstatus_column;
+    } netsnmp_table_data_set;
+
+
+/* ============================
+ * DataSet API: Table maintenance
+ * ============================ */
+
+    netsnmp_table_data_set *netsnmp_create_table_data_set(const char *);
+    netsnmp_table_row *netsnmp_table_data_set_clone_row( netsnmp_table_row *row);
+    void netsnmp_table_dataset_delete_all_data(
+                            netsnmp_table_data_set_storage *data);
+    void netsnmp_table_dataset_delete_row(netsnmp_table_row *row);
+
+    void netsnmp_table_dataset_add_row(netsnmp_table_data_set
+                                                  *table,
+                                                  netsnmp_table_row *row);
+    void
+        netsnmp_table_dataset_replace_row(netsnmp_table_data_set *table,
+                                          netsnmp_table_row *origrow,
+                                          netsnmp_table_row *newrow);
+    void netsnmp_table_dataset_remove_row(netsnmp_table_data_set
+                                                     *table,
+                                                     netsnmp_table_row *row);
+    void
+        netsnmp_table_dataset_remove_and_delete_row(netsnmp_table_data_set
+                                                    *table,
+                                                    netsnmp_table_row *row);
+    void netsnmp_delete_table_data_set(netsnmp_table_data_set *table_set);
+
+/* ============================
+ * DataSet API: Default row operations
+ * ============================ */
+
+    /*
+     * to set, add column, type, (writable) ? 1 : 0 
+     */
+    /*
+     * default value, if not NULL, is the default value used in row
+     * creation.  It is copied into the storage template (free your
+     * calling argument). 
+     */
+    int netsnmp_table_set_add_default_row(netsnmp_table_data_set *,
+                                          unsigned int, int, int,
+                                          void  *default_value,
+                                          size_t default_value_len);
+    void netsnmp_table_set_multi_add_default_row(netsnmp_table_data_set *,
+                                                ...);
+
+
+/* ============================
+ * DataSet API: MIB maintenance
+ * ============================ */
+
+    netsnmp_mib_handler
+        *netsnmp_get_table_data_set_handler(netsnmp_table_data_set *);
+    Netsnmp_Node_Handler netsnmp_table_data_set_helper_handler;
+    int netsnmp_register_table_data_set(netsnmp_handler_registration *,
+                                        netsnmp_table_data_set *,
+                                        netsnmp_table_registration_info *);
+    netsnmp_table_data_set
+        *netsnmp_extract_table_data_set(netsnmp_request_info *request);
+    netsnmp_table_data_set_storage
+        *netsnmp_extract_table_data_set_column(netsnmp_request_info *,
+                                               unsigned int);
+    netsnmp_oid_stash_node **
+    netsnmp_table_dataset_get_or_create_stash(netsnmp_agent_request_info *ari,
+                                              netsnmp_table_data_set *tds,
+                                              netsnmp_table_request_info *tri);
+    netsnmp_table_row *
+    netsnmp_table_dataset_get_newrow(netsnmp_request_info *request,
+                                     netsnmp_agent_request_info *reqinfo,
+                                     int rootoid_len,
+                                     netsnmp_table_data_set *datatable,
+                                     netsnmp_table_request_info *table_info);
+
+
+/* ============================
+ * DataSet API: Config-based operations
+ * ============================ */
+
+    void netsnmp_register_auto_data_table(netsnmp_table_data_set *table_set,
+                                          char *registration_name);
+    void netsnmp_config_parse_table_set(const char *token, char *line);
+    void netsnmp_config_parse_add_row(  const char *token, char *line);
+
+
+/* ============================
+ * DataSet API: Row operations
+ * ============================ */
+
+    netsnmp_table_row *netsnmp_table_data_set_get_first_row(netsnmp_table_data_set *table);
+    netsnmp_table_row *netsnmp_table_data_set_get_next_row( netsnmp_table_data_set *table,
+                                                            netsnmp_table_row      *row);
+    int netsnmp_table_set_num_rows(netsnmp_table_data_set *table);
+
+
+/* ============================
+ * DataSet API: Column operations
+ * ============================ */
+
+    netsnmp_table_data_set_storage
+        *netsnmp_table_data_set_find_column(netsnmp_table_data_set_storage *,
+                                            unsigned int);
+    int  netsnmp_mark_row_column_writable(  netsnmp_table_row *row,
+                                            int column, int writable);
+    int  netsnmp_set_row_column(            netsnmp_table_row *,
+                                            unsigned int, int, const void *,
+                                            size_t);
+
+/* ============================
+ * DataSet API: Index operations
+ * ============================ */
+
+    void netsnmp_table_dataset_add_index(netsnmp_table_data_set
+                                                    *table, u_char type);
+    void netsnmp_table_set_add_indexes(netsnmp_table_data_set *tset, ...);
+
+#ifdef __cplusplus
+}
+#endif
+
+#define netsnmp_table_row_add_column(row, type, value, value_len) snmp_varlist_add_variable(&row->indexes, NULL, 0, type, (u_char *) value, value_len)
+
+#endif                          /* _TABLE_DATA_SET_HANDLER_H_ */
diff -rupN quagga-0.99.18//include/net-snmp/agent/table.h quaggasnmpTrap//include/net-snmp/agent/table.h
--- quagga-0.99.18//include/net-snmp/agent/table.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/table.h	2009-02-03 22:57:14.000000000 -0800
@@ -0,0 +1,196 @@
+/* Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ */
+/*
+ * Portions of this file are copyrighted by:
+ * Copyright Â© 2003 Sun Microsystems, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+/*
+ * Portions of this file are copyrighted by:
+ * Copyright (C) 2007 Apple, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+/*
+ * @file table.h
+ *
+ * @addtogroup table
+ *
+ * @{
+ */
+#ifndef _TABLE_HANDLER_H_
+#define _TABLE_HANDLER_H_
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/**
+ * The table helper is designed to simplify the task of writing a
+ * table handler for the net-snmp agent.  You should create a normal
+ * handler and register it using the netsnmp_register_table() function
+ * instead of the netsnmp_register_handler() function.
+ */
+
+/**
+ * Notes:
+ *
+ *   1) illegal indexes automatically get handled for get/set cases.
+ *      Simply check to make sure the value is type ASN_NULL before
+ *      you answer a request.
+ */
+	
+/**
+ * used as an index to parent_data lookups 
+ */
+#define TABLE_HANDLER_NAME "table"
+
+/** @typedef struct netsnmp_column_info_t netsnmp_column_info
+ * Typedefs the netsnmp_column_info_t struct into netsnmp_column_info */
+
+/**
+ * @struct netsnmp_column_info_t
+ * column info struct.  OVERLAPPING RANGES ARE NOT SUPPORTED.
+ */
+    typedef struct netsnmp_column_info_t {
+        char            isRange;
+ 	/** only useful if isRange == 0 */
+        char            list_count;
+
+        union {
+            unsigned int    range[2];
+            unsigned int   *list;
+        } details;
+
+        struct netsnmp_column_info_t *next;
+
+    } netsnmp_column_info;
+
+/** @typedef struct netsnmp_table_registration_info_s netsnmp_table_registration_info
+  * Typedefs the netsnmp_table_registration_info_s  struct into
+  * netsnmp_table_registration_info */
+
+/**
+ * @struct netsnmp_table_registration_info_s
+ * Table registration structure.
+ */
+    typedef struct netsnmp_table_registration_info_s {
+ 	/** list of varbinds with only 'type' set */
+        netsnmp_variable_list *indexes;
+ 	/** calculated automatically */
+        unsigned int    number_indexes;
+
+       /**
+        * the minimum columns number. If there are columns
+        * in-between which are not valid, use valid_columns to get
+        * automatic column range checking.
+        */
+        unsigned int    min_column;
+ 	/** the maximum columns number */
+        unsigned int    max_column;
+
+ 	/** more details on columns */
+        netsnmp_column_info *valid_columns;
+
+    } netsnmp_table_registration_info;
+
+/** @typedef struct netsnmp_table_request_info_s netsnmp_table_request_info
+  * Typedefs the netsnmp_table_request_info_s  struct into
+  * netsnmp_table_request_info */
+
+/**
+ * @struct netsnmp_table_request_info_s
+ * The table request info structure.
+ */
+    typedef struct netsnmp_table_request_info_s {
+ 	/** 0 if OID not long enough */
+        unsigned int    colnum;
+        /** 0 if failure to parse any */
+        unsigned int    number_indexes;
+ 	/** contents freed by helper upon exit */
+        netsnmp_variable_list *indexes;
+
+        oid             index_oid[MAX_OID_LEN];
+        size_t          index_oid_len;
+        netsnmp_table_registration_info *reg_info;
+    } netsnmp_table_request_info;
+
+    netsnmp_mib_handler
+        *netsnmp_get_table_handler(netsnmp_table_registration_info
+                                   *tabreq);
+    int   netsnmp_register_table(  netsnmp_handler_registration    *reginfo,
+                                   netsnmp_table_registration_info *tabreq);
+    int   netsnmp_unregister_table(netsnmp_handler_registration    *reginfo);
+    int   netsnmp_table_build_oid( netsnmp_handler_registration    *reginfo,
+                                   netsnmp_request_info            *reqinfo,
+                                   netsnmp_table_request_info   *table_info);
+    int            
+        netsnmp_table_build_oid_from_index(netsnmp_handler_registration
+                                           *reginfo,
+                                           netsnmp_request_info *reqinfo,
+                                           netsnmp_table_request_info
+                                           *table_info);
+    int             netsnmp_table_build_result(netsnmp_handler_registration
+                                               *reginfo,
+                                               netsnmp_request_info
+                                               *reqinfo,
+                                               netsnmp_table_request_info
+                                               *table_info, u_char type,
+                                               u_char * result,
+                                               size_t result_len);
+    int            
+        netsnmp_update_variable_list_from_index(netsnmp_table_request_info
+                                                *);
+    int            
+        netsnmp_update_indexes_from_variable_list
+        (netsnmp_table_request_info *tri);
+    netsnmp_table_registration_info
+        *netsnmp_find_table_registration_info(netsnmp_handler_registration
+                                              *reginfo);
+    void netsnmp_table_registration_info_free(netsnmp_table_registration_info *);
+
+    netsnmp_index * netsnmp_table_index_find_next_row(netsnmp_container *c,
+                                                      netsnmp_table_request_info *tblreq);
+
+    unsigned int    netsnmp_closest_column(unsigned int current,
+                                           netsnmp_column_info
+                                           *valid_columns);
+
+    Netsnmp_Node_Handler table_helper_handler;
+
+#define netsnmp_table_helper_add_index(tinfo, type) snmp_varlist_add_variable(&tinfo->indexes, NULL, 0, (u_char)type, NULL, 0);
+
+    void           
+        netsnmp_table_helper_add_indexes(netsnmp_table_registration_info
+                                         *tinfo, ...);
+
+    int netsnmp_check_getnext_reply(netsnmp_request_info *request,
+                                    oid * prefix, size_t prefix_len,
+                                    netsnmp_variable_list * newvar,
+                                    netsnmp_variable_list ** outvar);
+
+    netsnmp_table_request_info
+        *netsnmp_extract_table_info(netsnmp_request_info *);
+    netsnmp_oid_stash_node
+        **netsnmp_table_get_or_create_row_stash(netsnmp_agent_request_info
+                                                *reqinfo,
+                                                const u_char *
+                                                storage_name);
+	unsigned int
+		netsnmp_table_next_column(netsnmp_table_request_info *table_info);
+
+
+    int   netsnmp_sparse_table_register(netsnmp_handler_registration    *reginfo,
+                                        netsnmp_table_registration_info *tabreq);
+
+    netsnmp_mib_handler *netsnmp_sparse_table_handler_get(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif                          /* _TABLE_HANDLER_H_ */
+/** @} */
diff -rupN quagga-0.99.18//include/net-snmp/agent/table_iterator.h quaggasnmpTrap//include/net-snmp/agent/table_iterator.h
--- quagga-0.99.18//include/net-snmp/agent/table_iterator.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/table_iterator.h	2006-10-17 19:05:35.000000000 -0700
@@ -0,0 +1,157 @@
+/* Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ */
+/*
+ * Portions of this file are copyrighted by:
+ * Copyright Â© 2003 Sun Microsystems, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+/**
+ * @file table_iterator.h
+ * @addtogroup table_iterator
+ * @{
+ */
+#ifndef _TABLE_ITERATOR_HANDLER_H_
+#define _TABLE_ITERATOR_HANDLER_H_
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    struct netsnmp_iterator_info_s;
+
+    typedef netsnmp_variable_list *
+               (Netsnmp_First_Data_Point) (void **loop_context,
+                                           void **data_context,
+                                           netsnmp_variable_list *,
+                                           struct netsnmp_iterator_info_s *);
+    typedef netsnmp_variable_list *
+               (Netsnmp_Next_Data_Point)  (void **loop_context,
+                                           void **data_context,
+                                           netsnmp_variable_list *,
+                                           struct netsnmp_iterator_info_s *);
+    typedef void *(Netsnmp_Make_Data_Context) (void *loop_context,
+                                             struct netsnmp_iterator_info_s *);
+    typedef void  (Netsnmp_Free_Loop_Context) (void *,
+                                             struct netsnmp_iterator_info_s *);
+    typedef void  (Netsnmp_Free_Data_Context) (void *,
+                                             struct netsnmp_iterator_info_s *);
+
+    /** @typedef struct netsnmp_iterator_info_s netsnmp_iterator_info
+     * Typedefs the netsnmp_iterator_info_s struct into netsnmp_iterator_info */
+
+    /** @struct netsnmp_iterator_info_s
+
+     * Holds iterator information containing functions which should be
+       called by the iterator_handler to loop over your data set and
+       sort it in a SNMP specific manner.
+       
+       The netsnmp_iterator_info typedef can be used instead of directly calling this struct if you would prefer.
+     */
+    typedef struct netsnmp_iterator_info_s {
+       /** Responsible for: returning the first set of "index" data, a
+           loop-context pointer, and optionally a data context
+           pointer */
+        Netsnmp_First_Data_Point *get_first_data_point;
+
+       /** Given the previous loop context, this should return the
+           next loop context, associated index set and optionally a
+           data context */
+        Netsnmp_Next_Data_Point *get_next_data_point;
+
+       /** If a data context wasn't supplied by the
+           get_first_data_point or get_next_data_point functions and
+           the make_data_context pointer is defined, it will be called
+           to convert a loop context into a data context. */
+        Netsnmp_Make_Data_Context *make_data_context;
+
+       /** A function which should free the loop context.  This
+           function is called at *each* iteration step, which is
+           not-optimal for speed purposes.  The use of
+           free_loop_context_at_end instead is strongly
+           encouraged. This can be set to NULL to avoid its usage. */
+        Netsnmp_Free_Loop_Context *free_loop_context;
+
+       /** Frees a data context.  This will be called at any time a
+           data context needs to be freed.  This may be at the same
+           time as a correspondng loop context is freed, or much much
+           later.  Multiple data contexts may be kept in existence at
+           any time. */
+       Netsnmp_Free_Data_Context *free_data_context;
+
+       /** Frees a loop context at the end of the entire iteration
+           sequence.  Generally, this would free the loop context
+           allocated by the get_first_data_point function (which would
+           then be updated by each call to the get_next_data_point
+           function).  It is not called until the get_next_data_point
+           function returns a NULL */
+        Netsnmp_Free_Loop_Context *free_loop_context_at_end;
+
+       /** This can be used by client handlers to store any
+           information they need */
+        void           *myvoid;
+        int             flags;
+#define NETSNMP_ITERATOR_FLAG_SORTED	0x01
+
+       /** A pointer to the netsnmp_table_registration_info object
+           this iterator is registered along with. */
+        netsnmp_table_registration_info *table_reginfo;
+
+        /* Experimental extension - Use At Your Own Risk
+           (these two fields may change/disappear without warning) */
+        Netsnmp_First_Data_Point *get_row_indexes;
+        netsnmp_variable_list *indexes;
+    } netsnmp_iterator_info;
+
+#define TABLE_ITERATOR_NAME "table_iterator"
+
+/* ============================
+ * Iterator API: Table maintenance
+ * ============================ */
+        /* N/A */
+
+/* ============================
+ * Iterator API: MIB maintenance
+ * ============================ */
+
+    netsnmp_mib_handler
+          *netsnmp_get_table_iterator_handler(netsnmp_iterator_info *iinfo);
+    int    netsnmp_register_table_iterator(   netsnmp_handler_registration
+                                                                    *reginfo,
+                                              netsnmp_iterator_info *iinfo);
+    void  netsnmp_iterator_delete_table(netsnmp_iterator_info *iinfo);
+
+    void *netsnmp_extract_iterator_context(netsnmp_request_info *);
+    void   netsnmp_insert_iterator_context(netsnmp_request_info *, void *);
+
+    Netsnmp_Node_Handler netsnmp_table_iterator_helper_handler;
+
+
+/* ============================
+ * Iterator API: Row operations
+ * ============================ */
+
+void *netsnmp_iterator_row_first(      netsnmp_iterator_info *);
+void *netsnmp_iterator_row_get(        netsnmp_iterator_info *, void *);
+void *netsnmp_iterator_row_next(       netsnmp_iterator_info *, void *);
+void *netsnmp_iterator_row_get_byidx(  netsnmp_iterator_info *,
+                                       netsnmp_variable_list *);
+void *netsnmp_iterator_row_next_byidx( netsnmp_iterator_info *,
+                                       netsnmp_variable_list *);
+void *netsnmp_iterator_row_get_byoid(  netsnmp_iterator_info *, oid *, size_t);
+void *netsnmp_iterator_row_next_byoid( netsnmp_iterator_info *, oid *, size_t);
+int   netsnmp_iterator_row_count(      netsnmp_iterator_info *);
+
+
+/* ============================
+ * Iterator API: Index operations
+ * ============================ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif                          /* _TABLE_ITERATOR_HANDLER_H_ */
+/** @} */
diff -rupN quagga-0.99.18//include/net-snmp/agent/table_tdata.h quaggasnmpTrap//include/net-snmp/agent/table_tdata.h
--- quagga-0.99.18//include/net-snmp/agent/table_tdata.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/table_tdata.h	2010-04-26 20:02:11.000000000 -0700
@@ -0,0 +1,147 @@
+/*
+ * table_tdata.h 
+ */
+#ifndef _TABLE_TDATA_HANDLER_H_
+#define _TABLE_TDATA_HANDLER_H_
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    /*
+     * This helper is designed to completely automate the task of storing
+     * tables of data within the agent that are not tied to external data
+     * sources (like the kernel, hardware, or other processes, etc).  IE,
+     * all rows within a table are expected to be added manually using
+     * functions found below.
+     */
+
+#define TABLE_TDATA_NAME  "table_tdata"
+#define TABLE_TDATA_ROW   "table_tdata"
+#define TABLE_TDATA_TABLE "table_tdata_table"
+
+#define TDATA_FLAG_NO_STORE_INDEXES   0x01
+#define TDATA_FLAG_NO_CONTAINER       0x02 /* user will provide container */
+
+    /*
+     * The (table-independent) per-row data structure
+     * This is a wrapper round the table-specific per-row data
+     *   structure, which is referred to as a "table entry"
+     *
+     * It should be regarded as an opaque, private data structure,
+     *   and shouldn't be accessed directly.
+     */
+    typedef struct netsnmp_tdata_row_s {
+        netsnmp_index   oid_index;      /* table_container index format */
+        netsnmp_variable_list *indexes; /* stored permanently if store_indexes = 1 */
+        void           *data;   /* the data to store */
+    } netsnmp_tdata_row;
+
+    /*
+     * The data structure to hold a complete table.
+     *
+     * This should be regarded as an opaque, private data structure,
+     *   and shouldn't be accessed directly.
+     */
+    typedef struct netsnmp_tdata_s {
+        netsnmp_variable_list *indexes_template;        /* containing only types */
+        char           *name;   /* if !NULL, it's registered globally */
+        int             flags;  /* This field may legitimately be accessed by external code */
+        netsnmp_container *container;
+    } netsnmp_tdata;
+
+/* Backwards compatability with the previous (poorly named) data structures */
+typedef  struct netsnmp_tdata_row_s netsnmp_table_data2row;
+typedef  struct netsnmp_tdata_s     netsnmp_table_data2;
+
+
+/* ============================
+ * TData API: Table maintenance
+ * ============================ */
+
+    netsnmp_tdata     *netsnmp_tdata_create_table(const char *name, long flags);
+    void               netsnmp_tdata_delete_table(netsnmp_tdata *table);
+    netsnmp_tdata_row *netsnmp_tdata_create_row(void);
+    netsnmp_tdata_row *netsnmp_tdata_clone_row( netsnmp_tdata_row *row);
+    int                netsnmp_tdata_copy_row(  netsnmp_tdata_row *dst_row,
+                                                netsnmp_tdata_row *src_row);
+    void           *netsnmp_tdata_delete_row(   netsnmp_tdata_row *row);
+
+    int             netsnmp_tdata_add_row(      netsnmp_tdata     *table,
+                                                netsnmp_tdata_row *row);
+    void            netsnmp_tdata_replace_row(  netsnmp_tdata     *table,
+                                                netsnmp_tdata_row *origrow,
+                                                netsnmp_tdata_row *newrow);
+    netsnmp_tdata_row *netsnmp_tdata_remove_row(netsnmp_tdata     *table,
+                                                netsnmp_tdata_row *row);
+    void   *netsnmp_tdata_remove_and_delete_row(netsnmp_tdata     *table,
+                                                netsnmp_tdata_row *row);
+
+
+/* ============================
+ * TData API: MIB maintenance
+ * ============================ */
+
+    netsnmp_mib_handler *netsnmp_get_tdata_handler(netsnmp_tdata *table);
+
+    int netsnmp_tdata_register(  netsnmp_handler_registration    *reginfo,
+                                 netsnmp_tdata                   *table,
+                                 netsnmp_table_registration_info *table_info);
+    int netsnmp_tdata_unregister(netsnmp_handler_registration    *reginfo);
+
+    netsnmp_tdata      *netsnmp_tdata_extract_table(    netsnmp_request_info *);
+    netsnmp_container  *netsnmp_tdata_extract_container(netsnmp_request_info *);
+    netsnmp_tdata_row  *netsnmp_tdata_extract_row(      netsnmp_request_info *);
+    void               *netsnmp_tdata_extract_entry(    netsnmp_request_info *);
+
+    void netsnmp_insert_tdata_row(netsnmp_request_info *, netsnmp_tdata_row *);
+    void netsnmp_remove_tdata_row(netsnmp_request_info *, netsnmp_tdata_row *);
+
+
+/* ============================
+ * TData API: Row operations
+ * ============================ */
+
+    void * netsnmp_tdata_row_entry( netsnmp_tdata_row *row );
+    netsnmp_tdata_row *netsnmp_tdata_row_first(netsnmp_tdata     *table);
+    netsnmp_tdata_row *netsnmp_tdata_row_get(  netsnmp_tdata     *table,
+                                               netsnmp_tdata_row *row);
+    netsnmp_tdata_row *netsnmp_tdata_row_next( netsnmp_tdata     *table,
+                                               netsnmp_tdata_row *row);
+
+    netsnmp_tdata_row *netsnmp_tdata_row_get_byidx(netsnmp_tdata      *table,
+                                                netsnmp_variable_list *indexes);
+    netsnmp_tdata_row *netsnmp_tdata_row_get_byoid(netsnmp_tdata      *table,
+                                                oid   *searchfor,
+                                                size_t searchfor_len);
+    netsnmp_tdata_row *netsnmp_tdata_row_next_byidx(netsnmp_tdata     *table,
+                                                netsnmp_variable_list *indexes);
+    netsnmp_tdata_row *netsnmp_tdata_row_next_byoid(netsnmp_tdata     *table,
+                                                oid   *searchfor,
+                                                size_t searchfor_len);
+
+    int netsnmp_tdata_row_count(netsnmp_tdata *table);
+
+
+/* ============================
+ * TData API: Index operations
+ * ============================ */
+
+#define netsnmp_tdata_add_index(thetable, type) snmp_varlist_add_variable(&thetable->indexes_template, NULL, 0, type, NULL, 0)
+#define netsnmp_tdata_row_add_index(row, type, value, value_len) snmp_varlist_add_variable(&row->indexes, NULL, 0, type, (const u_char *) value, value_len)
+
+    int netsnmp_tdata_compare_idx(        netsnmp_tdata_row     *row,
+                                          netsnmp_variable_list *indexes);
+    int netsnmp_tdata_compare_oid(        netsnmp_tdata_row     *row,
+                                          oid *compareto, size_t compareto_len);
+    int netsnmp_tdata_compare_subtree_idx(netsnmp_tdata_row     *row,
+                                          netsnmp_variable_list *indexes);
+    int netsnmp_tdata_compare_subtree_oid(netsnmp_tdata_row     *row,
+                                          oid *compareto, size_t compareto_len);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif                          /* _TABLE_TDATA_HANDLER_H_ */
diff -rupN quagga-0.99.18//include/net-snmp/agent/var_struct.h quaggasnmpTrap//include/net-snmp/agent/var_struct.h
--- quagga-0.99.18//include/net-snmp/agent/var_struct.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/var_struct.h	2004-12-13 09:27:58.000000000 -0800
@@ -0,0 +1,116 @@
+#ifndef VAR_STRUCT_H
+#define VAR_STRUCT_H
+/*
+ * The subtree structure contains a subtree prefix which applies to
+ * all variables in the associated variable list.
+ *
+ * By converting to a tree of subtree structures, entries can
+ * now be subtrees of another subtree in the structure. i.e:
+ * 1.2
+ * 1.2.0
+ */
+
+#define UCD_REGISTRY_OID_MAX_LEN	128
+
+/*
+ * subtree flags 
+ */
+#define FULLY_QUALIFIED_INSTANCE    0x01
+#define SUBTREE_ATTACHED	    	0x02
+
+typedef struct netsnmp_subtree_s {
+    oid		   *name_a;	/* objid prefix of registered subtree */
+    u_char          namelen;    /* number of subid's in name above */
+    oid            *start_a;	/* objid of start of covered range */
+    u_char          start_len;  /* number of subid's in start name */
+    oid            *end_a;	/* objid of end of covered range   */
+    u_char          end_len;    /* number of subid's in end name */
+    struct variable *variables; /* pointer to variables array */
+    int             variables_len;      /* number of entries in above array */
+    int             variables_width;    /* sizeof each variable entry */
+    char           *label_a;	/* calling module's label */
+    netsnmp_session *session;
+    u_char          flags;
+    u_char          priority;
+    int             timeout;
+    struct netsnmp_subtree_s *next;       /* List of 'sibling' subtrees */
+    struct netsnmp_subtree_s *prev;       /* (doubly-linked list) */
+    struct netsnmp_subtree_s *children;   /* List of 'child' subtrees */
+    int             range_subid;
+    oid             range_ubound;
+    netsnmp_handler_registration *reginfo;      /* new API */
+    int             cacheid;
+    int             global_cacheid;
+    size_t          oid_off;
+} netsnmp_subtree;
+
+/*
+ * This is a new variable structure that doesn't have as much memory
+ * tied up in the object identifier.  It's elements have also been re-arranged
+ * so that the name field can be variable length.  Any number of these
+ * structures can be created with lengths tailor made to a particular
+ * application.  The first 5 elements of the structure must remain constant.
+ */
+struct variable1 {
+    u_char          magic;      /* passed to function as a hint */
+    u_char          type;       /* type of variable */
+    u_short         acl;        /* access control list for variable */
+    FindVarMethod  *findVar;    /* function that finds variable */
+    u_char          namelen;    /* length of name below */
+    oid             name[1];    /* object identifier of variable */
+};
+
+struct variable2 {
+    u_char          magic;      /* passed to function as a hint */
+    u_char          type;       /* type of variable */
+    u_short         acl;        /* access control list for variable */
+    FindVarMethod  *findVar;    /* function that finds variable */
+    u_char          namelen;    /* length of name below */
+    oid             name[2];    /* object identifier of variable */
+};
+
+struct variable3 {
+    u_char          magic;      /* passed to function as a hint */
+    u_char          type;       /* type of variable */
+    u_short         acl;        /* access control list for variable */
+    FindVarMethod  *findVar;    /* function that finds variable */
+    u_char          namelen;    /* length of name below */
+    oid             name[3];    /* object identifier of variable */
+};
+
+struct variable4 {
+    u_char          magic;      /* passed to function as a hint */
+    u_char          type;       /* type of variable */
+    u_short         acl;        /* access control list for variable */
+    FindVarMethod  *findVar;    /* function that finds variable */
+    u_char          namelen;    /* length of name below */
+    oid             name[4];    /* object identifier of variable */
+};
+
+struct variable7 {
+    u_char          magic;      /* passed to function as a hint */
+    u_char          type;       /* type of variable */
+    u_short         acl;        /* access control list for variable */
+    FindVarMethod  *findVar;    /* function that finds variable */
+    u_char          namelen;    /* length of name below */
+    oid             name[7];    /* object identifier of variable */
+};
+
+struct variable8 {
+    u_char          magic;      /* passed to function as a hint */
+    u_char          type;       /* type of variable */
+    u_short         acl;        /* access control list for variable */
+    FindVarMethod  *findVar;    /* function that finds variable */
+    u_char          namelen;    /* length of name below */
+    oid             name[8];    /* object identifier of variable */
+};
+
+struct variable13 {
+    u_char          magic;      /* passed to function as a hint */
+    u_char          type;       /* type of variable */
+    u_short         acl;        /* access control list for variable */
+    FindVarMethod  *findVar;    /* function that finds variable */
+    u_char          namelen;    /* length of name below */
+    oid             name[13];   /* object identifier of variable */
+};
+#endif                          /* VAR_STRUCT_H */
diff -rupN quagga-0.99.18//include/net-snmp/agent/watcher.h quaggasnmpTrap//include/net-snmp/agent/watcher.h
--- quagga-0.99.18//include/net-snmp/agent/watcher.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/agent/watcher.h	2009-11-19 14:52:10.000000000 -0800
@@ -0,0 +1,139 @@
+/*
+ * watcher.h 
+ */
+#ifndef NETSNMP_WATCHER_H
+#define NETSNMP_WATCHER_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** @ingroup watcher
+ *  @{
+ */
+
+/*
+ * if handler flag has this bit set, the timestamp will be
+ * treated as a pointer to the timestamp. If this bit is
+ * not set (the default), the timestamp is a struct timeval
+ * that must be compared to the agent starttime.
+ */
+#define NETSNMP_WATCHER_DIRECT MIB_HANDLER_CUSTOM1
+
+/** The size of the watched object is constant.
+ *  @hideinitializer
+ */
+#define WATCHER_FIXED_SIZE     0x01
+/** The maximum size of the watched object is stored in max_size.
+ *  If WATCHER_SIZE_STRLEN is set then it is supposed that max_size + 1
+ *  bytes could be stored in the buffer.
+ *  @hideinitializer
+ */
+#define WATCHER_MAX_SIZE       0x02
+/** If set then the variable data_size_p points to is supposed to hold the
+ *  current size of the watched object and will be updated on writes.
+ *  @hideinitializer
+ *  @since Net-SNMP 5.5
+ */
+#define WATCHER_SIZE_IS_PTR    0x04
+/** If set then data is suppposed to be a zero-terminated character array
+ *  and both data_size and data_size_p are ignored. Additionally \\0 is a
+ *  forbidden character in the data set.
+ *  @hideinitializer
+ *  @since Net-SNMP 5.5
+ */
+#define WATCHER_SIZE_STRLEN    0x08
+/** If set then size is in units of object identifiers.
+ *  This is useful if you have an OID and tracks the OID_LENGTH of it as
+ *  opposed to it's size.
+ *  @hideinitializer
+ *  @since Net-SNMP 5.5.1
+ */
+#define WATCHER_SIZE_UNIT_OIDS 0x10
+
+typedef struct netsnmp_watcher_info_s {
+    void     *data;
+    size_t    data_size;
+    size_t    max_size;
+    u_char    type;
+    int       flags;
+    size_t   *data_size_p;
+} netsnmp_watcher_info;
+
+/** @} */
+
+int netsnmp_register_watched_instance( netsnmp_handler_registration *reginfo,
+                                       netsnmp_watcher_info         *winfo);
+int netsnmp_register_watched_scalar(   netsnmp_handler_registration *reginfo,
+                                       netsnmp_watcher_info         *winfo);
+int netsnmp_register_watched_timestamp(netsnmp_handler_registration *reginfo,
+                                       marker_t timestamp);
+int netsnmp_watched_timestamp_register(netsnmp_mib_handler *whandler,
+                                       netsnmp_handler_registration *reginfo,
+                                       marker_t timestamp);
+int netsnmp_register_watched_spinlock(netsnmp_handler_registration *reginfo,
+                                      int *spinlock);    
+
+/*
+ * Convenience registration calls
+ */
+
+int netsnmp_register_ulong_scalar(const char *name,
+                              const oid * reg_oid, size_t reg_oid_len,
+                              u_long * it,
+                              Netsnmp_Node_Handler * subhandler);
+int netsnmp_register_read_only_ulong_scalar(const char *name,
+                              const oid * reg_oid, size_t reg_oid_len,
+                              u_long * it,
+                              Netsnmp_Node_Handler * subhandler);
+int netsnmp_register_long_scalar(const char *name,
+                              const oid * reg_oid, size_t reg_oid_len,
+                              long * it,
+                              Netsnmp_Node_Handler * subhandler);
+int netsnmp_register_read_only_long_scalar(const char *name,
+                              const oid * reg_oid, size_t reg_oid_len,
+                              long * it,
+                              Netsnmp_Node_Handler * subhandler);
+int netsnmp_register_int_scalar(const char *name,
+                              const oid * reg_oid, size_t reg_oid_len,
+                              int * it,
+                              Netsnmp_Node_Handler * subhandler);
+int netsnmp_register_read_only_int_scalar(const char *name,
+                              const oid * reg_oid, size_t reg_oid_len,
+                              int * it,
+                              Netsnmp_Node_Handler * subhandler);
+int netsnmp_register_read_only_counter32_scalar(const char *name,
+                              const oid * reg_oid, size_t reg_oid_len,
+                              u_long * it,
+                              Netsnmp_Node_Handler * subhandler);
+
+#define WATCHER_HANDLER_NAME "watcher"
+
+netsnmp_mib_handler  *netsnmp_get_watcher_handler(void);
+
+netsnmp_watcher_info *
+netsnmp_init_watcher_info(netsnmp_watcher_info *, void *, size_t, u_char, int);
+
+netsnmp_watcher_info *
+netsnmp_init_watcher_info6(netsnmp_watcher_info *,
+			   void *, size_t, u_char, int, size_t, size_t*);
+
+netsnmp_watcher_info *
+netsnmp_create_watcher_info(void *, size_t, u_char, int);
+
+netsnmp_watcher_info *
+netsnmp_create_watcher_info6(void *, size_t, u_char, int, size_t, size_t*);
+
+Netsnmp_Node_Handler  netsnmp_watcher_helper_handler;
+
+netsnmp_mib_handler  *netsnmp_get_watched_timestamp_handler(void);
+Netsnmp_Node_Handler  netsnmp_watched_timestamp_handler;
+
+netsnmp_mib_handler  *netsnmp_get_watched_spinlock_handler(void);
+Netsnmp_Node_Handler  netsnmp_watched_spinlock_handler;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /** NETSNMP_WATCHER_H */
diff -rupN quagga-0.99.18//include/net-snmp/config_api.h quaggasnmpTrap//include/net-snmp/config_api.h
--- quagga-0.99.18//include/net-snmp/config_api.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/config_api.h	2010-07-28 07:44:56.000000000 -0700
@@ -0,0 +1,100 @@
+#ifndef NET_SNMP_CONFIG_API_H
+#define NET_SNMP_CONFIG_API_H
+
+    /**
+     *  Library API routines concerned with configuration and control
+     *    of the behaviour of the library, agent and other applications.
+     */
+
+#include <net-snmp/types.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    /* Config Handlers */
+    NETSNMP_IMPORT
+    struct config_line *register_config_handler(const char *filePrefix,
+                                                const char *token,
+                                                void (*parser) (const char *, char *),
+                                                void (*releaser) (void),
+                                                const char *usageLine);
+    NETSNMP_IMPORT
+    struct config_line *register_const_config_handler(const char *filePrefix,
+                                  const char *token,
+                                  void (*parser) (const char *, const char *),
+                                  void (*releaser) (void),
+                                  const char *usageLine);
+    NETSNMP_IMPORT
+    struct config_line *register_prenetsnmp_mib_handler(const char *filePrefix,
+                                                const char *token,
+                                                void (*parser) (const char *, char *),
+                                                void (*releaser) (void),
+                                                const char *usageLine);
+    NETSNMP_IMPORT
+    void            unregister_config_handler(const char *filePrefix, const char *token);
+
+    				/* Defined in mib.c, rather than read_config.c */
+    void            register_mib_handlers(void);
+    void            unregister_all_config_handlers(void);
+
+    /* Application Handlers */
+    NETSNMP_IMPORT
+    struct config_line *register_app_config_handler(
+                                                const char *token,
+                                                void (*parser) (const char *, char *),
+                                                void (*releaser) (void),
+                                                const char *usageLine);
+
+    NETSNMP_IMPORT
+    struct config_line *register_app_prenetsnmp_mib_handler(
+                                                const char *token,
+                                                void (*parser) (const char *, char *),
+                                                void (*releaser) (void),
+                                                const char *usageLine);
+    NETSNMP_IMPORT
+    void            unregister_app_config_handler(                    const char *token);
+
+    /* Reading Config Files */
+    NETSNMP_IMPORT
+    void            read_configs(void);
+    NETSNMP_IMPORT
+    void            read_premib_configs(void);
+
+    /* Help Strings and Errors */
+    NETSNMP_IMPORT
+    void            read_config_print_usage(const char *lead);
+    NETSNMP_IMPORT
+    void            config_perror(const char *);
+    NETSNMP_IMPORT
+    void            config_pwarn(const char *);
+
+#ifdef __cplusplus
+}
+#endif
+
+    /*
+     *    Having extracted the main ("public API") calls relevant
+     *  to this area of the Net-SNMP project, the next step is to
+     *  identify the related "public internal API" routines.
+     *
+     *    In due course, these should probably be gathered
+     *  together into a companion 'library/config_api.h' header file.
+     *  [Or some suitable name]
+     *
+     *    But for the time being, the expectation is that the
+     *  traditional headers that provided the above definitions
+     *  will probably also cover the relevant internal API calls.
+     *  Hence they are listed here:
+     */
+#include <net-snmp/library/snmp_api.h>
+
+#include <net-snmp/library/read_config.h>
+#include <net-snmp/library/default_store.h>
+
+#include <stdio.h>              /* for FILE definition */
+#include <net-snmp/library/snmp_parse_args.h>
+#include <net-snmp/library/snmp_enum.h>
+#include <net-snmp/library/vacm.h>
+
+#endif                          /* NET_SNMP_CONFIG_API_H */
diff -rupN quagga-0.99.18//include/net-snmp/data_access/arp.h quaggasnmpTrap//include/net-snmp/data_access/arp.h
--- quagga-0.99.18//include/net-snmp/data_access/arp.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/data_access/arp.h	2009-12-09 06:37:16.000000000 -0800
@@ -0,0 +1,137 @@
+/*
+ * arp data access header
+ *
+ * $Id: arp.h 17892 2009-12-09 14:37:16Z jsafranek $
+ */
+#ifndef NETSNMP_ACCESS_ARP_H
+#define NETSNMP_ACCESS_ARP_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/**---------------------------------------------------------------------*/
+#if defined( NETSNMP_ENABLE_IPV6 )
+#   define NETSNMP_ACCESS_ARP_IPADDR_BUF_SIZE 16
+#else
+#   define NETSNMP_ACCESS_ARP_IPADDR_BUF_SIZE 4
+#endif
+
+/** MAC address is 6, InfiniBand uses more, 32 must be enough for near future.*/
+#define NETSNMP_ACCESS_ARP_PHYSADDR_BUF_SIZE 32
+
+/*************************************************************
+ * constants for enums for the MIB node
+ * inetNetToMediaType (INTEGER / ASN_INTEGER)
+ *
+ * since a Textual Convention may be referenced more than once in a
+ * MIB, protect againt redefinitions of the enum values.
+ */
+#ifndef inetNetToMediaType_ENUMS
+#define inetNetToMediaType_ENUMS
+
+#define INETNETTOMEDIATYPE_OTHER  1
+#define INETNETTOMEDIATYPE_INVALID  2
+#define INETNETTOMEDIATYPE_DYNAMIC  3
+#define INETNETTOMEDIATYPE_STATIC  4
+#define INETNETTOMEDIATYPE_LOCAL  5
+
+#endif                          /* inetNetToMediaType_ENUMS */
+
+/*************************************************************
+ * constants for enums for the MIB node
+ * inetNetToMediaState (INTEGER / ASN_INTEGER)
+ *
+ * since a Textual Convention may be referenced more than once in a
+ * MIB, protect againt redifinitions of the enum values.
+ */
+#ifndef inetNetToMediaState_ENUMS
+#define inetNetToMediaState_ENUMS
+
+#define INETNETTOMEDIASTATE_REACHABLE  1
+#define INETNETTOMEDIASTATE_STALE  2
+#define INETNETTOMEDIASTATE_DELAY  3
+#define INETNETTOMEDIASTATE_PROBE  4
+#define INETNETTOMEDIASTATE_INVALID  5
+#define INETNETTOMEDIASTATE_UNKNOWN  6
+#define INETNETTOMEDIASTATE_INCOMPLETE  7
+
+#endif                          /* inetNetToMediaState_ENUMS */
+
+/**---------------------------------------------------------------------*/
+/*
+ * structure definitions
+ */
+/*
+ * netsnmp_arp_entry
+ *   - primary arp structure for both ipv4 & ipv6
+ */
+typedef struct netsnmp_arp_s {
+
+   netsnmp_index oid_index;      /* MUST BE FIRST!! for container use */
+   oid           ns_arp_index;  /* arbitrary index */
+
+   int       flags; /* for net-snmp use */
+
+   oid       if_index;
+
+   u_char    arp_physaddress[NETSNMP_ACCESS_ARP_PHYSADDR_BUF_SIZE];
+   u_char    arp_ipaddress[NETSNMP_ACCESS_ARP_IPADDR_BUF_SIZE];
+
+   u_char    arp_physaddress_len;/* phys address len, max 32 */
+   u_char    arp_ipaddress_len;  /* ip address len, 4 | 16 */
+   u_char    arp_type;           /* inetNetToMediaType 1-5 */
+   u_char    arp_state;          /* inetNetToMediaState 1-7 */
+
+   u_long    arp_last_updated;   /* timeticks of last update */
+} netsnmp_arp_entry;
+
+
+/**---------------------------------------------------------------------*/
+/*
+ * ACCESS function prototypes
+ */
+/*
+ * ifcontainer init
+ */
+netsnmp_container * netsnmp_access_arp_container_init(u_int init_flags);
+#define NETSNMP_ACCESS_ARP_INIT_NOFLAGS               0x0000
+
+/*
+ * ifcontainer load and free
+ */
+netsnmp_container*
+netsnmp_access_arp_container_load(netsnmp_container* container,
+                                    u_int load_flags);
+#define NETSNMP_ACCESS_ARP_LOAD_NOFLAGS               0x0000
+
+void netsnmp_access_arp_container_free(netsnmp_container *container,
+                                         u_int free_flags);
+#define NETSNMP_ACCESS_ARP_FREE_NOFLAGS               0x0000
+#define NETSNMP_ACCESS_ARP_FREE_DONT_CLEAR            0x0001
+#define NETSNMP_ACCESS_ARP_FREE_KEEP_CONTAINER        0x0002
+
+
+/*
+ * create/free a arp+entry
+ */
+netsnmp_arp_entry *
+netsnmp_access_arp_entry_create(void);
+
+void netsnmp_access_arp_entry_free(netsnmp_arp_entry * entry);
+
+void netsnmp_access_arp_entry_update(netsnmp_arp_entry *entry,
+        netsnmp_arp_entry *new_data);
+
+/*
+ * find entry in container
+ */
+/** not yet */
+
+/**---------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETSNMP_ACCESS_ARP_H */
diff -rupN quagga-0.99.18//include/net-snmp/data_access/defaultrouter.h quaggasnmpTrap//include/net-snmp/data_access/defaultrouter.h
--- quagga-0.99.18//include/net-snmp/data_access/defaultrouter.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/data_access/defaultrouter.h	2007-05-28 05:02:14.000000000 -0700
@@ -0,0 +1,114 @@
+/*
+ * defaultrouter data access header
+ *
+ * $Id:$
+ */
+#ifndef NETSNMP_ACCESS_DEFAULTROUTER_H
+#define NETSNMP_ACCESS_DEFAULTROUTER_H
+
+# ifdef __cplusplus
+extern          "C" {
+#endif
+
+/**---------------------------------------------------------------------*/
+/*
+ * structure definitions
+ */
+#if defined( NETSNMP_ENABLE_IPV6 )
+#   define NETSNMP_ACCESS_DEFAULTROUTER_BUF_SIZE 16   /* XXX: 20, for ip6z? */
+#else
+#   define NETSNMP_ACCESS_DEFAULTROUTER_BUF_SIZE 4
+#endif
+
+
+/*
+ * netsnmp_default_route_entry
+ */
+typedef struct netsnmp_defaultrouter_s {
+
+    netsnmp_index oid_index;   /* MUST BE FIRST!! for container use */
+    oid           ns_dr_index; /* arbitrary index */
+
+    int      flags; /* for net-snmp use */
+
+    /*
+     * mib related data
+     */
+    u_char   dr_addresstype;    /* ipDefaultRouterAddressType */
+    char     dr_address[NETSNMP_ACCESS_DEFAULTROUTER_BUF_SIZE]; /* ipDefaultRouterAddress */
+    size_t   dr_address_len;    /* length of ipDefaultRouterAddress */
+    oid      dr_if_index;       /* ipDefaultRouterIfIndex */
+    uint32_t dr_lifetime;       /* ipDefaultRouterLifetime (0-65535) */
+    char     dr_preference;     /* ipDefaultRouterPreference (-2,-1,0,1) */
+
+} netsnmp_defaultrouter_entry;
+
+
+/**---------------------------------------------------------------------*/
+/*
+ * ACCESS function prototypes
+ */
+/*
+ * container init
+ */
+netsnmp_container *
+netsnmp_access_defaultrouter_container_init(u_int flags);
+#define NETSNMP_ACCESS_DEFAULTROUTER_INIT_NOFLAGS               0x0000
+#define NETSNMP_ACCESS_DEFAULTROUTER_INIT_ADDL_IDX_BY_ADDR      0x0001
+
+/*
+ * container load
+ */
+netsnmp_container*
+netsnmp_access_defaultrouter_container_load(netsnmp_container* container,
+                                            u_int load_flags);
+#define NETSNMP_ACCESS_DEFAULTROUTER_LOAD_NOFLAGS               0x0000
+#define NETSNMP_ACCESS_DEFAULTROUTER_LOAD_IPV4_ONLY             0x0001
+#define NETSNMP_ACCESS_DEFAULTROUTER_LOAD_IPV6_ONLY             0x0002
+#define NETSNMP_ACCESS_DEFAULTROUTER_LOAD_ADDL_IDX_BY_ADDR      0x0004
+
+/*
+ * container free
+ */
+void
+netsnmp_access_defaultrouter_container_free(netsnmp_container *container,
+                                            u_int free_flags);
+#define NETSNMP_ACCESS_DEFAULTROUTER_FREE_NOFLAGS               0x0000
+#define NETSNMP_ACCESS_DEFAULTROUTER_FREE_DONT_CLEAR            0x0001
+#define NETSNMP_ACCESS_DEFAULTROUTER_FREE_KEEP_CONTAINER        0x0002
+
+/*
+ * entry create
+ */
+netsnmp_defaultrouter_entry *
+netsnmp_access_defaultrouter_entry_create(void);
+
+/*
+ * entry load
+ */
+int
+netsnmp_access_defaultrouter_entry_load(size_t *num_entries,
+                                        netsnmp_defaultrouter_entry **entries);
+
+/*
+ * entry update
+ */
+int
+netsnmp_access_defaultrouter_entry_update(netsnmp_defaultrouter_entry *lhs,
+                                          netsnmp_defaultrouter_entry *rhs);
+
+/*
+ * entry free
+ */
+void
+netsnmp_access_defaultrouter_entry_free(netsnmp_defaultrouter_entry *entry);
+
+
+
+/**---------------------------------------------------------------------*/
+
+# ifdef __cplusplus
+}
+#endif
+
+#endif /* NETSNMP_ACCESS_DEFAULTROUTER_H */
diff -rupN quagga-0.99.18//include/net-snmp/data_access/interface.h quaggasnmpTrap//include/net-snmp/data_access/interface.h
--- quagga-0.99.18//include/net-snmp/data_access/interface.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/data_access/interface.h	2010-05-27 04:19:06.000000000 -0700
@@ -0,0 +1,303 @@
+/*
+ * interface data access header
+ *
+ * $Id: interface.h 18886 2010-05-27 11:19:06Z jsafranek $
+ */
+#ifndef NETSNMP_ACCESS_INTERFACE_H
+#define NETSNMP_ACCESS_INTERFACE_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/*
+ * define flags to indicate the availability of certain data
+ */
+#define NETSNMP_INTERFACE_FLAGS_ACTIVE			0x00000001
+#define NETSNMP_INTERFACE_FLAGS_HAS_BYTES		0x00000002
+#define NETSNMP_INTERFACE_FLAGS_HAS_DROPS		0x00000004
+#define NETSNMP_INTERFACE_FLAGS_HAS_MCAST_PKTS		0x00000008
+#define NETSNMP_INTERFACE_FLAGS_HAS_HIGH_BYTES		0x00000010
+#define NETSNMP_INTERFACE_FLAGS_HAS_HIGH_PACKETS	0x00000020
+#define NETSNMP_INTERFACE_FLAGS_HAS_HIGH_SPEED		0x00000040
+#define NETSNMP_INTERFACE_FLAGS_DYNAMIC_SPEED		0x00000080
+#define NETSNMP_INTERFACE_FLAGS_HAS_LASTCHANGE		0x00000100
+#define NETSNMP_INTERFACE_FLAGS_HAS_DISCONTINUITY	0x00000200
+#define NETSNMP_INTERFACE_FLAGS_HAS_IF_FLAGS      	0x00000400
+#define NETSNMP_INTERFACE_FLAGS_CAN_DOWN_PROTOCOL       0x00000800
+#define NETSNMP_INTERFACE_FLAGS_HAS_IPV4                0x00001000
+#define NETSNMP_INTERFACE_FLAGS_HAS_IPV6                0x00002000
+#define NETSNMP_INTERFACE_FLAGS_HAS_V4_RETRANSMIT       0x00004000
+#define NETSNMP_INTERFACE_FLAGS_HAS_V4_REASMMAX         0x00008000
+#define NETSNMP_INTERFACE_FLAGS_HAS_V6_RETRANSMIT       0x00010000
+#define NETSNMP_INTERFACE_FLAGS_HAS_V6_REASMMAX         0x00020000
+#define NETSNMP_INTERFACE_FLAGS_HAS_V6_REACHABLE        0x00040000
+#define NETSNMP_INTERFACE_FLAGS_HAS_V6_IFID             0x00080000
+#define NETSNMP_INTERFACE_FLAGS_HAS_V6_FORWARDING       0x00100000
+/* Some platforms, e.g.Linux, do not provide standalone counter
+ * for incoming unicast packets - they provide counter of all packets
+ * + separate counter for the multicast ones.
+ * That means the counter of all packets must watched and checked
+ * for overflows to reconstruct its 64-bit value (i.e. as usual
+ * for counter of unicast packets), and after its expansion to 64-bits,
+ * nr.of multicast packets must be substracted to get nr. of unicast
+ * packets.
+ * This flag marks stats of such platforms. Nr. of all incoming packets,
+ * provided by the platform, must be stored in
+ * netsnmp_interface_stats.iall and netsnmp_interface_stats.iucast will
+ * be automatically calculated later.
+ */
+#define NETSNMP_INTERFACE_FLAGS_CALCULATE_UCAST         0x00200000
+
+/*************************************************************
+ * constants for enums for the MIB node
+ * ifAdminStatus (INTEGER / ASN_INTEGER)
+ *
+ * since a Textual Convention may be referenced more than once in a
+ * MIB, protect againt redifinitions of the enum values.
+ */
+#ifndef ifAdminStatus_ENUMS
+#define ifAdminStatus_ENUMS
+
+#define IFADMINSTATUS_UP  1
+#define IFADMINSTATUS_DOWN  2
+#define IFADMINSTATUS_TESTING  3
+
+#endif                          /* ifAdminStatus_ENUMS */
+
+/*************************************************************
+ * constants for enums for the MIB node
+ * ifOperStatus (INTEGER / ASN_INTEGER)
+ *
+ * since a Textual Convention may be referenced more than once in a
+ * MIB, protect againt redifinitions of the enum values.
+ */
+#ifndef ifOperStatus_ENUMS
+#define ifOperStatus_ENUMS
+
+#define IFOPERSTATUS_UP  1
+#define IFOPERSTATUS_DOWN  2
+#define IFOPERSTATUS_TESTING  3
+#define IFOPERSTATUS_UNKNOWN  4
+#define IFOPERSTATUS_DORMANT  5
+#define IFOPERSTATUS_NOTPRESENT 6
+#define IFOPERSTATUS_LOWERLAYERDOWN 7
+
+#endif                          /* ifOperStatus_ENUMS */
+
+/* nominal speed of network interface - used when the real speed is unknown */
+#define NOMINAL_LINK_SPEED 10000000
+
+/**---------------------------------------------------------------------*/
+/*
+ * structure definitions
+ *
+ * NOTE: if you add fields, update code dealing with
+ *       stats in interface_common.c, particularly
+ *       netsnmp_access_interface_entry_update_stats()
+ *
+ */
+typedef struct netsnmp_interface_stats_s {
+    /*
+     *  "Dynamic" fields
+     *  Cached versions of byte/packet counters, etc
+     *  (saved as a 'struct counter64' even if the
+     *   high order half isn't actually used)
+     *
+     */
+   /** input */
+    struct counter64 ibytes;
+    /*
+     * nr. of all packets (to calculate iucast, when underlying platform does
+     * not provide it)
+     */
+    struct counter64 iall;
+    struct counter64 iucast;
+    struct counter64 imcast;
+    struct counter64 ibcast;
+    unsigned int     ierrors;
+    unsigned int     idiscards;
+    unsigned int     iunknown_protos;
+    unsigned int     inucast;
+   /** output */
+    struct counter64 obytes;
+    struct counter64 oucast;
+    struct counter64 omcast;
+    struct counter64 obcast;
+    unsigned int     oerrors;
+    unsigned int     odiscards;
+    unsigned int     oqlen;
+    unsigned int     collisions;
+    unsigned int     onucast;
+} netsnmp_interface_stats;
+
+/*
+ *
+ * NOTE: if you add fields, update code dealing with
+ *       them in interface_common.c, particularly
+ *       netsnmp_access_interface_entry_copy().
+ */
+typedef struct netsnmp_interface_entry_s {
+    netsnmp_index oid_index;
+
+    u_int   ns_flags; /* net-snmp flags */
+    oid     index;
+
+    /*
+     *  "Static" information
+     *  Typically constant for a given interface
+     */
+    char   *name;
+    char   *descr;
+    int     type;
+    u_int   speed;
+    u_int   speed_high;
+    char   *paddr;
+    u_int   paddr_len;
+    u_int   mtu;
+
+    u_int   retransmit_v4; /* milliseconds */
+    u_int   retransmit_v6; /* milliseconds */
+
+    u_int   reachable_time; /* ipv6 / milliseconds */
+
+    u_long  lastchange;
+    time_t  discontinuity;
+
+    uint16_t     reasm_max_v4; /* 0..65535 */
+    uint16_t     reasm_max_v6; /* 1500..65535 */
+    char  admin_status;
+    char  oper_status;
+
+    /** booleans (not TruthValues!) */
+    char  promiscuous;
+    char  connector_present;
+    char  forwarding_v6;
+
+    char    v6_if_id_len;
+    u_char  v6_if_id[8];
+
+    /*-----------------------------------------------
+     * platform/arch/access specific data
+     */
+    u_int os_flags; /* iff NETSNMP_INTERFACE_FLAGS_HAS_IF_FLAGS */
+
+    /*
+     * statistics
+     */
+    netsnmp_interface_stats stats;
+
+    /** old_stats is used in netsnmp_access_interface_entry_update_stats */
+    netsnmp_interface_stats *old_stats;
+
+} netsnmp_interface_entry;
+
+/*
+ * conf file overrides
+ */
+typedef struct _conf_if_list {
+    const char     *name;
+    int             type;
+    uint64_t speed;
+    struct _conf_if_list *next;
+} netsnmp_conf_if_list;
+
+    typedef netsnmp_conf_if_list conf_if_list; /* backwards compat */
+
+/**---------------------------------------------------------------------*/
+/*
+ * ACCESS function prototypes
+ */
+void init_interface(void);
+void netsnmp_access_interface_init(void);
+
+/*
+ * ifcontainer init
+ */
+netsnmp_container * netsnmp_access_interface_container_init(u_int init_flags);
+#define NETSNMP_ACCESS_INTERFACE_INIT_NOFLAGS               0x0000
+#define NETSNMP_ACCESS_INTERFACE_INIT_ADDL_IDX_BY_NAME      0x0001
+
+/*
+ * ifcontainer load and free
+ */
+netsnmp_container*
+netsnmp_access_interface_container_load(netsnmp_container* container,
+                                        u_int load_flags);
+#define NETSNMP_ACCESS_INTERFACE_LOAD_NOFLAGS               0x0000
+#define NETSNMP_ACCESS_INTERFACE_LOAD_NO_STATS              0x0001
+#define NETSNMP_ACCESS_INTERFACE_LOAD_IP4_ONLY              0x0002
+#define NETSNMP_ACCESS_INTERFACE_LOAD_IP6_ONLY              0x0004
+
+void netsnmp_access_interface_container_free(netsnmp_container *container,
+                                             u_int free_flags);
+#define NETSNMP_ACCESS_INTERFACE_FREE_NOFLAGS               0x0000
+#define NETSNMP_ACCESS_INTERFACE_FREE_DONT_CLEAR            0x0001
+
+
+/*
+ * create/free an ifentry
+ */
+netsnmp_interface_entry *
+netsnmp_access_interface_entry_create(const char *name, oid if_index);
+
+void netsnmp_access_interface_entry_free(netsnmp_interface_entry * entry);
+
+int
+netsnmp_access_interface_entry_set_admin_status(netsnmp_interface_entry * entry,
+	                                                int ifAdminStatus);
+
+/*
+ * find entry in container
+ */
+netsnmp_interface_entry *
+netsnmp_access_interface_entry_get_by_name(netsnmp_container *container,
+                                           const char *name);
+netsnmp_interface_entry *
+netsnmp_access_interface_entry_get_by_index(netsnmp_container *container,
+                                            oid index);
+
+/*
+ * find ifIndex for given interface. 0 == not found.
+ */
+oid netsnmp_access_interface_index_find(const char *name);
+
+/*
+ * find name for given index
+ */
+const char *netsnmp_access_interface_name_find(oid index);
+
+/*
+ * copy interface entry data
+ */
+int netsnmp_access_interface_entry_copy(netsnmp_interface_entry * lhs,
+                                        netsnmp_interface_entry * rhs);
+
+/*
+ * utility routines
+ */
+void netsnmp_access_interface_entry_guess_speed(netsnmp_interface_entry *);
+void netsnmp_access_interface_entry_overrides(netsnmp_interface_entry *);
+
+
+netsnmp_conf_if_list *
+netsnmp_access_interface_entry_overrides_get(const char * name);
+
+/**---------------------------------------------------------------------*/
+
+#if defined( USING_IF_MIB_IFTABLE_IFTABLE_DATA_ACCESS_MODULE ) && \
+    ! defined( NETSNMP_NO_BACKWARDS_COMPATABILITY )
+void
+Interface_Scan_Init(void);
+int
+Interface_Scan_Next(short *index, char *name, netsnmp_interface_entry **entry,
+                    void *dc);
+#endif
+
+/**---------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETSNMP_ACCESS_INTERFACE_H */
diff -rupN quagga-0.99.18//include/net-snmp/data_access/ipaddress.h quaggasnmpTrap//include/net-snmp/data_access/ipaddress.h
--- quagga-0.99.18//include/net-snmp/data_access/ipaddress.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/data_access/ipaddress.h	2008-02-22 16:59:03.000000000 -0800
@@ -0,0 +1,168 @@
+/*
+ * ipaddress data access header
+ *
+ * $Id: ipaddress.h 16831 2008-02-23 00:59:03Z hardaker $
+ */
+#ifndef NETSNMP_ACCESS_IPADDRESS_H
+#define NETSNMP_ACCESS_IPADDRESS_H
+
+# ifdef __cplusplus
+extern          "C" {
+#endif
+
+/**---------------------------------------------------------------------*/
+/*
+ * structure definitions
+ */
+#if defined( NETSNMP_ENABLE_IPV6 )
+#   define NETSNMP_ACCESS_IPADDRESS_BUF_SIZE 16   /* xxx-rks: 20, for ip6z? */
+#else
+#   define NETSNMP_ACCESS_IPADDRESS_BUF_SIZE 4
+#endif
+
+
+/*
+ * netsnmp_ipaddress_entry
+ *   - primary ipaddress structure for both ipv4 & ipv6
+ */
+typedef struct netsnmp_ipaddress_s {
+
+   netsnmp_index oid_index;   /* MUST BE FIRST!! for container use */
+   oid           ns_ia_index; /* arbitrary index */
+
+   int       flags; /* for net-snmp use */
+
+   /*
+    * mib related data (considered for
+    *  netsnmp_access_ipaddress_entry_update)
+    */
+
+   u_char    ia_address[NETSNMP_ACCESS_IPADDRESS_BUF_SIZE];
+
+   oid       if_index;
+
+   u_char    ia_address_len;/* address len, 4 | 16 */
+   u_char    ia_prefix_len; /* 1-128 bits */
+   u_char    ia_type;       /* 1-3 */
+   u_char    ia_status;     /* IpAddressStatus (1-7) */
+   u_char    ia_origin;     /* IpAddressOrigin (1-6) */
+   u_char    ia_storagetype; /* IpAddressStorageType (1-5) */
+   u_char    ia_onlink_flag; /* IpOnlinkFlag */
+   u_char    ia_autonomous_flag; /*IpAutonomousFlag */
+   u_long    ia_prefered_lifetime;/*IpPreferedLifeTime*/
+   u_long    ia_valid_lifetime;/*IpValidLifeTime*/
+   netsnmp_data_list *arch_data;      /* arch specific data */
+
+} netsnmp_ipaddress_entry;
+
+
+/**---------------------------------------------------------------------*/
+/*
+ * ACCESS function prototypes
+ */
+/*
+ * ifcontainer init
+ */
+netsnmp_container * netsnmp_access_ipaddress_container_init(u_int init_flags);
+#define NETSNMP_ACCESS_IPADDRESS_INIT_NOFLAGS               0x0000
+#define NETSNMP_ACCESS_IPADDRESS_INIT_ADDL_IDX_BY_ADDR      0x0001
+
+/*
+ * ifcontainer load and free
+ */
+netsnmp_container*
+netsnmp_access_ipaddress_container_load(netsnmp_container* container,
+                                    u_int load_flags);
+#define NETSNMP_ACCESS_IPADDRESS_LOAD_NOFLAGS               0x0000
+#define NETSNMP_ACCESS_IPADDRESS_LOAD_IPV4_ONLY             0x0001
+#define NETSNMP_ACCESS_IPADDRESS_LOAD_IPV6_ONLY             0x0002
+#define NETSNMP_ACCESS_IPADDRESS_LOAD_ADDL_IDX_BY_ADDR      0x0004
+
+void netsnmp_access_ipaddress_container_free(netsnmp_container *container,
+                                         u_int free_flags);
+#define NETSNMP_ACCESS_IPADDRESS_FREE_NOFLAGS               0x0000
+#define NETSNMP_ACCESS_IPADDRESS_FREE_DONT_CLEAR            0x0001
+#define NETSNMP_ACCESS_IPADDRESS_FREE_KEEP_CONTAINER        0x0002
+
+
+/*
+ * create/free a ipaddress+entry
+ */
+netsnmp_ipaddress_entry *
+netsnmp_access_ipaddress_entry_create(void);
+
+void netsnmp_access_ipaddress_entry_free(netsnmp_ipaddress_entry * entry);
+
+/*
+ * copy
+ */
+int
+netsnmp_access_ipaddress_entry_copy(netsnmp_ipaddress_entry *old, 
+                                    netsnmp_ipaddress_entry *new_val);
+
+/*
+ * update/compare
+ */
+int
+netsnmp_access_ipaddress_entry_update(netsnmp_ipaddress_entry *old, 
+                                      netsnmp_ipaddress_entry *new_val);
+
+/*
+ * find entry in container
+ */
+/** not yet */
+
+/*
+ * create/change/delete
+ */
+int
+netsnmp_access_ipaddress_entry_set(netsnmp_ipaddress_entry * entry);
+
+
+/*
+ * ipaddress flags
+ *   upper bits for internal use
+ *   lower bits indicate changed fields. see FLAG_IPADDRESS* definitions in
+ *         ipAddressTable_constants.h
+ */
+#define NETSNMP_ACCESS_IPADDRESS_CREATE     0x80000000
+#define NETSNMP_ACCESS_IPADDRESS_DELETE     0x40000000
+#define NETSNMP_ACCESS_IPADDRESS_CHANGE     0x20000000
+
+#define NETSNMP_ACCESS_IPADDRESS_ISALIAS    0x10000000
+
+/* 
+ * mask for change flag bits
+ */
+#define NETSNMP_ACCESS_IPADDRESS_RESERVED_BITS 0x0000001f
+
+
+/*
+ * utility routines
+ */
+int netsnmp_ipaddress_prefix_copy(u_char *dst, u_char *src, 
+                                  int addr_len, int pfx_len);
+
+int netsnmp_ipaddress_ipv4_prefix_len(in_addr_t mask);
+
+int netsnmp_ipaddress_flags_copy(u_long *ipAddressPrefixAdvPreferredLifetime,
+                                 u_long *ipAddressPrefixAdvValidLifetime,
+                                 u_long *ipAddressPrefixOnLinkFlag,
+                                 u_long *ipAddressPrefixAutonomousFlag,
+                                 u_long *ia_prefered_lifetime,
+                                 u_long *ia_valid_lifetime,
+                                 u_char *ia_onlink_flag,
+                                 u_char *ia_autonomous_flag);
+
+int netsnmp_ipaddress_prefix_origin_copy(u_long *ipAddressPrefixOrigin,
+                                         u_char ia_origin,
+                                         int flags,
+                                         u_long ipAddressAddrType);
+
+/**---------------------------------------------------------------------*/
+
+# ifdef __cplusplus
+}
+#endif
+
+#endif /* NETSNMP_ACCESS_IPADDRESS_H */
diff -rupN quagga-0.99.18//include/net-snmp/data_access/ip_scalars.h quaggasnmpTrap//include/net-snmp/data_access/ip_scalars.h
--- quagga-0.99.18//include/net-snmp/data_access/ip_scalars.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/data_access/ip_scalars.h	2010-01-03 08:26:19.000000000 -0800
@@ -0,0 +1,19 @@
+#ifndef NETSNMP_ACCESS_IP_SCALARS_H
+#define NETSNMP_ACCESS_IP_SCALARS_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+int netsnmp_arch_ip_scalars_ipForwarding_get(u_long *value);
+int netsnmp_arch_ip_scalars_ipForwarding_set(u_long value);
+
+int netsnmp_arch_ip_scalars_ipv6IpForwarding_get(u_long *value);
+int netsnmp_arch_ip_scalars_ipv6IpForwarding_set(u_long value);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETSNMP_ACCESS_IP_SCALARS_H */
diff -rupN quagga-0.99.18//include/net-snmp/data_access/ipstats.h quaggasnmpTrap//include/net-snmp/data_access/ipstats.h
--- quagga-0.99.18//include/net-snmp/data_access/ipstats.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/data_access/ipstats.h	2008-10-15 05:57:09.000000000 -0700
@@ -0,0 +1,110 @@
+/*
+ * ipstats data access header
+ *
+ * $Id: ipstats.h 17260 2008-10-15 12:57:09Z jsafranek $
+ */
+#ifndef NETSNMP_ACCESS_IPSTATS_H
+#define NETSNMP_ACCESS_IPSTATS_H
+
+# ifdef __cplusplus
+extern          "C" {
+#endif
+
+#define IPSYSTEMSTATSTABLE_HCINRECEIVES       1
+#define IPSYSTEMSTATSTABLE_HCINOCTETS         2
+#define IPSYSTEMSTATSTABLE_INHDRERRORS        3
+#define IPSYSTEMSTATSTABLE_HCINNOROUTES       4 
+#define IPSYSTEMSTATSTABLE_INADDRERRORS       5
+#define IPSYSTEMSTATSTABLE_INUNKNOWNPROTOS    6
+#define IPSYSTEMSTATSTABLE_INTRUNCATEDPKTS    7
+#define IPSYSTEMSTATSTABLE_HCINFORWDATAGRAMS  8 
+#define IPSYSTEMSTATSTABLE_REASMREQDS         9
+#define IPSYSTEMSTATSTABLE_REASMOKS           10
+#define IPSYSTEMSTATSTABLE_REASMFAILS         11
+#define IPSYSTEMSTATSTABLE_INDISCARDS         12
+#define IPSYSTEMSTATSTABLE_HCINDELIVERS       13
+#define IPSYSTEMSTATSTABLE_HCOUTREQUESTS      14
+#define IPSYSTEMSTATSTABLE_HCOUTNOROUTES      15
+#define IPSYSTEMSTATSTABLE_HCOUTFORWDATAGRAMS 16
+#define IPSYSTEMSTATSTABLE_HCOUTDISCARDS      17
+#define IPSYSTEMSTATSTABLE_HCOUTFRAGREQDS     18
+#define IPSYSTEMSTATSTABLE_HCOUTFRAGOKS       19
+#define IPSYSTEMSTATSTABLE_HCOUTFRAGFAILS     20
+#define IPSYSTEMSTATSTABLE_HCOUTFRAGCREATES   21
+#define IPSYSTEMSTATSTABLE_HCOUTTRANSMITS     22
+#define IPSYSTEMSTATSTABLE_HCOUTOCTETS        23
+#define IPSYSTEMSTATSTABLE_HCINMCASTPKTS      24
+#define IPSYSTEMSTATSTABLE_HCINMCASTOCTETS    25
+#define IPSYSTEMSTATSTABLE_HCOUTMCASTPKTS     26
+#define IPSYSTEMSTATSTABLE_HCOUTMCASTOCTETS   27
+#define IPSYSTEMSTATSTABLE_HCINBCASTPKTS      28
+#define IPSYSTEMSTATSTABLE_HCOUTBCASTPKTS     29
+#define IPSYSTEMSTATSTABLE_DISCONTINUITYTIME  30
+#define IPSYSTEMSTATSTABLE_REFRESHRATE        31
+    
+#define IPSYSTEMSTATSTABLE_LAST IPSYSTEMSTATSTABLE_REFRESHRATE
+    
+/**---------------------------------------------------------------------*/
+/*
+ * structure definitions
+ */
+
+/*
+ * netsnmp_ipstats_entry
+ */
+typedef struct netsnmp_ipstats_s {
+
+   /* Columns of ipStatsTable. Some of them are HC for computation of the 
+    * other columns, when underlying OS does not provide them.
+    * Always fill at least 32 bits, the table is periodically polled -> 32 bit
+    * overflow shall be detected and 64 bit value should be computed automatically. */
+   U64             HCInReceives;
+   U64             HCInOctets;
+   u_long          InHdrErrors;
+   U64             HCInNoRoutes; 
+   u_long          InAddrErrors;
+   u_long          InUnknownProtos;
+   u_long          InTruncatedPkts;
+   
+   /* optional, can be computed from HCInNoRoutes and HCOutForwDatagrams */
+   U64             HCInForwDatagrams; 
+   
+   u_long          ReasmReqds;
+   u_long          ReasmOKs;
+   u_long          ReasmFails;
+   u_long          InDiscards;
+   U64             HCInDelivers;
+   U64             HCOutRequests;
+   U64             HCOutNoRoutes;
+   U64             HCOutForwDatagrams;
+   U64             HCOutDiscards;
+   
+   /* optional, can be computed from HCOutFragOKs + HCOutFragFails*/
+   U64             HCOutFragReqds;
+   U64             HCOutFragOKs;
+   U64             HCOutFragFails;
+   U64             HCOutFragCreates;
+   
+   /* optional, can be computed from 
+    * HCOutRequests +HCOutForwDatagrams + HCOutFragCreates
+    * - HCOutFragReqds - HCOutNoRoutes  - HCOutDiscards */
+   U64             HCOutTransmits;
+   
+   U64             HCOutOctets;
+   U64             HCInMcastPkts;
+   U64             HCInMcastOctets;
+   U64             HCOutMcastPkts;
+   U64             HCOutMcastOctets;
+   U64             HCInBcastPkts;
+   U64             HCOutBcastPkts;
+
+   /* Array of available columns.*/
+   int             columnAvail[IPSYSTEMSTATSTABLE_LAST+1];
+} netsnmp_ipstats;
+
+
+# ifdef __cplusplus
+}
+#endif
+
+#endif /* NETSNMP_ACCESS_IPSTATS_H */
diff -rupN quagga-0.99.18//include/net-snmp/data_access/net-snmp-data-access-includes.h quaggasnmpTrap//include/net-snmp/data_access/net-snmp-data-access-includes.h
--- quagga-0.99.18//include/net-snmp/data_access/net-snmp-data-access-includes.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/data_access/net-snmp-data-access-includes.h	2004-07-10 13:02:16.000000000 -0700
@@ -0,0 +1,14 @@
+/*
+ * A simple helpful wrapper to include data access includes.
+ */
+#ifndef NETSNMP_DATA_ACCESS_INCLUDES
+#define NETSNMP_DATA_ACCESS_INCLUDES
+
+#include <net-snmp/data_access/arp.h>
+#include <net-snmp/data_access/interface.h>
+#include <net-snmp/data_access/ipaddress.h>
+#include <net-snmp/data_access/route.h>
+#include <net-snmp/data_access/ipstats.h>
+#include <net-snmp/data_access/systemstats.h>
+
+#endif /* NETSNMP_DATA_ACCESS_INCLUDES */
diff -rupN quagga-0.99.18//include/net-snmp/data_access/route.h quaggasnmpTrap//include/net-snmp/data_access/route.h
--- quagga-0.99.18//include/net-snmp/data_access/route.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/data_access/route.h	2010-11-17 11:57:42.000000000 -0800
@@ -0,0 +1,158 @@
+/*
+ * route data access header
+ *
+ * $Id: route.h 19685 2010-11-17 19:57:42Z nba $
+ */
+#ifndef NETSNMP_ACCESS_ROUTE_H
+#define NETSNMP_ACCESS_ROUTE_H
+
+# ifdef __cplusplus
+extern          "C" {
+#endif
+
+/**---------------------------------------------------------------------*/
+/*
+ * structure definitions
+ */
+#if defined( NETSNMP_ENABLE_IPV6 )
+#   define NETSNMP_ACCESS_ROUTE_ADDR_BUF_SIZE 16
+#else
+#   define NETSNMP_ACCESS_ROUTE_ADDR_BUF_SIZE 4
+#endif
+
+
+/*
+ * netsnmp_route_entry
+ *   - primary route structure for both ipv4 & ipv6
+ */
+typedef struct netsnmp_route_s {
+
+   netsnmp_index oid_index;   /* MUST BE FIRST!! for container use */
+   oid           ns_rt_index; /* arbitrary index */
+
+   int       flags; /* for net-snmp use */
+
+   oid       if_index;
+
+    /*
+     * addresses, in network byte order
+     */
+   u_char    rt_dest[NETSNMP_ACCESS_ROUTE_ADDR_BUF_SIZE];
+   u_char    rt_nexthop[NETSNMP_ACCESS_ROUTE_ADDR_BUF_SIZE];
+
+#ifdef USING_IP_FORWARD_MIB_INETCIDRROUTETABLE_INETCIDRROUTETABLE_MODULE
+   /*
+    * define the maximum oid length for a policy, for use by the
+    * inetCidrRouteTable. Must be at least 2, for default nullOid case.
+    */
+#define NETSNMP_POLICY_OID_MAX_LEN  3
+   oid      *rt_policy;      /* NULL should be interpreted as { 0, 0 } */
+   u_char    rt_policy_len;  /* 0-128 oids */
+#endif
+
+   u_char    rt_dest_len;    /* 4 | 16 since we only do ipv4|ipv6 */
+   u_char    rt_dest_type;   /* InetAddressType 0-16 */
+   u_char    rt_nexthop_len; /* 4 | 16 since we only do ipv4|ipv6*/
+   u_char    rt_nexthop_type;/* InetAddressType 0-16 */
+   u_char    rt_pfx_len;     /* 0-128 bits */
+   u_char    rt_type;        /* ip(1-4) != inet(1-5) */
+   u_char    rt_proto;       /* ip(enum 1-16) ?= inet(IANAipRouteProtocol 1-17) */
+
+#ifdef USING_IP_FORWARD_MIB_IPCIDRROUTETABLE_IPCIDRROUTETABLE_MODULE
+   /** rt_info != inet_policy, because that would have made sense */
+   uint8_t   rt_info_len;    /* 0-128 oids */
+   oid      *rt_info;        /* NULL should be interpreted as { 0, 0 } */
+
+   uint32_t  rt_mask;        /* ipv4 only */
+   uint32_t  rt_tos;         /* Integer32 (0..2147483647) */
+#endif
+
+   uint32_t  rt_age;         /* seconds (ip == inet) */
+   int32_t   rt_nexthop_as;  /* ip(int32) == inet(InetAutonomousSystemNumber) */
+
+   int32_t   rt_metric1;
+   int32_t   rt_metric2;
+   int32_t   rt_metric3;
+   int32_t   rt_metric4;
+   int32_t   rt_metric5;
+
+} netsnmp_route_entry;
+
+
+
+/**---------------------------------------------------------------------*/
+/*
+ * ACCESS function prototypes
+ */
+/*
+ * ifcontainer init
+ */
+netsnmp_container * netsnmp_access_route_container_init(u_int init_flags);
+#define NETSNMP_ACCESS_ROUTE_INIT_NOFLAGS               0x0000
+#define NETSNMP_ACCESS_ROUTE_INIT_ADDL_IDX_BY_NAME      0x0001
+
+/*
+ * ifcontainer load and free
+ */
+netsnmp_container*
+netsnmp_access_route_container_load(netsnmp_container* container,
+                                    u_int load_flags);
+#define NETSNMP_ACCESS_ROUTE_LOAD_NOFLAGS               0x0000
+#define NETSNMP_ACCESS_ROUTE_LOAD_IPV4_ONLY             0x0001
+
+void netsnmp_access_route_container_free(netsnmp_container *container,
+                                         u_int free_flags);
+#define NETSNMP_ACCESS_ROUTE_FREE_NOFLAGS               0x0000
+#define NETSNMP_ACCESS_ROUTE_FREE_DONT_CLEAR            0x0001
+#define NETSNMP_ACCESS_ROUTE_FREE_KEEP_CONTAINER        0x0002
+
+
+/*
+ * create/copy/free a route entry
+ */
+netsnmp_route_entry *
+netsnmp_access_route_entry_create(void);
+
+void netsnmp_access_route_entry_free(netsnmp_route_entry * entry);
+
+int
+netsnmp_access_route_entry_copy(netsnmp_route_entry *lhs,
+                                netsnmp_route_entry *rhs);
+
+/*
+ * find entry in container
+ */
+/** not yet */
+
+/*
+ * create/change/delete
+ */
+int
+netsnmp_access_route_entry_set(netsnmp_route_entry * entry);
+
+/*
+ * route flags
+ *   upper bits for internal use
+ *   lower bits indicate changed fields. see FLAG_INETCIDRROUTE* definitions in
+ *         inetCidrRouteTable_constants.h
+ */
+#define NETSNMP_ACCESS_ROUTE_CREATE                         0x80000000
+#define NETSNMP_ACCESS_ROUTE_DELETE                         0x40000000
+#define NETSNMP_ACCESS_ROUTE_CHANGE                         0x20000000
+#define NETSNMP_ACCESS_ROUTE_POLICY_STATIC                  0x10000000
+#define NETSNMP_ACCESS_ROUTE_POLICY_DEEP_COPY               0x08000000
+
+/* 
+ * mask for change flag bits
+ */
+#define NETSNMP_ACCESS_ROUTE_RESERVED_BITS                  0x000001ff
+
+
+
+/**---------------------------------------------------------------------*/
+
+# ifdef __cplusplus
+}
+#endif
+
+#endif /* NETSNMP_ACCESS_ROUTE_H */
diff -rupN quagga-0.99.18//include/net-snmp/data_access/scopezone.h quaggasnmpTrap//include/net-snmp/data_access/scopezone.h
--- quagga-0.99.18//include/net-snmp/data_access/scopezone.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/data_access/scopezone.h	2008-02-14 21:00:55.000000000 -0800
@@ -0,0 +1,68 @@
+/*
+ * scopezone data access header
+ *
+ * $Id: scopezone.h 14170 2007-04-29 02:22:12Z varun_c $
+ */
+#ifndef NETSNMP_ACCESS_SCOPEZONE_H
+#define NETSNMP_ACCESS_SCOPEZONE_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+
+/**---------------------------------------------------------------------*/
+/*
+ * structure definitions
+ *
+ *
+ * NOTE: if you add fields, update code dealing with
+ *       them in ipv6scopezone_common.c
+ */
+typedef struct netsnmp_v6scopezone_entry_s {
+    netsnmp_index oid_index;
+    oid           ns_scopezone_index;
+    u_int   ns_flags; /* net-snmp flags */
+    oid     index;
+    int     scopezone_linklocal;    
+
+} netsnmp_v6scopezone_entry;
+
+/**---------------------------------------------------------------------*/
+/*
+ * ACCESS function prototypes
+ */
+
+/*
+ * scopezone container init
+ */
+netsnmp_container * netsnmp_access_scopezone_container_init(u_int init_flags);
+
+/*
+ * scopezone container load and free
+ */
+netsnmp_container*
+netsnmp_access_scopezone_container_load(netsnmp_container* container,
+                                        u_int load_flags);
+
+void netsnmp_access_scopezone_container_free(netsnmp_container *container,
+                                             u_int free_flags);
+#define NETSNMP_ACCESS_SCOPEZONE_FREE_NOFLAGS               0x0000
+#define NETSNMP_ACCESS_SCOPEZONE_FREE_DONT_CLEAR            0x0001
+#define NETSNMP_ACCESS_SCOPEZONE_FREE_KEEP_CONTAINER        0x0002
+
+
+/*
+ * create/free an scopezone entry
+ */
+netsnmp_v6scopezone_entry *
+netsnmp_access_scopezone_entry_create(void);
+
+void netsnmp_access_scopezone_entry_free(netsnmp_v6scopezone_entry * entry);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETSNMP_ACCESS_SCOPEZONE_H */
diff -rupN quagga-0.99.18//include/net-snmp/data_access/swinst.h quaggasnmpTrap//include/net-snmp/data_access/swinst.h
--- quagga-0.99.18//include/net-snmp/data_access/swinst.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/data_access/swinst.h	2007-09-14 06:09:42.000000000 -0700
@@ -0,0 +1,77 @@
+/* Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ */
+/*
+ * Portions of this file are copyrighted by:
+ * Copyright (C) 2007 Apple, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+#ifndef NETSNMP_SWINST_H
+#define NETSNMP_SWINST_H
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+    /*
+     * Data structure for a swinst entry 
+     */
+    typedef struct hrSWInstalledTable_entry {
+        netsnmp_index   oid_index;
+        
+        /*
+         * Index values; MIB type is int32, but we use oid so this
+         * structure can be used directly with a table_container.
+         */
+        oid             swIndex;
+        
+        /*
+         * Column values 
+         */
+        char            swName[64];
+        char            swDate[11];
+#ifdef NETSNMP_HAVE_SWID
+        oid            *swID;
+        u_char          swID_len;
+#endif
+        u_char          swType;
+        u_char          swName_len;
+        u_char          swDate_len;
+    } netsnmp_swinst_entry;
+    
+#define HRSWINSTALLEDTYPE_UNKNOWN  1
+#define HRSWINSTALLEDTYPE_OPERATINGSYSTEM  2
+#define HRSWINSTALLEDTYPE_DEVICEDRIVER  3
+#define HRSWINSTALLEDTYPE_APPLICATION  4
+
+
+#define NETSNMP_SWINST_NOFLAGS            0x00000000
+
+#define NETSNMP_SWINST_ALL_OR_NONE        0x00000001
+#define NETSNMP_SWINST_DONT_FREE_ITEMS    0x00000002
+
+    netsnmp_container *
+    netsnmp_swinst_container_load(netsnmp_container *container, int flags );
+
+    void netsnmp_swinst_container_free(netsnmp_container *container,
+                                       u_int flags);
+    void netsnmp_swinst_container_free_items(netsnmp_container *container);
+
+    void netsnmp_swinst_entry_remove(netsnmp_container * container,
+                                     netsnmp_swinst_entry *entry);
+
+    netsnmp_swinst_entry * netsnmp_swinst_entry_create(int32_t index);
+    void netsnmp_swinst_entry_free(netsnmp_swinst_entry *entry);
+
+    int32_t netsnmp_swinst_add_name(const char *name);
+    int32_t netsnmp_swinst_get_id(const char *name);
+    const char * netsnmp_swinst_get_name(int32_t id);
+
+#ifdef  __cplusplus
+}
+#endif
+
+
+#endif /* NETSNMP_SWINST_H */
diff -rupN quagga-0.99.18//include/net-snmp/data_access/swrun.h quaggasnmpTrap//include/net-snmp/data_access/swrun.h
--- quagga-0.99.18//include/net-snmp/data_access/swrun.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/data_access/swrun.h	2008-07-29 09:05:31.000000000 -0700
@@ -0,0 +1,104 @@
+/* Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ */
+/*
+ * Portions of this file are copyrighted by:
+ * Copyright (C) 2007 Apple, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+#ifndef NETSNMP_SWRUN_H
+#define NETSNMP_SWRUN_H
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+
+    /*-*****************************************************************
+     *
+     * Data structure for a row entry 
+     */
+    typedef struct hrSWRunTable_entry {
+        netsnmp_index   oid_index;
+        
+        /*
+         * Index values 
+         */
+        oid             hrSWRunIndex;
+        
+        /*
+         * Column values 
+         */
+        char            hrSWRunName[ 64+1];  /* size per MIB + 1 */
+        char            hrSWRunPath[128+1];  /* size per MIB + 1 */
+        char            hrSWRunParameters[128+1]; /* size per MIB + 1 */
+#ifdef NETSNMP_SWRUN_HAVE_ID  /* if not defined, will always use nullOid */
+        oid             hrSWRunID[SNMP_MAXOID];
+        u_char          hrSWRunID_len;
+#endif
+        u_char          hrSWRunName_len;
+        u_char          hrSWRunPath_len;
+        u_char          hrSWRunParameters_len;
+
+        u_char          hrSWRunType;
+        u_char          hrSWRunStatus;
+        u_char          old_hrSWRunStatus;
+
+        /*
+         * Perf values
+         */
+        int32_t         hrSWRunPerfCPU;
+        int32_t         hrSWRunPerfMem;
+        
+    } netsnmp_swrun_entry;
+
+    /*
+     * enums for column hrSWRunType
+     */
+#define HRSWRUNTYPE_UNKNOWN             1
+#define HRSWRUNTYPE_OPERATINGSYSTEM     2
+#define HRSWRUNTYPE_DEVICEDRIVER        3
+#define HRSWRUNTYPE_APPLICATION         4
+
+    /*
+     * enums for column hrSWRunStatus
+     */
+#define HRSWRUNSTATUS_RUNNING           1
+#define HRSWRUNSTATUS_RUNNABLE          2
+#define HRSWRUNSTATUS_NOTRUNNABLE       3
+#define HRSWRUNSTATUS_INVALID           4
+
+    /*-*****************************************************************
+     *
+     * Prototypes
+     */
+    netsnmp_container *
+    netsnmp_swrun_container_load(netsnmp_container *container, u_int flags );
+
+    void netsnmp_swrun_container_free(netsnmp_container *container, u_int flags);
+    void netsnmp_swrun_container_free_items(netsnmp_container * container);
+
+    netsnmp_swrun_entry *
+    netsnmp_swrun_entry_create(int32_t swIndex);
+
+    void netsnmp_swrun_entry_free(netsnmp_swrun_entry *entry);
+
+    int  swrun_count_processes( void );
+    int  swrun_max_processes(   void );
+    int  swrun_count_processes_by_name( char *name );
+
+#define NETSNMP_SWRUN_NOFLAGS            0x00000000
+#define NETSNMP_SWRUN_ALL_OR_NONE        0x00000001
+#define NETSNMP_SWRUN_DONT_FREE_ITEMS    0x00000002
+/*#define NETSNMP_SWRUN_xx                0x00000004 */
+
+#ifdef  __cplusplus
+}
+#endif
+
+
+#endif /* NETSNMP_SWRUN_H */
+
+
diff -rupN quagga-0.99.18//include/net-snmp/data_access/systemstats.h quaggasnmpTrap//include/net-snmp/data_access/systemstats.h
--- quagga-0.99.18//include/net-snmp/data_access/systemstats.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/data_access/systemstats.h	2010-04-08 03:55:42.000000000 -0700
@@ -0,0 +1,106 @@
+/*
+ * systemstats data access header
+ *
+ * $Id: systemstats.h 18483 2010-04-08 10:55:42Z jsafranek $
+ */
+#ifndef NETSNMP_ACCESS_SYSTEMSTATS_H
+#define NETSNMP_ACCESS_SYSTEMSTATS_H
+
+# ifdef __cplusplus
+extern          "C" {
+#endif
+
+/**---------------------------------------------------------------------*/
+/*
+ * structure definitions
+ */
+
+
+/*
+ * netsnmp_systemstats_entry
+ */
+typedef struct netsnmp_systemstats_s {
+
+   netsnmp_index oid_index;   /* MUST BE FIRST!! for container use */
+   /* 
+    * Index of the table
+    * First entry = ip version
+    * Second entry = interface index (0 for ipSystemStatsTable */
+   oid           index[2];           
+
+   int       flags; /* for net-snmp use */
+
+   /*
+    * mib related data (considered for
+    *  netsnmp_access_systemstats_entry_update)
+    */
+   netsnmp_ipstats stats;
+
+   /*
+    * for logging
+    */
+   const char* tableName;
+   
+   /** old_stats is used in netsnmp_access_interface_entry_update_stats */
+   netsnmp_ipstats *old_stats;
+
+} netsnmp_systemstats_entry;
+
+
+/**---------------------------------------------------------------------*/
+/*
+ * ACCESS function prototypes
+ */
+/*
+ * init
+ */
+void netsnmp_access_systemstats_init(void);
+
+/*
+ * init
+ */
+netsnmp_container * netsnmp_access_systemstats_container_init(u_int init_flags);
+#define NETSNMP_ACCESS_SYSTEMSTATS_INIT_NOFLAGS               0x0000
+#define NETSNMP_ACCESS_SYSTEMSTATS_INIT_ADDL_IDX_BY_ADDR      0x0001
+
+/**
+ * Load container. If the NETSNMP_ACCESS_SYSTEMSTATS_LOAD_IFTABLE is set
+ * the ipIfSystemStats table is loaded, else ipSystemStatsTable is loaded.
+ */
+netsnmp_container*
+netsnmp_access_systemstats_container_load(netsnmp_container* container,
+                                    u_int load_flags);
+#define NETSNMP_ACCESS_SYSTEMSTATS_LOAD_NOFLAGS               0x0000
+#define NETSNMP_ACCESS_SYSTEMSTATS_LOAD_IFTABLE               0x0001 
+
+void netsnmp_access_systemstats_container_free(netsnmp_container *container,
+                                         u_int free_flags);
+#define NETSNMP_ACCESS_SYSTEMSTATS_FREE_NOFLAGS               0x0000
+#define NETSNMP_ACCESS_SYSTEMSTATS_FREE_DONT_CLEAR            0x0001
+#define NETSNMP_ACCESS_SYSTEMSTATS_FREE_KEEP_CONTAINER        0x0002
+
+
+/*
+ * create/free an entry
+ */
+netsnmp_systemstats_entry *
+netsnmp_access_systemstats_entry_create(int version, int if_index,
+            const char* tableName);
+
+void netsnmp_access_systemstats_entry_free(netsnmp_systemstats_entry * entry);
+
+/*
+ * update/compare
+ */
+int
+netsnmp_access_systemstats_entry_update(netsnmp_systemstats_entry *old, 
+                                        netsnmp_systemstats_entry *new_val);
+
+
+/**---------------------------------------------------------------------*/
+
+# ifdef __cplusplus
+}
+#endif
+
+#endif /* NETSNMP_ACCESS_SYSTEMSTATS_H */
diff -rupN quagga-0.99.18//include/net-snmp/data_access/tcpConn.h quaggasnmpTrap//include/net-snmp/data_access/tcpConn.h
--- quagga-0.99.18//include/net-snmp/data_access/tcpConn.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/data_access/tcpConn.h	2006-09-01 10:50:29.000000000 -0700
@@ -0,0 +1,130 @@
+/*
+ * tcpConn data access header
+ *
+ * $Id: tcpConn.h 15136 2006-09-01 17:50:29Z rstory $
+ */
+#ifndef NETSNMP_ACCESS_TCPCONN_H
+#define NETSNMP_ACCESS_TCPCONN_H
+
+/** need def of NETSNMP_ACCESS_IPADDRESS_BUF_SIZE */
+#include <net-snmp/data_access/ipaddress.h>
+
+# ifdef __cplusplus
+extern          "C" {
+#endif
+
+/**---------------------------------------------------------------------*/
+/*
+ * structure definitions
+ */
+
+/*
+ * netsnmp_tcpconn_entry
+ *   - primary tcpconn structure for both ipv4 & ipv6
+ */
+    typedef struct netsnmp_tcpconn_s {
+
+        netsnmp_index oid_index;   /* MUST BE FIRST!! for container use */
+        oid           arbitrary_index; /* arbitrary index */
+
+        int       flags; /* for net-snmp use */
+
+        u_char    loc_addr[NETSNMP_ACCESS_IPADDRESS_BUF_SIZE];
+        u_char    rmt_addr[NETSNMP_ACCESS_IPADDRESS_BUF_SIZE];
+
+        u_char    loc_addr_len;/* address len, 4 | 16 */
+        u_char    rmt_addr_len;/* address len, 4 | 16 */
+
+        u_short   loc_port;
+        u_short   rmt_port;
+        
+        /*
+         * mib related data (considered for
+         *  netsnmp_access_tcpconn_entry_update)
+         */
+   
+        /*
+         * tcpconnState(1)/INTEGER/ASN_INTEGER/long(u_long)//l/A/W/E/r/d/h
+         */
+        u_int           tcpConnState; /* 1-12 */
+
+        u_int           pid;
+   
+        netsnmp_data_list *arch_data;      /* arch specific data */
+   
+    } netsnmp_tcpconn_entry;
+
+
+/**---------------------------------------------------------------------*/
+/*
+ * ACCESS function prototypes
+ */
+/*
+ * ifcontainer init
+ */
+    netsnmp_container * netsnmp_access_tcpconn_container_init(u_int init_flags);
+#define NETSNMP_ACCESS_TCPCONN_INIT_NOFLAGS               0x0000
+
+/*
+ * ifcontainer load and free
+ */
+    netsnmp_container*
+    netsnmp_access_tcpconn_container_load(netsnmp_container* container,
+                                          u_int load_flags);
+#define NETSNMP_ACCESS_TCPCONN_LOAD_NOFLAGS               0x0000
+#define NETSNMP_ACCESS_TCPCONN_LOAD_NOLISTEN              0x0001
+#define NETSNMP_ACCESS_TCPCONN_LOAD_ONLYLISTEN            0x0002
+#define NETSNMP_ACCESS_TCPCONN_LOAD_IPV4_ONLY             0x0004
+
+    void netsnmp_access_tcpconn_container_free(netsnmp_container *container,
+                                               u_int free_flags);
+#define NETSNMP_ACCESS_TCPCONN_FREE_NOFLAGS               0x0000
+#define NETSNMP_ACCESS_TCPCONN_FREE_DONT_CLEAR            0x0001
+#define NETSNMP_ACCESS_TCPCONN_FREE_KEEP_CONTAINER        0x0002
+
+
+/*
+ * create/free a tcpconn entry
+ */
+    netsnmp_tcpconn_entry *
+    netsnmp_access_tcpconn_entry_create(void);
+
+    void netsnmp_access_tcpconn_entry_free(netsnmp_tcpconn_entry * entry);
+
+/*
+ * update/compare
+ */
+    int
+    netsnmp_access_tcpconn_entry_update(netsnmp_tcpconn_entry *old, 
+                                        netsnmp_tcpconn_entry *new_val);
+
+/*
+ * find entry in container
+ */
+/** not yet */
+
+/*
+ * create/change/delete
+ */
+    int
+    netsnmp_access_tcpconn_entry_set(netsnmp_tcpconn_entry * entry);
+
+
+/*
+ * tcpconn flags
+ *   upper bits for internal use
+ *   lower bits indicate changed fields. see FLAG_TCPCONN* definitions in
+ *         tcpConnTable_constants.h
+ */
+#define NETSNMP_ACCESS_TCPCONN_CREATE     0x80000000
+#define NETSNMP_ACCESS_TCPCONN_DELETE     0x40000000
+#define NETSNMP_ACCESS_TCPCONN_CHANGE     0x20000000
+
+
+/**---------------------------------------------------------------------*/
+
+# ifdef __cplusplus
+}
+#endif
+
+#endif /* NETSNMP_ACCESS_TCPCONN_H */
diff -rupN quagga-0.99.18//include/net-snmp/data_access/udp_endpoint.h quaggasnmpTrap//include/net-snmp/data_access/udp_endpoint.h
--- quagga-0.99.18//include/net-snmp/data_access/udp_endpoint.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/data_access/udp_endpoint.h	2007-04-30 03:50:39.000000000 -0700
@@ -0,0 +1,100 @@
+/*
+ * udp_endpoint data access header
+ *
+ * $Id: udp_endpoint.h 16319 2007-04-30 10:50:39Z dts12 $
+ */
+#ifndef NETSNMP_ACCESS_UDP_ENDPOINT_H
+#define NETSNMP_ACCESS_UDP_ENDPOINT_H
+
+#ifndef NETSNMP_ACCESS_IPADDRESS_BUF_SIZE
+#   error "include <net-snmp/data_access/ipaddress.h> before this file"
+#endif
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/**---------------------------------------------------------------------*/
+/*
+ * structure definitions
+ */
+
+/*
+ * netsnmp_udp_endpoint_entry
+ *   - primary udp_endpoint structure for both ipv4 & ipv6
+ */
+    typedef struct netsnmp_udp_endpoint_s {
+
+        netsnmp_index oid_index;   /* MUST BE FIRST!! for container use */
+        oid           index; /* sl */
+
+        int       flags; /* for net-snmp use */
+
+        u_char    loc_addr[NETSNMP_ACCESS_IPADDRESS_BUF_SIZE];
+        u_char    rmt_addr[NETSNMP_ACCESS_IPADDRESS_BUF_SIZE];
+
+        u_char    loc_addr_len;/* address len, 4 | 16 */
+        u_char    rmt_addr_len;/* address len, 4 | 16 */
+        u_char    state; /* not in the mib, but what the heck */
+
+        u_short   loc_port;
+        u_short   rmt_port;
+
+        u_int     instance;
+        u_int     pid;
+   
+    } netsnmp_udp_endpoint_entry;
+
+
+/**---------------------------------------------------------------------*/
+/*
+ * ACCESS function prototypes
+ */
+/*
+ * ifcontainer init
+ */
+    netsnmp_container *
+    netsnmp_access_udp_endpoint_container_init(u_int init_flags);
+#define NETSNMP_ACCESS_UDP_ENDPOINT_INIT_NOFLAGS               0x0000
+
+/*
+ * ifcontainer load and free
+ */
+    netsnmp_container*
+    netsnmp_access_udp_endpoint_container_load(netsnmp_container* c,
+                                          u_int load_flags);
+#define NETSNMP_ACCESS_UDP_ENDPOINT_LOAD_NOFLAGS               0x0000
+
+    void netsnmp_access_udp_endpoint_container_free(netsnmp_container *c,
+                                               u_int free_flags);
+#define NETSNMP_ACCESS_UDP_ENDPOINT_FREE_NOFLAGS               0x0000
+#define NETSNMP_ACCESS_UDP_ENDPOINT_FREE_DONT_CLEAR            0x0001
+#define NETSNMP_ACCESS_UDP_ENDPOINT_FREE_KEEP_CONTAINER        0x0002
+
+
+/*
+ * create/free a udp_endpoint entry
+ */
+    netsnmp_udp_endpoint_entry *
+    netsnmp_access_udp_endpoint_entry_create(void);
+
+    void netsnmp_access_udp_endpoint_entry_free(netsnmp_udp_endpoint_entry *e);
+
+/*
+ * update/compare
+ */
+
+/*
+ * find entry in container
+ */
+/** not yet */
+
+
+
+/**---------------------------------------------------------------------*/
+
+# ifdef __cplusplus
+}
+#endif
+
+#endif /* NETSNMP_ACCESS_UDP_ENDPOINT_H */
diff -rupN quagga-0.99.18//include/net-snmp/definitions.h quaggasnmpTrap//include/net-snmp/definitions.h
--- quagga-0.99.18//include/net-snmp/definitions.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/definitions.h	2002-07-19 14:10:06.000000000 -0700
@@ -0,0 +1,32 @@
+#ifndef NET_SNMP_DEFINITIONS_H
+#define NET_SNMP_DEFINITIONS_H
+
+    /**
+     *  Defined constants, and other similar enumerations.
+     */
+
+#define MAX_OID_LEN	    128 /* max subid's in an oid */
+
+#define ONE_SEC         1000000L
+
+    /*
+     *  For the initial release, this will just refer to the
+     *  relevant UCD header files.
+     *    In due course, the relevant definitions will be
+     *  identified, and listed here directly.
+     *
+     *  But for the time being, this header file is primarily a placeholder,
+     *  to allow application writers to adopt the new header file names.
+     */
+
+#include <net-snmp/types.h>     /* for oid */
+#include <net-snmp/library/snmp_api.h>
+#include <net-snmp/library/asn1.h>
+#include <net-snmp/library/snmp_impl.h>
+#include <net-snmp/library/snmp.h>
+#include <net-snmp/library/snmp-tc.h>
+/*
+ * #include <net-snmp/library/libsnmp.h> 
+ */
+
+#endif                          /* NET_SNMP_DEFINITIONS_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/asn1.h quaggasnmpTrap//include/net-snmp/library/asn1.h
--- quagga-0.99.18//include/net-snmp/library/asn1.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/asn1.h	2010-02-27 05:11:15.000000000 -0800
@@ -0,0 +1,455 @@
+#ifndef ASN1_H
+#define ASN1_H
+
+#include <net-snmp/library/oid.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#define PARSE_PACKET	0
+#define DUMP_PACKET	1
+
+    /*
+     * Definitions for Abstract Syntax Notation One, ASN.1
+     * As defined in ISO/IS 8824 and ISO/IS 8825
+     *
+     *
+     */
+/***********************************************************
+	Copyright 1988, 1989 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of CMU not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+******************************************************************/
+
+
+#define MIN_OID_LEN	    2
+#define MAX_OID_LEN	    128 /* max subid's in an oid */
+#ifndef MAX_NAME_LEN            /* conflicts with some libraries */
+#define MAX_NAME_LEN	    MAX_OID_LEN /* obsolete. use MAX_OID_LEN */
+#endif
+
+#define OID_LENGTH(x)  (sizeof(x)/sizeof(oid))
+
+
+#define ASN_BOOLEAN	    ((u_char)0x01)
+#define ASN_INTEGER	    ((u_char)0x02)
+#define ASN_BIT_STR	    ((u_char)0x03)
+#define ASN_OCTET_STR	    ((u_char)0x04)
+#define ASN_NULL	    ((u_char)0x05)
+#define ASN_OBJECT_ID	    ((u_char)0x06)
+#define ASN_SEQUENCE	    ((u_char)0x10)
+#define ASN_SET		    ((u_char)0x11)
+
+#define ASN_UNIVERSAL	    ((u_char)0x00)
+#define ASN_APPLICATION     ((u_char)0x40)
+#define ASN_CONTEXT	    ((u_char)0x80)
+#define ASN_PRIVATE	    ((u_char)0xC0)
+
+#define ASN_PRIMITIVE	    ((u_char)0x00)
+#define ASN_CONSTRUCTOR	    ((u_char)0x20)
+
+#define ASN_LONG_LEN	    (0x80)
+#define ASN_EXTENSION_ID    (0x1F)
+#define ASN_BIT8	    (0x80)
+
+#define IS_CONSTRUCTOR(byte)	((byte) & ASN_CONSTRUCTOR)
+#define IS_EXTENSION_ID(byte)	(((byte) & ASN_EXTENSION_ID) == ASN_EXTENSION_ID)
+
+    struct counter64 {
+        u_long          high;
+        u_long          low;
+    };
+
+#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES
+    typedef struct counter64 integer64;
+    typedef struct counter64 unsigned64;
+
+    /*
+     * The BER inside an OPAQUE is an context specific with a value of 48 (0x30)
+     * plus the "normal" tag. For a Counter64, the tag is 0x46 (i.e., an
+     * applications specific tag with value 6). So the value for a 64 bit
+     * counter is 0x46 + 0x30, or 0x76 (118 base 10). However, values
+     * greater than 30 can not be encoded in one octet. So the first octet
+     * has the class, in this case context specific (ASN_CONTEXT), and
+     * the special value (i.e., 31) to indicate that the real value follows
+     * in one or more octets. The high order bit of each following octet
+     * indicates if the value is encoded in additional octets. A high order
+     * bit of zero, indicates the last. For this "hack", only one octet
+     * will be used for the value. 
+     */
+
+    /*
+     * first octet of the tag 
+     */
+#define ASN_OPAQUE_TAG1 (ASN_CONTEXT | ASN_EXTENSION_ID)
+    /*
+     * base value for the second octet of the tag - the
+     * second octet was the value for the tag 
+     */
+#define ASN_OPAQUE_TAG2 ((u_char)0x30)
+
+#define ASN_OPAQUE_TAG2U ((u_char)0x2f) /* second octet of tag for union */
+
+    /*
+     * All the ASN.1 types for SNMP "should have been" defined in this file,
+     * but they were not. (They are defined in snmp_impl.h)  Thus, the tag for
+     * Opaque and Counter64 is defined, again, here with a different names. 
+     */
+#define ASN_APP_OPAQUE (ASN_APPLICATION | 4)
+#define ASN_APP_COUNTER64 (ASN_APPLICATION | 6)
+#define ASN_APP_FLOAT (ASN_APPLICATION | 8)
+#define ASN_APP_DOUBLE (ASN_APPLICATION | 9)
+#define ASN_APP_I64 (ASN_APPLICATION | 10)
+#define ASN_APP_U64 (ASN_APPLICATION | 11)
+#define ASN_APP_UNION (ASN_PRIVATE | 1) /* or ASN_PRIV_UNION ? */
+
+    /*
+     * value for Counter64 
+     */
+#define ASN_OPAQUE_COUNTER64 (ASN_OPAQUE_TAG2 + ASN_APP_COUNTER64)
+    /*
+     * max size of BER encoding of Counter64 
+     */
+#define ASN_OPAQUE_COUNTER64_MX_BER_LEN 12
+
+    /*
+     * value for Float 
+     */
+#define ASN_OPAQUE_FLOAT (ASN_OPAQUE_TAG2 + ASN_APP_FLOAT)
+    /*
+     * size of BER encoding of Float 
+     */
+#define ASN_OPAQUE_FLOAT_BER_LEN 7
+
+    /*
+     * value for Double 
+     */
+#define ASN_OPAQUE_DOUBLE (ASN_OPAQUE_TAG2 + ASN_APP_DOUBLE)
+    /*
+     * size of BER encoding of Double 
+     */
+#define ASN_OPAQUE_DOUBLE_BER_LEN 11
+
+    /*
+     * value for Integer64 
+     */
+#define ASN_OPAQUE_I64 (ASN_OPAQUE_TAG2 + ASN_APP_I64)
+    /*
+     * max size of BER encoding of Integer64 
+     */
+#define ASN_OPAQUE_I64_MX_BER_LEN 11
+
+    /*
+     * value for Unsigned64 
+     */
+#define ASN_OPAQUE_U64 (ASN_OPAQUE_TAG2 + ASN_APP_U64)
+    /*
+     * max size of BER encoding of Unsigned64 
+     */
+#define ASN_OPAQUE_U64_MX_BER_LEN 12
+
+#endif                          /* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */
+
+
+#define ASN_PRIV_INCL_RANGE (ASN_PRIVATE | 2)
+#define ASN_PRIV_EXCL_RANGE (ASN_PRIVATE | 3)
+#define ASN_PRIV_DELEGATED  (ASN_PRIVATE | 5)
+#define ASN_PRIV_IMPLIED_OCTET_STR  (ASN_PRIVATE | ASN_OCTET_STR)       /* 4 */
+#define ASN_PRIV_IMPLIED_OBJECT_ID  (ASN_PRIVATE | ASN_OBJECT_ID)       /* 6 */
+#define ASN_PRIV_RETRY      (ASN_PRIVATE | 7)   /* 199 */
+#define IS_DELEGATED(x)   ((x) == ASN_PRIV_DELEGATED)
+
+
+    int             asn_check_packet(u_char *, size_t);
+    NETSNMP_IMPORT
+    u_char         *asn_parse_int(u_char *, size_t *, u_char *, long *,
+                                  size_t);
+    NETSNMP_IMPORT
+    u_char         *asn_build_int(u_char *, size_t *, u_char, const long *,
+                                  size_t);
+    NETSNMP_IMPORT
+    u_char         *asn_parse_unsigned_int(u_char *, size_t *, u_char *,
+                                           u_long *, size_t);
+    NETSNMP_IMPORT
+    u_char         *asn_build_unsigned_int(u_char *, size_t *, u_char,
+                                           const u_long *, size_t);
+    NETSNMP_IMPORT
+    u_char         *asn_parse_string(u_char *, size_t *, u_char *,
+                                     u_char *, size_t *);
+    NETSNMP_IMPORT
+    u_char         *asn_build_string(u_char *, size_t *, u_char,
+                                     const u_char *, size_t);
+    NETSNMP_IMPORT
+    u_char         *asn_parse_header(u_char *, size_t *, u_char *);
+    u_char         *asn_parse_sequence(u_char *, size_t *, u_char *, u_char expected_type,      /* must be this type */
+                                       const char *estr);       /* error message prefix */
+    NETSNMP_IMPORT
+    u_char         *asn_build_header(u_char *, size_t *, u_char, size_t);
+    NETSNMP_IMPORT
+    u_char         *asn_build_sequence(u_char *, size_t *, u_char, size_t);
+    NETSNMP_IMPORT
+    u_char         *asn_parse_length(u_char *, u_long *);
+    NETSNMP_IMPORT
+    u_char         *asn_build_length(u_char *, size_t *, size_t);
+    NETSNMP_IMPORT
+    u_char         *asn_parse_objid(u_char *, size_t *, u_char *, oid *,
+                                    size_t *);
+    NETSNMP_IMPORT
+    u_char         *asn_build_objid(u_char *, size_t *, u_char, oid *,
+                                    size_t);
+    NETSNMP_IMPORT
+    u_char         *asn_parse_null(u_char *, size_t *, u_char *);
+    NETSNMP_IMPORT
+    u_char         *asn_build_null(u_char *, size_t *, u_char);
+    NETSNMP_IMPORT
+    u_char         *asn_parse_bitstring(u_char *, size_t *, u_char *,
+                                        u_char *, size_t *);
+    NETSNMP_IMPORT
+    u_char         *asn_build_bitstring(u_char *, size_t *, u_char,
+                                        const u_char *, size_t);
+    NETSNMP_IMPORT
+    u_char         *asn_parse_unsigned_int64(u_char *, size_t *, u_char *,
+                                             struct counter64 *, size_t);
+    NETSNMP_IMPORT
+    u_char         *asn_build_unsigned_int64(u_char *, size_t *, u_char,
+                                             const struct counter64 *, size_t);
+    u_char         *asn_parse_signed_int64(u_char *, size_t *, u_char *,
+                                           struct counter64 *, size_t);
+    u_char         *asn_build_signed_int64(u_char *, size_t *, u_char,
+                                           const struct counter64 *, size_t);
+    u_char         *asn_build_float(u_char *, size_t *, u_char, const float *,
+                                    size_t);
+    u_char         *asn_parse_float(u_char *, size_t *, u_char *, float *,
+                                    size_t);
+    u_char         *asn_build_double(u_char *, size_t *, u_char, const double *,
+                                     size_t);
+    u_char         *asn_parse_double(u_char *, size_t *, u_char *,
+                                     double *, size_t);
+
+#ifdef NETSNMP_USE_REVERSE_ASNENCODING
+
+    /*
+     * Re-allocator function for below.  
+     */
+
+    int             asn_realloc(u_char **, size_t *);
+
+    /*
+     * Re-allocating reverse ASN.1 encoder functions.  Synopsis:
+     * 
+     * u_char *buf = (u_char*)malloc(100);
+     * u_char type = (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER);
+     * size_t buf_len = 100, offset = 0;
+     * long data = 12345;
+     * int allow_realloc = 1;
+     * 
+     * if (asn_realloc_rbuild_int(&buf, &buf_len, &offset, allow_realloc,
+     * type, &data, sizeof(long)) == 0) {
+     * error;
+     * }
+     * 
+     * NOTE WELL: after calling one of these functions with allow_realloc
+     * non-zero, buf might have moved, buf_len might have grown and
+     * offset will have increased by the size of the encoded data.
+     * You should **NEVER** do something like this:
+     * 
+     * u_char *buf = (u_char *)malloc(100), *ptr;
+     * u_char type = (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER);
+     * size_t buf_len = 100, offset = 0;
+     * long data1 = 1234, data2 = 5678;
+     * int rc = 0, allow_realloc = 1;
+     * 
+     * rc  = asn_realloc_rbuild_int(&buf, &buf_len, &offset, allow_realloc,
+     * type, &data1, sizeof(long));
+     * ptr = buf[buf_len - offset];   / * points at encoding of data1 * /
+     * if (rc == 0) {
+     * error;
+     * }
+     * rc  = asn_realloc_rbuild_int(&buf, &buf_len, &offset, allow_realloc,
+     * type, &data2, sizeof(long));
+     * make use of ptr here;
+     * 
+     * 
+     * ptr is **INVALID** at this point.  In general, you should store the
+     * offset value and compute pointers when you need them:
+     * 
+     * 
+     * 
+     * u_char *buf = (u_char *)malloc(100), *ptr;
+     * u_char type = (ASN_UNIVERSAL | ASN_PRIMITIVE | ASN_INTEGER);
+     * size_t buf_len = 100, offset = 0, ptr_offset;
+     * long data1 = 1234, data2 = 5678;
+     * int rc = 0, allow_realloc = 1;
+     * 
+     * rc  = asn_realloc_rbuild_int(&buf, &buf_len, &offset, allow_realloc,
+     * type, &data1, sizeof(long));
+     * ptr_offset = offset;
+     * if (rc == 0) {
+     * error;
+     * }
+     * rc  = asn_realloc_rbuild_int(&buf, &buf_len, &offset, allow_realloc,
+     * type, &data2, sizeof(long));
+     * ptr = buf + buf_len - ptr_offset
+     * make use of ptr here;
+     * 
+     * 
+     * 
+     * Here, you can see that ptr will be a valid pointer even if the block of
+     * memory has been moved, as it may well have been.  Plenty of examples of
+     * usage all over asn1.c, snmp_api.c, snmpusm.c.
+     * 
+     * The other thing you should **NEVER** do is to pass a pointer to a buffer
+     * on the stack as the first argument when allow_realloc is non-zero, unless
+     * you really know what you are doing and your machine/compiler allows you to
+     * free non-heap memory.  There are rumours that such things exist, but many
+     * consider them no more than the wild tales of a fool.
+     * 
+     * Of course, you can pass allow_realloc as zero, to indicate that you do not
+     * wish the packet buffer to be reallocated for some reason; perhaps because
+     * it is on the stack.  This may be useful to emulate the functionality of
+     * the old API:
+     * 
+     * u_char my_static_buffer[100], *cp = NULL;
+     * size_t my_static_buffer_len = 100;
+     * float my_pi = (float)22/(float)7;
+     * 
+     * cp = asn_rbuild_float(my_static_buffer, &my_static_buffer_len,
+     * ASN_OPAQUE_FLOAT, &my_pi, sizeof(float));
+     * if (cp == NULL) {
+     * error;
+     * }
+     * 
+     * 
+     * IS EQUIVALENT TO:
+     * 
+     * 
+     * u_char my_static_buffer[100];
+     * size_t my_static_buffer_len = 100, my_offset = 0;
+     * float my_pi = (float)22/(float)7;
+     * int rc = 0;
+     * 
+     * rc = asn_realloc_rbuild_float(&my_static_buffer, &my_static_buffer_len,
+     * &my_offset, 0,
+     * ASN_OPAQUE_FLOAT, &my_pi, sizeof(float));
+     * if (rc == 0) {
+     * error;
+     * }
+     * 
+     * 
+     */
+
+
+    int             asn_realloc_rbuild_int(u_char ** pkt, size_t * pkt_len,
+                                           size_t * offset,
+                                           int allow_realloc, u_char type,
+                                           const long *data, size_t data_size);
+
+    int             asn_realloc_rbuild_string(u_char ** pkt,
+                                              size_t * pkt_len,
+                                              size_t * offset,
+                                              int allow_realloc,
+                                              u_char type,
+                                              const u_char * data,
+                                              size_t data_size);
+
+    int             asn_realloc_rbuild_unsigned_int(u_char ** pkt,
+                                                    size_t * pkt_len,
+                                                    size_t * offset,
+                                                    int allow_realloc,
+                                                    u_char type,
+                                                    const u_long * data,
+                                                    size_t data_size);
+
+    int             asn_realloc_rbuild_header(u_char ** pkt,
+                                              size_t * pkt_len,
+                                              size_t * offset,
+                                              int allow_realloc,
+                                              u_char type,
+                                              size_t data_size);
+
+    int             asn_realloc_rbuild_sequence(u_char ** pkt,
+                                                size_t * pkt_len,
+                                                size_t * offset,
+                                                int allow_realloc,
+                                                u_char type,
+                                                size_t data_size);
+
+    int             asn_realloc_rbuild_length(u_char ** pkt,
+                                              size_t * pkt_len,
+                                              size_t * offset,
+                                              int allow_realloc,
+                                              size_t data_size);
+
+    int             asn_realloc_rbuild_objid(u_char ** pkt,
+                                             size_t * pkt_len,
+                                             size_t * offset,
+                                             int allow_realloc,
+                                             u_char type, const oid *,
+                                             size_t);
+
+    int             asn_realloc_rbuild_null(u_char ** pkt,
+                                            size_t * pkt_len,
+                                            size_t * offset,
+                                            int allow_realloc,
+                                            u_char type);
+
+    int             asn_realloc_rbuild_bitstring(u_char ** pkt,
+                                                 size_t * pkt_len,
+                                                 size_t * offset,
+                                                 int allow_realloc,
+                                                 u_char type,
+                                                 const u_char * data,
+                                                 size_t data_size);
+
+    int             asn_realloc_rbuild_unsigned_int64(u_char ** pkt,
+                                                      size_t * pkt_len,
+                                                      size_t * offset,
+                                                      int allow_realloc,
+                                                      u_char type,
+                                                      struct counter64
+                                                      const *data, size_t);
+
+    int             asn_realloc_rbuild_signed_int64(u_char ** pkt,
+                                                    size_t * pkt_len,
+                                                    size_t * offset,
+                                                    int allow_realloc,
+                                                    u_char type,
+                                                    const struct counter64 *data,
+                                                    size_t);
+
+    int             asn_realloc_rbuild_float(u_char ** pkt,
+                                             size_t * pkt_len,
+                                             size_t * offset,
+                                             int allow_realloc,
+                                             u_char type, const float *data,
+                                             size_t data_size);
+
+    int             asn_realloc_rbuild_double(u_char ** pkt,
+                                              size_t * pkt_len,
+                                              size_t * offset,
+                                              int allow_realloc,
+                                              u_char type, const double *data,
+                                              size_t data_size);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* ASN1_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/callback.h quaggasnmpTrap//include/net-snmp/library/callback.h
--- quagga-0.99.18//include/net-snmp/library/callback.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/callback.h	2010-02-27 05:11:15.000000000 -0800
@@ -0,0 +1,84 @@
+/*
+ * callback.c: A generic callback mechanism 
+ */
+
+#ifndef CALLBACK_H
+#define CALLBACK_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#define MAX_CALLBACK_IDS    2
+#define MAX_CALLBACK_SUBIDS 16
+
+    /*
+     * Callback Major Types 
+     */
+#define SNMP_CALLBACK_LIBRARY     0
+#define SNMP_CALLBACK_APPLICATION 1
+
+    /*
+     * SNMP_CALLBACK_LIBRARY minor types 
+     */
+#define SNMP_CALLBACK_POST_READ_CONFIG	        0
+#define SNMP_CALLBACK_STORE_DATA	        1
+#define SNMP_CALLBACK_SHUTDOWN		        2
+#define SNMP_CALLBACK_POST_PREMIB_READ_CONFIG	3
+#define SNMP_CALLBACK_LOGGING			4
+#define SNMP_CALLBACK_SESSION_INIT		5
+#define SNMP_CALLBACK_PRE_READ_CONFIG	        7
+#define SNMP_CALLBACK_PRE_PREMIB_READ_CONFIG	8
+
+
+    /*
+     * Callback priority (lower priority numbers called first(
+     */
+#define NETSNMP_CALLBACK_HIGHEST_PRIORITY      -1024 
+#define NETSNMP_CALLBACK_DEFAULT_PRIORITY       0
+#define NETSNMP_CALLBACK_LOWEST_PRIORITY        1024
+
+    typedef int     (SNMPCallback) (int majorID, int minorID,
+                                    void *serverarg, void *clientarg);
+
+    struct snmp_gen_callback {
+        SNMPCallback   *sc_callback;
+        void           *sc_client_arg;
+        int             priority;
+        struct snmp_gen_callback *next;
+    };
+
+    /*
+     * function prototypes 
+     */
+    NETSNMP_IMPORT
+    void            init_callbacks(void);
+
+    int             netsnmp_register_callback(int major, int minor,
+                                              SNMPCallback * new_callback,
+                                              void *arg, int priority);
+    NETSNMP_IMPORT
+    int             snmp_register_callback(int major, int minor,
+                                           SNMPCallback * new_callback,
+                                           void *arg);
+    NETSNMP_IMPORT
+    int             snmp_call_callbacks(int major, int minor,
+                                        void *caller_arg);
+    NETSNMP_IMPORT
+    int             snmp_callback_available(int major, int minor);      /* is >1 available */
+    NETSNMP_IMPORT
+    int             snmp_count_callbacks(int major, int minor); /* ret the number registered */
+    NETSNMP_IMPORT
+    int             snmp_unregister_callback(int major, int minor,
+                                             SNMPCallback * new_callback,
+                                             void *arg, int matchargs);
+    NETSNMP_IMPORT
+    void            clear_callback (void);
+    int             netsnmp_callback_clear_client_arg(void *, int i, int j);
+
+    struct snmp_gen_callback *snmp_callback_list(int major, int minor);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* CALLBACK_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/cert_util.h quaggasnmpTrap//include/net-snmp/library/cert_util.h
--- quagga-0.99.18//include/net-snmp/library/cert_util.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/cert_util.h	2010-11-29 20:30:35.000000000 -0800
@@ -0,0 +1,226 @@
+#ifndef NETSNMP_CERT_UTIL_H
+
+#if defined(NETSNMP_USE_OPENSSL) && defined(HAVE_LIBSSL)
+
+#ifndef HEADER_SSL_H
+#error "must include <openssl/ssl.h> before cert_util.h"
+#endif
+#ifndef HEADER_X509_H
+#error "must include <openssl/x509.h> before cert_util.h"
+#endif
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+    /*************************************************************************
+     *
+     * netsnmp_cert structures, defines and function definitions
+     *
+     *************************************************************************/
+
+void netsnmp_certs_init(void);
+void netsnmp_certs_agent_init(void);
+void netsnmp_certs_shutdown(void);
+void netsnmp_certs_load(void);
+netsnmp_container *netsnmp_cert_get_trustlist(void);
+
+    typedef struct netsnmp_cert_common_s {
+        char           *dir;
+        char           *filename;
+        
+        u_char          type;
+        u_char          allowed_uses;
+        u_char          _pad[2]; /* for future use */
+    } netsnmp_cert_common;
+
+    typedef struct netsnmp_key_s {
+        netsnmp_cert_common info;
+
+        EVP_PKEY       *okey;
+        struct netsnmp_cert_s   *cert;
+    } netsnmp_key;
+
+    typedef struct netsnmp_cert_s {
+        netsnmp_cert_common info;
+
+        X509           *ocert;
+        netsnmp_key    *key;
+        struct netsnmp_cert_s *issuer_cert;
+
+        char           *issuer;
+        char           *subject;
+        char           *fingerprint;
+        char           *common_name;
+
+        u_char          hash_type;
+        u_char          _pad[3]; /* for future use */
+    } netsnmp_cert;
+
+/** types */
+    enum { NS_CERT_TYPE_UNKNOWN = 0, NS_CERT_TYPE_PEM, NS_CERT_TYPE_DER,
+           NS_CERT_TYPE_PKCS12, NS_CERT_TYPE_KEY };
+
+/** uses */
+#define NS_CERT_IDENTITY       0x0001
+#define NS_CERT_REMOTE_PEER    0x0002
+#define NS_CERT_RESERVED1      0x0004
+#define NS_CERT_CA             0x0008
+
+/** source */
+#define NS_CERTKEY_DEFAULT       0x000 /* get default from DS store */
+#define NS_CERTKEY_FILE          0x001 /* filename/full path */
+#define NS_CERTKEY_FINGERPRINT   0x002 /* public key fingerprint */
+#define NS_CERTKEY_CA            0x004 /* trusted CA */
+#define NS_CERTKEY_SAN_RFC822    0x008 /* subj alt name: rfc822 */
+#define NS_CERTKEY_SAN_DNS       0x010 /* subj alt name: DNS */
+#define NS_CERTKEY_SAN_IPADDR    0x020 /* subj alt name: IP address */
+#define NS_CERTKEY_COMMON_NAME   0x040 /* common name */
+#define NS_CERTKEY_TARGET_PARAM  0x080 /* tlstmParamsTable */
+#define NS_CERTKEY_TARGET_ADDR   0x100 /* tlstmAddrTable */
+#define NS_CERTKEY_MULTIPLE      0x200 /* try multiple sources */
+
+/** RFC 5246 hash algorithms (Section 7.4.1.4.1) */
+#define NS_HASH_NONE        0
+#define NS_HASH_MD5         1
+#define NS_HASH_SHA1        2
+#define NS_HASH_SHA224      3
+#define NS_HASH_SHA256      4
+#define NS_HASH_SHA384      5
+#define NS_HASH_SHA512      6
+#define NS_HASH_MAX         NS_HASH_SHA512
+
+/** SNMP-TLS-TM-MIB */
+#define SNMPTLSFINGERPRINT_MAX_LEN   255
+
+    /*************************************************************************
+     * netsnmp_cert function definitions
+     *************************************************************************/
+
+    netsnmp_cert *netsnmp_cert_find(int what, int where, void *hint);
+
+    int netsnmp_cert_check_vb_fingerprint(const netsnmp_variable_list *var);
+
+    void netsnmp_fp_lowercase_and_strip_colon(char *fp);
+    int netsnmp_cert_parse_hash_type(const char *str);
+    int netsnmp_tls_fingerprint_build(int hash_type, const char *hex_fp,
+                                      u_char **tls_fp, size_t *tls_fp_len,
+                                      int allow_realloc);
+    int netsnmp_tls_fingerprint_parse(const u_char *binary_fp, int fp_len,
+                                      char **fp_str_ptr, u_int *fp_str_len,
+                                      int allow_realloc, u_char *hash_type_ptr);
+
+
+    int netsnmp_cert_trust(SSL_CTX *ctx, netsnmp_cert *thiscert);
+    int netsnmp_cert_trust_ca(SSL_CTX *ctx, netsnmp_cert *thiscertsrootca);
+
+    /*************************************************************************
+     *
+     *  certificate to Transport Security Name mapping (netsnmp_cert_map)
+     *
+     *************************************************************************/
+
+#define TSNM_tlstmCertSpecified                 1
+#define TSNM_tlstmCertSANRFC822Name             2
+#define TSNM_tlstmCertSANDNSName                3
+#define TSNM_tlstmCertSANIpAddress              4
+#define TSNM_tlstmCertSANAny                    5
+#define TSNM_tlstmCertCommonName                6
+#define TSNM_tlstmCert_MAX                      TSNM_tlstmCertCommonName
+
+#define NSCM_FROM_CONFIG                        0x0001
+#define NSCM_FROM_MIB                           0x0002
+#define NSCM_NONVOLATILE                        0x0004
+
+    typedef struct netsnmp_cert_map_s {
+        int             priority;
+        char           *fingerprint;
+        int             mapType;
+        char           *data;
+
+        char            hashType;
+        char            flags;
+
+        X509           *ocert;
+    } netsnmp_cert_map;
+
+    netsnmp_cert_map *netsnmp_cert_map_alloc(char *fp, X509 *ocert);
+    void netsnmp_cert_map_free(netsnmp_cert_map *cert_map);
+    int netsnmp_cert_map_add(netsnmp_cert_map *map);
+    int netsnmp_cert_map_remove(netsnmp_cert_map *map);
+    netsnmp_cert_map *netsnmp_cert_map_find(netsnmp_cert_map *map);
+
+    void netsnmp_cert_map_container_free(netsnmp_container *c);
+    netsnmp_container *netsnmp_cert_map_container_create(int with_fp);
+    netsnmp_container *netsnmp_cert_map_container(void);
+
+    int netsnmp_cert_get_secname_maps(netsnmp_container *cm);
+
+    /*************************************************************************
+     *
+     *  snmpTlstmParamsTable data
+     *
+     *************************************************************************/
+    typedef struct snmpTlstmParams_s {
+        char         *name;
+        char         *fingerprint;
+        char          hashType;
+        u_char        flags;
+        u_char        fingerprint_len;
+    } snmpTlstmParams;
+    
+#define TLSTM_PARAMS_FROM_CONFIG          0x01
+#define TLSTM_PARAMS_FROM_MIB             0x02
+#define TLSTM_PARAMS_NONVOLATILE          0x04
+/** ine TLSTM_PARAMS_XXX                  0x08 */
+
+    snmpTlstmParams *netsnmp_tlstmParams_create(const char *tag, int hashType,
+                                                const char *fp, int fp_len);
+    void netsnmp_tlstmParams_free(snmpTlstmParams *stp);
+    snmpTlstmParams *netsnmp_tlstmParams_restore_common(char **line);
+
+    netsnmp_container *netsnmp_tlstmParams_container(void);
+    int netsnmp_tlstmParams_add(snmpTlstmParams *stp);
+    int netsnmp_tlstmParams_remove(snmpTlstmParams *stp);
+    snmpTlstmParams *netsnmp_tlstmParams_find(snmpTlstmParams *stp);
+
+    /*************************************************************************
+     *
+     *  snmpTlstmAddrTable data
+     *
+     *************************************************************************/
+    typedef struct snmpTlstmAddr_s {
+        char         *name;
+        char         *fingerprint;
+        char         *identity;
+        
+        u_char        hashType;
+        u_char        flags;
+        
+    } snmpTlstmAddr;
+
+#define TLSTM_ADDR_FROM_CONFIG          0x01
+#define TLSTM_ADDR_FROM_MIB             0x02
+#define TLSTM_ADDR_NONVOLATILE          0x04
+/** ine TLSTM_ADDR_XXX                  0x08 */
+
+    int netsnmp_tlstmAddr_restore_common(char **line, char *name,
+                                         size_t *name_len, char *id,
+                                         size_t *id_len, char *fp,
+                                         size_t *fp_len, u_char *ht);
+    netsnmp_container *netsnmp_tlstmAddr_container(void);
+    snmpTlstmAddr *netsnmp_tlstmAddr_find(snmpTlstmAddr *entry);
+    snmpTlstmAddr *netsnmp_tlstmAddr_create(char *targetAddrName);
+    void netsnmp_tlstmAddr_free(snmpTlstmAddr *entry);
+    int netsnmp_tlstmAddr_add(snmpTlstmAddr *entry);
+    int netsnmp_tlstmAddr_remove(snmpTlstmAddr *entry);
+    char *netsnmp_tlstmAddr_get_serverId(const char *name);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* defined(NETSNMP_USE_OPENSSL) && defined(HAVE_LIBSSL) */
+
+#endif /* NETSNMP_CERT_UTIL_H */
+
diff -rupN quagga-0.99.18//include/net-snmp/library/check_varbind.h quaggasnmpTrap//include/net-snmp/library/check_varbind.h
--- quagga-0.99.18//include/net-snmp/library/check_varbind.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/check_varbind.h	2010-05-27 11:59:33.000000000 -0700
@@ -0,0 +1,53 @@
+#ifndef SNMP_CHECK_VARBIND_H
+#define SNMP_CHECK_VARBIND_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    /*
+     * Assorted convience routines to check the contents of a
+     * netsnmp_variable_list instance.
+     */
+
+    int netsnmp_check_vb_type(const netsnmp_variable_list *var, int type);
+    int netsnmp_check_vb_size(const netsnmp_variable_list *var, size_t size );
+    int netsnmp_check_vb_max_size(const netsnmp_variable_list *var, size_t size );
+    int netsnmp_check_vb_range(const netsnmp_variable_list *var,
+                               size_t low, size_t high );
+    int netsnmp_check_vb_size_range(const netsnmp_variable_list *var,
+                                    size_t low, size_t high );
+
+    NETSNMP_IMPORT
+    int netsnmp_check_vb_type_and_size(const netsnmp_variable_list *var,
+                                    int type, size_t size);
+    NETSNMP_IMPORT
+    int netsnmp_check_vb_type_and_max_size(const netsnmp_variable_list *var,
+                                    int type, size_t size);
+
+    NETSNMP_IMPORT
+    int netsnmp_check_vb_oid(const netsnmp_variable_list *var);
+    NETSNMP_IMPORT
+    int netsnmp_check_vb_int(const netsnmp_variable_list *var);
+    NETSNMP_IMPORT
+    int netsnmp_check_vb_uint(const netsnmp_variable_list *var);
+    NETSNMP_IMPORT
+    int netsnmp_check_vb_int_range(const netsnmp_variable_list *var, int low,
+                                   int high);
+
+    NETSNMP_IMPORT
+    int netsnmp_check_vb_truthvalue(const netsnmp_variable_list *var);
+
+    NETSNMP_IMPORT
+    int netsnmp_check_vb_rowstatus_value(const netsnmp_variable_list *var);
+    NETSNMP_IMPORT
+    int netsnmp_check_vb_rowstatus(const netsnmp_variable_list *var, int old_val);
+    int netsnmp_check_vb_rowstatus_with_storagetype(const netsnmp_variable_list *var, int old_val, int old_storage);
+
+    int netsnmp_check_vb_storagetype(const netsnmp_variable_list *var, int old_val);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* SNMP_CHECK_VARBIND_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/cmu_compat.h quaggasnmpTrap//include/net-snmp/library/cmu_compat.h
--- quagga-0.99.18//include/net-snmp/library/cmu_compat.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/cmu_compat.h	2005-03-29 12:05:47.000000000 -0800
@@ -0,0 +1,292 @@
+/* Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ */
+/*
+ * Portions of this file are copyrighted by:
+ * Copyright Â© 2003 Sun Microsystems, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
+/*
+ *  CMU compatability definitions and structures.
+ *
+ *    (since the UCD package split from the CMU one
+ *     about 8 years ago, that's probably enough time
+ *     for people to convert any outstanding code!)
+ */
+
+#ifndef NET_SNMP_CMU_COMPAT_H
+#define NET_SNMP_CMU_COMPAT_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    /*
+     * ============================
+     * *
+     * * Enumerations and definitions
+     * *
+     * * ============================ 
+     */
+#include <net-snmp/definitions.h>
+    /*
+     * From parse.h 
+     */
+#define ACCESS_READONLY		MIB_ACCESS_READONLY
+#define ACCESS_READWRITE	MIB_ACCESS_READWRITE
+#define ACCESS_WRITEONLY	MIB_ACCESS_WRITEONLY
+#define ACCESS_NOACCESS		MIB_ACCESS_NOACCESS
+#define ACCESS_NOTIFY		MIB_ACCESS_NOTIFY
+#define ACCESS_CREATE		MIB_ACCESS_CREATE
+#define STATUS_MANDATORY	MIB_STATUS_MANDATORY
+#define STATUS_OPTIONAL		MIB_STATUS_OPTIONAL
+#define STATUS_OBSOLETE		MIB_STATUS_OBSOLETE
+#define STATUS_DEPRECATED	MIB_STATUS_DEPRECATED
+#define STATUS_CURRENT		MIB_STATUS_CURRENT
+    /*
+     * From smnp_impl.h 
+     */
+#define INTEGER	    ASN_INTEGER
+#define STRING	    ASN_OCTET_STR
+#define OBJID	    ASN_OBJECT_ID
+#define NULLOBJ	    ASN_NULL
+#define BITSTRING   ASN_BIT_STR /* HISTORIC - don't use */
+#define IPADDRESS   ASN_IPADDRESS
+#define COUNTER	    ASN_COUNTER
+#define GAUGE	    ASN_GAUGE
+#define UNSIGNED    ASN_UNSIGNED
+#define TIMETICKS   ASN_TIMETICKS
+#define ASNT_OPAQUE ASN_OPAQUE
+#define NSAP	    ASN_NSAP
+#define COUNTER64   ASN_COUNTER64
+#define UINTEGER    ASN_UINTEGER
+    /*
+     * From snmp.h 
+     */
+#define GET_REQ_MSG	    SNMP_MSG_GET
+#define GETNEXT_REQ_MSG	    SNMP_MSG_GETNEXT
+#define GET_RSP_MSG	    SNMP_MSG_RESPONSE
+#define SET_REQ_MSG	    SNMP_MSG_SET
+#define TRP_REQ_MSG	    SNMP_MSG_TRAP
+#define BULK_REQ_MSG	    SNMP_MSG_GETBULK
+#define INFORM_REQ_MSG	    SNMP_MSG_INFORM
+#define TRP2_REQ_MSG	    SNMP_MSG_TRAP2
+#define REPORT_RSP_MSG	    SNMP_MSG_REPORT
+    /*
+     * since CMU V1.5 
+     */
+#define SNMP_PDU_GET	    SNMP_MSG_GET
+#define SNMP_PDU_GETNEXT    SNMP_MSG_GETNEXT
+#define SNMP_PDU_RESPONSE   SNMP_MSG_RESPONSE
+#define SNMP_PDU_SET        SNMP_MSG_SET
+#define SNMP_PDU_GETBULK    SNMP_MSG_GETBULK
+#define SNMP_PDU_INFORM     SNMP_MSG_INFORM
+#define SNMP_PDU_V2TRAP     SNMP_MSG_TRAP2
+#define SNMP_PDU_REPORT     SNMP_MSG_REPORT
+#define SNMP_TRAP_AUTHENTICATIONFAILURE SNMP_TRAP_AUTHFAIL
+#define SMI_INTEGER     ASN_INTEGER
+#define SMI_STRING      ASN_OCTET_STR
+#define SMI_OBJID       ASN_OBJECT_ID
+#define SMI_NULLOBJ     ASN_NULL
+#define SMI_IPADDRESS   ASN_IPADDRESS
+#define SMI_COUNTER32	ASN_COUNTER
+#define SMI_GAUGE32	ASN_GAUGE
+#define SMI_UNSIGNED32  SMI_GAUGE32
+#define SMI_TIMETICKS   ASN_TIMETICKS
+#define SMI_OPAQUE      ASN_OPAQUE
+#define SMI_COUNTER64   ASN_COUNTER64
+    /*
+     * ============================
+     * *
+     * *     Function declarations
+     * *     and global variables
+     * *
+     * * ============================ 
+     */
+extern int      snmp_dump_packet;       /* from snmp_api.h */
+extern int      quick_print;    /* from snmp_api.h */
+
+#include <net-snmp/types.h>     /* for snmp_pdu & snmp_session */
+
+int             mib_TxtToOid(char *, oid **, size_t *); /* from snmp.h */
+int             mib_OidToTxt(oid *, size_t, char *, size_t);    /* from snmp.h */
+u_char         *cmu_snmp_parse(netsnmp_session * session, netsnmp_pdu *pdu, u_char * data, size_t length);      /* from snmp.h */
+
+
+
+
+        /*
+         * ============================
+         * *
+         * * MIB-II data structures
+         * *    (from mib.h) 
+         * *
+         * * ============================ 
+         */
+
+
+struct mib_system {
+    char            sysDescr[32];       /* textual description */
+    u_char          sysObjectID[16];    /* OBJECT IDENTIFIER of system */
+    u_char          ObjIDLen;   /* length of sysObjectID */
+    u_int           sysUpTime;  /* Uptime in 100/s of a second */
+};
+
+struct mib_interface {
+    int             ifNumber;   /* number of interfaces */
+};
+
+struct mib_ifEntry {
+    int             ifIndex;    /* index of this interface  */
+    char            ifDescr[32];        /* english description of interface */
+    int             ifType;     /* network type of device   */
+    int             ifMtu;      /* size of largest packet in bytes  */
+    u_int           ifSpeed;    /* bandwidth in bits/sec    */
+    u_char          ifPhysAddress[11];  /* interface's address */
+    u_char          PhysAddrLen;        /* length of physAddr */
+    int             ifAdminStatus;      /* desired state of interface */
+    int             ifOperStatus;       /* current operational status */
+    u_int           ifLastChange;       /* value of sysUpTime when current state entered */
+    u_int           ifInOctets; /* number of octets received on interface */
+    u_int           ifInUcastPkts;      /* number of unicast packets delivered */
+    u_int           ifInNUcastPkts;     /* number of broadcasts or multicasts */
+    u_int           ifInDiscards;       /* number of packets discarded with no error */
+    u_int           ifInErrors; /* number of packets containing errors */
+    u_int           ifInUnknownProtos;  /* number of packets with unknown protocol */
+    u_int           ifOutOctets;        /* number of octets transmitted */
+    u_int           ifOutUcastPkts;     /* number of unicast packets sent */
+    u_int           ifOutNUcastPkts;    /* number of broadcast or multicast pkts */
+    u_int           ifOutDiscards;      /* number of packets discarded with no error */
+    u_int           ifOutErrors;        /* number of pkts discarded with an error */
+    u_int           ifOutQLen;  /* number of packets in output queue */
+};
+
+struct mib_atEntry {
+    int             atIfIndex;  /* interface on which this entry maps */
+    u_char          atPhysAddress[11];  /* physical address of destination */
+    u_char          PhysAddressLen;     /* length of atPhysAddress */
+    u_int           atNetAddress;       /* IP address of physical address */
+};
+
+struct mib_ip {
+    int             ipForwarding;       /* 1 if gateway, 2 if host */
+    int             ipDefaultTTL;       /* default TTL for pkts originating here */
+    u_int           ipInReceives;       /* no. of IP packets received from interfaces */
+    u_int           ipInHdrErrors;      /* number of pkts discarded due to header errors */
+    u_int           ipInAddrErrors;     /* no. of pkts discarded due to bad address */
+    u_int           ipForwDatagrams;    /* number pf pkts forwarded through this entity */
+    u_int           ipInUnknownProtos;  /* no. of local-addressed pkts w/unknown proto */
+    u_int           ipInDiscards;       /* number of error-free packets discarded */
+    u_int           ipInDelivers;       /* number of datagrams delivered to upper level */
+    u_int           ipOutRequests;      /* number of IP datagrams originating locally */
+    u_int           ipOutDiscards;      /* number of error-free output IP pkts discarded */
+    u_int           ipOutNoRoutes;      /* number of IP pkts discarded due to no route */
+    int             ipReasmTimeout;     /* seconds fragment is held awaiting reassembly */
+    u_int           ipReasmReqds;       /* no. of fragments needing reassembly (here) */
+    u_int           ipReasmOKs; /* number of fragments reassembled */
+    u_int           ipReasmFails;       /* number of failures in IP reassembly */
+    u_int           ipFragOKs;  /* number of datagrams fragmented here */
+    u_int           ipFragFails;        /* no. pkts unable to be fragmented here */
+    u_int           ipFragCreates;      /* number of IP fragments created here */
+};
+
+struct mib_ipAddrEntry {
+    u_int           ipAdEntAddr;        /* IP address of this entry */
+    int             ipAdEntIfIndex;     /* IF for this entry */
+    u_int           ipAdEntNetMask;     /* subnet mask of this entry */
+    int             ipAdEntBcastAddr;   /* read the MIB for this one */
+    int 	    ipAdEntReasmMaxSize;
+		/* max size for dg reassembly   {ipAddrEntry 5} */
+};
+
+struct mib_ipRouteEntry {
+    u_int           ipRouteDest;        /* destination IP addr for this route */
+    int             ipRouteIfIndex;     /* index of local IF for this route */
+    int             ipRouteMetric1;     /* Primary routing metric */
+    int             ipRouteMetric2;     /* Alternate routing metric */
+    int             ipRouteMetric3;     /* Alternate routing metric */
+    int             ipRouteMetric4;     /* Alternate routing metric */
+    u_int           ipRouteNextHop;     /* IP addr of next hop */
+    int             ipRouteType;        /* Type of this route */
+    int             ipRouteProto;       /* How this route was learned */
+    int             ipRouteAge; /* No. of seconds since updating this route */
+};
+
+struct mib_icmp {
+    u_int           icmpInMsgs; /* Total of ICMP msgs received */
+    u_int           icmpInErrors;       /* Total of ICMP msgs received with errors */
+    u_int           icmpInDestUnreachs;
+    u_int           icmpInTimeExcds;
+    u_int           icmpInParmProbs;
+    u_int           icmpInSrcQuenchs;
+    u_int           icmpInRedirects;
+    u_int           icmpInEchos;
+    u_int           icmpInEchoReps;
+    u_int           icmpInTimestamps;
+    u_int           icmpInTimestampReps;
+    u_int           icmpInAddrMasks;
+    u_int           icmpInAddrMaskReps;
+    u_int           icmpOutMsgs;
+    u_int           icmpOutErrors;
+    u_int           icmpOutDestUnreachs;
+    u_int           icmpOutTimeExcds;
+    u_int           icmpOutParmProbs;
+    u_int           icmpOutSrcQuenchs;
+    u_int           icmpOutRedirects;
+    u_int           icmpOutEchos;
+    u_int           icmpOutEchoReps;
+    u_int           icmpOutTimestamps;
+    u_int           icmpOutTimestampReps;
+    u_int           icmpOutAddrMasks;
+    u_int           icmpOutAddrMaskReps;
+};
+
+struct mib_tcp {
+    int             tcpRtoAlgorithm;    /* retransmission timeout algorithm */
+    int             tcpRtoMin;  /* minimum retransmission timeout (mS) */
+    int             tcpRtoMax;  /* maximum retransmission timeout (mS) */
+    int             tcpMaxConn; /* maximum tcp connections possible */
+    u_int           tcpActiveOpens;     /* number of SYN-SENT -> CLOSED transitions */
+    u_int           tcpPassiveOpens;    /* number of SYN-RCVD -> LISTEN transitions */
+    u_int           tcpAttemptFails;    /*(SYN-SENT,SYN-RCVD)->CLOSED or SYN-RCVD->LISTEN */
+    u_int           tcpEstabResets;     /* (ESTABLISHED,CLOSE-WAIT) -> CLOSED */
+    u_int           tcpCurrEstab;       /* number in ESTABLISHED or CLOSE-WAIT state */
+    u_int           tcpInSegs;  /* number of segments received */
+    u_int           tcpOutSegs; /* number of segments sent */
+    u_int           tcpRetransSegs;     /* number of retransmitted segments */
+};
+
+struct mib_tcpConnEntry {
+    int             tcpConnState;       /* State of this connection */
+    u_int           tcpConnLocalAddress;        /* local IP address for this connection */
+    int             tcpConnLocalPort;   /* local port for this connection */
+    u_int           tcpConnRemAddress;  /* remote IP address for this connection */
+    int             tcpConnRemPort;     /* remote port for this connection */
+};
+
+struct mib_udp {
+    u_int           udpInDatagrams;     /* No. of UDP datagrams delivered to users */
+    u_int           udpNoPorts; /* No. of UDP datagrams to port with no listener */
+    u_int           udpInErrors;        /* No. of UDP datagrams unable to be delivered */
+    u_int           udpOutDatagrams;    /* No. of UDP datagrams sent from this entity */
+};
+
+struct mib_egp {
+    u_int           egpInMsgs;  /* No. of EGP msgs received without error */
+    u_int           egpInErrors;        /* No. of EGP msgs received with error */
+    u_int           egpOutMsgs; /* No. of EGP msgs sent */
+    u_int           egpOutErrors;       /* No. of (outgoing) EGP msgs dropped due to error */
+};
+
+struct mib_egpNeighEntry {
+    int             egpNeighState;      /* local EGP state with this entry's neighbor */
+    u_int           egpNeighAddr;       /* IP address of this entry's neighbor */
+};
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* NET_SNMP_CMU_COMPAT_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/container_binary_array.h quaggasnmpTrap//include/net-snmp/library/container_binary_array.h
--- quagga-0.99.18//include/net-snmp/library/container_binary_array.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/container_binary_array.h	2007-10-15 13:52:11.000000000 -0700
@@ -0,0 +1,46 @@
+/*
+ * binary_array.h
+ * $Id: container_binary_array.h 16726 2007-10-15 20:52:11Z rstory $
+ */
+
+#ifndef BINARY_ARRAY_H
+#define BINARY_ARRAY_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#include <net-snmp/library/asn1.h>
+#include <net-snmp/library/container.h>
+#include <net-snmp/library/factory.h>
+
+    /*
+     * initialize binary array container. call at startup.
+     */
+    void netsnmp_container_binary_array_init(void);
+
+    /*
+     * get an container which uses an binary_array for storage
+     */
+    netsnmp_container *   netsnmp_container_get_binary_array(void);
+
+    /*
+     * get a factory for producing binary_array objects
+     */
+    netsnmp_factory *     netsnmp_container_get_binary_array_factory(void);
+
+
+    int netsnmp_binary_array_remove(netsnmp_container *c, const void *key,
+                                    void **save);
+
+    void netsnmp_binary_array_release(netsnmp_container *c);
+
+    void netsnmp_container_binary_array_init(void);
+
+    int netsnmp_binary_array_options_set(netsnmp_container *c, int set, u_int flags);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/library/container.h quaggasnmpTrap//include/net-snmp/library/container.h
--- quagga-0.99.18//include/net-snmp/library/container.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/container.h	2010-05-30 12:16:50.000000000 -0700
@@ -0,0 +1,666 @@
+/* Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ */
+/*
+ * Portions of this file are copyrighted by:
+ * Copyright (C) 2007 Apple, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+#ifndef NETSNMP_CONTAINER_H
+#define NETSNMP_CONTAINER_H
+
+/*
+ * $Id: container.h 18910 2010-05-30 19:16:50Z bvassche $
+ *
+ * WARNING: This is a recently created file, and all of it's contents are
+ *          subject to change at any time.
+ *
+ * A basic container template. A generic way for code to store and
+ * retrieve data. Allows for interchangable storage algorithms.
+ */
+#ifndef NET_SNMP_CONFIG_H
+#error "Please include <net-snmp/net-snmp-config.h> before this file"
+#endif
+
+#include <stdlib.h> /* free() */
+#include <net-snmp/types.h>
+#include <net-snmp/library/factory.h>
+#include <net-snmp/library/snmp_logging.h>
+#include <net-snmp/library/tools.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+    /*************************************************************************
+     *
+     * function pointer definitions
+     *
+     *************************************************************************/
+    struct netsnmp_iterator_s; /** forward declare */
+    struct netsnmp_container_s; /** forward declare */
+
+    /*
+     * function for performing an operation on a container which
+     * returns (maybe the same) container.
+     */
+    typedef struct netsnmp_container_s* (netsnmp_container_mod_op)
+        (struct netsnmp_container_s *, void *context, u_int flags);
+
+    /*
+     * function for setting an option on a container
+     */
+    typedef int (netsnmp_container_option)(struct netsnmp_container_s *,
+                                           int set, u_int flags);
+
+    /*
+     * function returning an int for an operation on a container
+     */
+    typedef int (netsnmp_container_rc)(struct netsnmp_container_s *);
+
+    /*
+     * function returning an iterator for a container
+     */
+    typedef struct netsnmp_iterator_s * (netsnmp_container_it)
+        (struct netsnmp_container_s *);
+
+    /*
+     * function returning a size_t for an operation on a container
+     */
+    typedef size_t (netsnmp_container_size)(struct netsnmp_container_s *);
+
+    /*
+     * function returning an int for an operation on an object and
+     * a container
+     */
+    typedef int (netsnmp_container_op)(struct netsnmp_container_s *,
+                                       const void *data);
+
+    /*
+     * function returning an oject for an operation on an object and a
+     * container
+     */
+    typedef void * (netsnmp_container_rtn)(struct netsnmp_container_s *,
+                                           const void *data);
+
+    /*
+     * function with no return which acts on an object
+     */
+    typedef void (netsnmp_container_obj_func)(void *data, void *context);
+
+    /*
+     * function with no return which calls a function on an object
+     */
+    typedef void (netsnmp_container_func)(struct netsnmp_container_s *,
+                                          netsnmp_container_obj_func *,
+                                          void *context);
+
+    /*
+     * function returning an array of objects for an operation on an
+     * ojbect and a container
+     */
+    typedef netsnmp_void_array * (netsnmp_container_set)
+        (struct netsnmp_container_s *, void *data);
+
+    /*
+     * function returning an int for a comparison between two objects
+     */
+    typedef int (netsnmp_container_compare)(const void *lhs,
+                                            const void *rhs);
+
+    /*************************************************************************
+     *
+     * Basic container
+     *
+     *************************************************************************/
+    typedef struct netsnmp_container_s {
+       
+       /*
+        * pointer for container implementation
+        */
+       void *         container_data;
+
+       /*
+        * returns the number of items in a container
+        */
+       netsnmp_container_size  *get_size;
+       
+       /*
+        * initialize a container
+        */
+       netsnmp_container_rc    *init;
+
+       /*
+        * release memory used by a container.
+        *
+        * Note: if your data structures contained allocated
+        * memory, you are responsible for releasing that
+        * memory before calling this function!
+        */
+       netsnmp_container_rc    *cfree;
+
+       /*
+        * add an entry to the container
+        */
+       netsnmp_container_op    *insert;
+
+       /*
+        * remove an entry from the container
+        */
+       netsnmp_container_op    *remove;
+
+       /*
+        * release memory for an entry from the container
+        */
+       netsnmp_container_op    *release; /* NOTE: deprecated. Use free_item */
+       netsnmp_container_obj_func *free_item;
+
+       /*
+        * find the entry in the container with the same key
+        *
+        * Note: do not change the key!  If you need to
+        * change a key, remove the entry, change the key,
+        * and the re-add the entry.
+        */
+       netsnmp_container_rtn   *find;
+
+       /*
+        * find the entry in the container with the next highest key
+        *
+        * If the key is NULL, return the first item in the container.
+        */
+       netsnmp_container_rtn   *find_next;
+
+       /*
+        * find all entries in the container which match the partial key
+        * returns allocated memory (netsnmp_void_array). User is responsible
+        * for releasing this memory (free(array->array), free(array)).
+        * DO NOT FREE ELEMENTS OF THE ARRAY, because they are the same pointers
+        * stored in the container.
+        */
+       netsnmp_container_set            *get_subset;
+
+       /*
+        * function to return an iterator for the container
+        */
+       netsnmp_container_it           *get_iterator;
+
+       /*
+        * function to call another function for each object in the container
+        */
+       netsnmp_container_func         *for_each;
+
+       /*
+        * specialized version of for_each used to optimize cleanup.
+        * clear the container, optionally calling a function for each item.
+        */
+       netsnmp_container_func         *clear;
+
+       /*
+        * OPTIONAL function to filter inserts to the container
+        *  (intended for a secondary container, which only wants
+        *   a sub-set of the objects in the primary/parent container)
+        * Returns:
+        *   1 : filter matched (don't insert)
+        *   0 : no match (insert)
+        */
+       netsnmp_container_op    *insert_filter;
+
+        /*
+         * OPTIONAL function to duplicate a container. Defaults to a shallow
+         * copy. Only the specified container is copied (i.e. sub-containers
+         * not included).
+         */
+        netsnmp_container_mod_op *duplicate;
+
+
+       /*
+        * function to compare two object stored in the container.
+        *
+        * Returns:
+        *
+        *   -1  LHS < RHS
+        *    0  LHS = RHS
+        *    1  LHS > RHS
+        */
+       netsnmp_container_compare        *compare;
+
+       /*
+        * same as compare, but RHS will be a partial key
+        */
+       netsnmp_container_compare        *ncompare;
+
+       /*
+        * function to set container options
+        */
+       netsnmp_container_option         *options;
+
+       /*
+        * unique name for finding a particular container in a list
+        */
+       char *container_name;
+
+       /*
+        * sort count, for iterators to track (insert/delete
+        * bumps counter, invalidates iterator)
+        */
+       u_long                          sync;
+
+       /*
+        * flags
+        */
+       u_int                           flags;
+
+       /*
+        * containers can contain other containers (additional indexes)
+        */
+       struct netsnmp_container_s *next, *prev;
+
+    } netsnmp_container;
+
+    /*
+     * initialize/free a container of container factories. used by
+     * netsnmp_container_find* functions.
+     */
+    NETSNMP_IMPORT
+    void netsnmp_container_init_list(void);
+    NETSNMP_IMPORT
+    void netsnmp_container_free_list(void);
+
+    /*
+     * register a new container factory
+     */
+    int netsnmp_container_register_with_compare(const char* name,
+                                                netsnmp_factory *f,
+                                                netsnmp_container_compare *c);
+    int netsnmp_container_register(const char* name, netsnmp_factory *f);
+
+    /*
+     * search for and create a container from a list of types or a
+     * specific type.
+     */
+    NETSNMP_IMPORT
+    netsnmp_container * netsnmp_container_find(const char *type_list);
+    netsnmp_container * netsnmp_container_get(const char *type);
+
+    /*
+     * utility routines
+     */
+    NETSNMP_IMPORT
+    void netsnmp_container_add_index(netsnmp_container *primary,
+                                     netsnmp_container *new_index);
+
+
+    netsnmp_factory *netsnmp_container_get_factory(const char *type);
+
+    /*
+     * common comparison routines
+     */
+    /** first data element is a 'netsnmp_index' */
+    NETSNMP_IMPORT
+    int netsnmp_compare_netsnmp_index(const void *lhs, const void *rhs);
+    NETSNMP_IMPORT
+    int netsnmp_ncompare_netsnmp_index(const void *lhs, const void *rhs);
+
+    /** first data element is a 'char *' */
+    int netsnmp_compare_cstring(const void * lhs, const void * rhs);
+    int netsnmp_ncompare_cstring(const void * lhs, const void * rhs);
+
+    /** useful for octet strings */
+    int netsnmp_compare_mem(const char * lhs, size_t lhs_len,
+                            const char * rhs, size_t rhs_len);
+
+    /** no structure, just 'char *' pointers */
+    int netsnmp_compare_direct_cstring(const void * lhs, const void * rhs);
+
+    int netsnmp_compare_long(const void * lhs, const void * rhs);
+    int netsnmp_compare_ulong(const void * lhs, const void * rhs);
+    int netsnmp_compare_int32(const void * lhs, const void * rhs);
+    int netsnmp_compare_uint32(const void * lhs, const void * rhs);
+
+    /** for_each callback to call free on data item */
+    NETSNMP_IMPORT
+    void  netsnmp_container_simple_free(void *data, void *context);
+
+/*
+ * container optionflags
+ */
+#define CONTAINER_KEY_ALLOW_DUPLICATES             0x00000001
+#define CONTAINER_KEY_UNSORTED                     0x00000002
+
+#define CONTAINER_SET_OPTIONS(x,o,rc)  do {                             \
+        if (NULL==(x)->options)                                         \
+            rc = -1;                                                    \
+        else {                                                          \
+            rc = (x)->options(x, 1, o);                                 \
+            if (rc != -1 )                                              \
+                (x)->flags |= o;                                        \
+        }                                                               \
+    } while(0)
+
+#define CONTAINER_CHECK_OPTION(x,o,rc)    do {                          \
+        rc = x->flags & 0;                                              \
+    } while(0)
+
+
+    /*
+     * useful macros (x = container; k = key; c = user context)
+     */
+#define CONTAINER_FIRST(x)          (x)->find_next(x,NULL)
+#define CONTAINER_FIND(x,k)         (x)->find(x,k)
+#define CONTAINER_NEXT(x,k)         (x)->find_next(x,k)
+/*
+ * GET_SUBSET returns allocated memory (netsnmp_void_array). User is responsible
+ * for releasing this memory (free(array->array), free(array)).
+ * DO NOT FREE ELEMENTS OF THE ARRAY, because they are the same pointers
+ * stored in the container.
+ */
+#define CONTAINER_GET_SUBSET(x,k)   (x)->get_subset(x,k)
+#define CONTAINER_SIZE(x)           (x)->get_size(x)
+#define CONTAINER_ITERATOR(x)       (x)->get_iterator(x)
+#define CONTAINER_COMPARE(x,l,r)    (x)->compare(l,r)
+#define CONTAINER_FOR_EACH(x,f,c)   (x)->for_each(x,f,c)
+
+    /*
+     * if you are getting multiple definitions of these three
+     * inline functions, you most likely have optimizations turned off.
+     * Either turn them back on, or define NETSNMP_NO_INLINE
+     */
+#ifndef NETSNMP_USE_INLINE /* default is to inline */
+    /*
+     * insert k into all containers
+     */
+    int CONTAINER_INSERT(netsnmp_container *x, const void *k);
+
+    /*
+     * remove k from all containers
+     */
+    int CONTAINER_REMOVE(netsnmp_container *x, const void *k);
+
+    /*
+     * duplicate container
+     */
+    netsnmp_container *CONTAINER_DUP(netsnmp_container *x, void *ctx,
+                                     u_int flags);
+
+    /*
+     * clear all containers. When clearing the *first* container, and
+     * *only* the first container, call the function f for each item.
+     * After calling this function, all containers should be empty.
+     */
+    void CONTAINER_CLEAR(netsnmp_container *x, netsnmp_container_obj_func *f,
+                        void *c);
+
+    /*
+     * clear all containers. When clearing the *first* container, and
+     * *only* the first container, call the free_item function for each item.
+     * After calling this function, all containers should be empty.
+     */
+    void CONTAINER_FREE_ALL(netsnmp_container *x, void *c);
+
+    /*
+     * free all containers
+     */
+    int CONTAINER_FREE(netsnmp_container *x);
+
+    netsnmp_container *SUBCONTAINER_FIND(netsnmp_container *x,
+                                         const char* name);
+#else
+    /*------------------------------------------------------------------
+     * These functions should EXACTLY match the function version in
+     * container.c. If you change one, change them both.
+     */
+    NETSNMP_STATIC_INLINE /* gcc docs recommend static w/inline */
+    int CONTAINER_INSERT_HELPER(netsnmp_container* x, const void* k)
+    {
+        while(x && x->insert_filter && x->insert_filter(x,k) == 1)
+            x = x->next;
+        if(x) {
+            int rc = x->insert(x,k);
+            if(rc)
+                snmp_log(LOG_DEBUG,"error on subcontainer '%s' insert (%d)\n",
+                         x->container_name ? x->container_name : "", rc);
+            else {
+                rc = CONTAINER_INSERT_HELPER(x->next, k);
+                if(rc)
+                    x->remove(x,k);
+            }
+            return rc;
+        }
+        return 0;
+    }
+
+    /*------------------------------------------------------------------
+     * These functions should EXACTLY match the function version in
+     * container.c. If you change one, change them both.
+     */
+    NETSNMP_STATIC_INLINE /* gcc docs recommend static w/inline */
+    int CONTAINER_INSERT(netsnmp_container* x, const void* k)
+    {
+        /** start at first container */
+        while(x->prev)
+            x = x->prev;
+        return CONTAINER_INSERT_HELPER(x, k);
+    }
+
+    /*------------------------------------------------------------------
+     * These functions should EXACTLY match the function version in
+     * container.c. If you change one, change them both.
+     */
+    NETSNMP_STATIC_INLINE /* gcc docs recommend static w/inline */
+    int CONTAINER_REMOVE(netsnmp_container *x, const void *k)
+    {
+        int rc2, rc = 0;
+        
+        /** start at last container */
+        while(x->next)
+            x = x->next;
+        while(x) {
+            rc2 = x->remove(x,k);
+            /** ignore remove errors if there is a filter in place */
+            if ((rc2) && (NULL == x->insert_filter)) {
+                snmp_log(LOG_ERR,"error on subcontainer '%s' remove (%d)\n",
+                         x->container_name ? x->container_name : "", rc2);
+                rc = rc2;
+            }
+            x = x->prev;
+            
+        }
+        return rc;
+    }
+    
+    /*------------------------------------------------------------------
+     * These functions should EXACTLY match the function version in
+     * container.c. If you change one, change them both.
+     */
+    NETSNMP_STATIC_INLINE /* gcc docs recommend static w/inline */
+    netsnmp_container *CONTAINER_DUP(netsnmp_container *x, void *ctx,
+                                     u_int flags)
+    {
+        if (NULL == x->duplicate) {
+            snmp_log(LOG_ERR, "container '%s' does not support duplicate\n",
+                     x->container_name ? x->container_name : "");
+            return NULL;
+        }
+        return x->duplicate(x, ctx, flags);
+    }
+
+    /*------------------------------------------------------------------
+     * These functions should EXACTLY match the function version in
+     * container.c. If you change one, change them both.
+     */
+    NETSNMP_STATIC_INLINE /* gcc docs recommend static w/inline */
+    int CONTAINER_FREE(netsnmp_container *x)
+    {
+	int  rc2, rc = 0;
+        
+        /** start at last container */
+        while(x->next)
+            x = x->next;
+        while(x) {
+            netsnmp_container *tmp;
+            char *name;
+            tmp = x->prev;
+            name = x->container_name;
+            x->container_name = NULL;
+            rc2 = x->cfree(x);
+            if (rc2) {
+                snmp_log(LOG_ERR,"error on subcontainer '%s' cfree (%d)\n",
+                         name ? name : "", rc2);
+                rc = rc2;
+            }
+            SNMP_FREE(name);
+            x = tmp;
+        }
+        return rc;
+    }
+
+    /*------------------------------------------------------------------
+     * These functions should EXACTLY match the function version in
+     * container.c. If you change one, change them both.
+     */
+    /*
+     * clear all containers. When clearing the *first* container, and
+     * *only* the first container, call the function f for each item.
+     * After calling this function, all containers should be empty.
+     */
+    NETSNMP_STATIC_INLINE /* gcc docs recommend static w/inline */
+    void CONTAINER_CLEAR(netsnmp_container *x, netsnmp_container_obj_func *f,
+                        void *c)
+    {
+        /** start at last container */
+        while(x->next)
+            x = x->next;
+        while(x->prev) {
+            x->clear(x, NULL, c);
+            x = x->prev;
+        }
+        x->clear(x, f, c);
+    }
+
+    /*
+     * clear all containers. When clearing the *first* container, and
+     * *only* the first container, call the free_item function for each item.
+     * After calling this function, all containers should be empty.
+     */
+    NETSNMP_STATIC_INLINE /* gcc docs recommend static w/inline */
+    void CONTAINER_FREE_ALL(netsnmp_container *x, void *c)
+    {
+        CONTAINER_CLEAR(x, x->free_item, c);
+    }
+
+    /*------------------------------------------------------------------
+     * These functions should EXACTLY match the function version in
+     * container.c. If you change one, change them both.
+     */
+    /*
+     * Find a sub-container with the given name
+     */
+    NETSNMP_STATIC_INLINE /* gcc docs recommend static w/inline */
+    netsnmp_container *SUBCONTAINER_FIND(netsnmp_container *x,
+                                         const char* name)
+    {
+        if ((NULL == x) || (NULL == name))
+            return NULL;
+
+        /** start at first container */
+        while(x->prev)
+            x = x->prev;
+        while(x) {
+            if ((NULL != x->container_name) &&
+                (0 == strcmp(name,x->container_name)))
+                break;
+            x = x->next;
+        }
+        return x;
+    }
+
+#endif
+
+    /*
+     * INTERNAL utility routines for container implementations
+     */
+    void netsnmp_init_container(netsnmp_container         *c,
+                                netsnmp_container_rc      *init,
+                                netsnmp_container_rc      *cfree,
+                                netsnmp_container_size    *size,
+                                netsnmp_container_compare *cmp,
+                                netsnmp_container_op      *ins,
+                                netsnmp_container_op      *rem,
+                                netsnmp_container_rtn     *fnd);
+    /** Duplicate container meta-data. */
+    int netsnmp_container_data_dup(netsnmp_container *dup,
+                                   netsnmp_container *c);
+
+    
+    /*************************************************************************
+     *
+     * container iterator
+     *
+     *************************************************************************/
+    /*
+     * function returning an int for an operation on an iterator
+     */
+    typedef int (netsnmp_iterator_rc)(struct netsnmp_iterator_s *);
+
+    /*
+     * function returning an oject for an operation on an iterator
+     */
+    typedef void * (netsnmp_iterator_rtn)(struct netsnmp_iterator_s *);
+
+
+    /*
+     * iterator structure
+     */
+    typedef struct netsnmp_iterator_s {
+
+       netsnmp_container              *container;
+
+        /*
+         * sync from container when iterator created. used to invalidate
+         * the iterator when the container changes.
+         */
+       u_long                          sync;
+
+        /*
+         * reset iterator position to beginning of container.
+         */
+       netsnmp_iterator_rc           *reset;
+
+        /*
+         * release iterator and memory it uses
+         */
+       netsnmp_iterator_rc           *release;
+
+        /*
+         * first, last and current DO NOT advance the iterator
+         */
+       netsnmp_iterator_rtn          *first;
+       netsnmp_iterator_rtn          *curr;
+       netsnmp_iterator_rtn          *last;
+
+       netsnmp_iterator_rtn          *next;
+
+        /*
+         * remove will remove the item at the current position, then back up
+         * the iterator to the previous item. That way next will move to the
+         * item (the one that replaced the removed item.
+         */
+       netsnmp_iterator_rc           *remove;
+
+    } netsnmp_iterator;
+
+
+#define ITERATOR_FIRST(x)  x->first(x)
+#define ITERATOR_NEXT(x)   x->next(x)
+#define ITERATOR_LAST(x)   x->last(x)
+#define ITERATOR_REMOVE(x) x->remove(x)
+#define ITERATOR_RELEASE(x) do { x->release(x); x = NULL; } while(0)
+    
+#ifdef  __cplusplus
+}
+#endif
+
+#endif /** NETSNMP_CONTAINER_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/container_iterator.h quaggasnmpTrap//include/net-snmp/library/container_iterator.h
--- quagga-0.99.18//include/net-snmp/library/container_iterator.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/container_iterator.h	2004-09-13 19:29:16.000000000 -0700
@@ -0,0 +1,62 @@
+/**
+ * @file container_iterator.h
+ * @addtogroup container_iterator
+ * @{
+ */
+#ifndef _CONTAINER_ITERATOR_HANDLER_H_
+#define _CONTAINER_ITERATOR_HANDLER_H_
+
+#include "container.h"
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    typedef int (Netsnmp_Iterator_Loop_Key) (void *iterator_ctx,
+                                             netsnmp_ref_void* loop_ctx,
+                                             netsnmp_ref_void* key);
+    typedef int (Netsnmp_Iterator_Loop_Data)(void *iterator_ctx,
+                                             netsnmp_ref_void* loop_ctx,
+                                             netsnmp_ref_void* data);
+    typedef int (Netsnmp_Iterator_Ctx) (void *iterator_ctx,
+                                         netsnmp_ref_void* loop_ctx);
+    typedef int (Netsnmp_Iterator_Ctx_Dup) (void *iterator_ctx,
+                                            netsnmp_ref_void* loop_ctx,
+                                            netsnmp_ref_void* dup_ctx,
+                                            int reuse);
+    typedef int (Netsnmp_Iterator_Op) (void *iterator_ctx);
+    typedef int (Netsnmp_Iterator_Data) (void *iterator_ctx,
+                                            const void *data);    
+
+    void netsnmp_container_iterator_init(void);
+
+    netsnmp_container* netsnmp_container_iterator_get(
+        void *iterator_user_ctx,
+        netsnmp_container_compare * compare,
+        Netsnmp_Iterator_Loop_Key * get_first,
+        Netsnmp_Iterator_Loop_Key * get_next,
+        Netsnmp_Iterator_Loop_Data * get_data,
+        Netsnmp_Iterator_Ctx_Dup * save_pos, /* iff returning static data */
+        Netsnmp_Iterator_Ctx * init_loop_ctx,
+        Netsnmp_Iterator_Ctx * cleanup_loop_ctx,
+        Netsnmp_Iterator_Data * free_user_ctx,
+        int sorted);
+    
+    /*
+     * set up optional callbacks/
+     * NOTE: even though the first parameter is a generic netsnmp_container,
+     *       this function should only be called for a container created
+     *       by netsnmp_container_iterator_get.
+     */
+    void
+    netsnmp_container_iterator_set_data_cb(netsnmp_container *c,
+                                           Netsnmp_Iterator_Data * insert_data,
+                                           Netsnmp_Iterator_Data * remove_data,
+                                           Netsnmp_Iterator_Op * get_size);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif                          /* _CONTAINER_ITERATOR_HANDLER_H_ */
+/** @} */
diff -rupN quagga-0.99.18//include/net-snmp/library/container_list_ssll.h quaggasnmpTrap//include/net-snmp/library/container_list_ssll.h
--- quagga-0.99.18//include/net-snmp/library/container_list_ssll.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/container_list_ssll.h	2010-02-27 05:11:15.000000000 -0800
@@ -0,0 +1,27 @@
+/*
+ * container_list_sl.h
+ * $Id: container_list_ssll.h 18212 2010-02-27 13:11:15Z bvassche $
+ *
+ */
+#ifndef NETSNMP_CONTAINER_SSLL_H
+#define NETSNMP_CONTAINER_SSLL_H
+
+
+#include <net-snmp/library/container.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+    netsnmp_container *netsnmp_container_get_sorted_singly_linked_list(void);
+    netsnmp_container *netsnmp_container_get_singly_linked_list(int fifo);
+
+    NETSNMP_IMPORT
+    void netsnmp_container_ssll_init(void);
+
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif /** NETSNMP_CONTAINER_SSLL_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/container_null.h quaggasnmpTrap//include/net-snmp/library/container_null.h
--- quagga-0.99.18//include/net-snmp/library/container_null.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/container_null.h	2010-02-27 05:11:15.000000000 -0800
@@ -0,0 +1,21 @@
+#ifndef NETSNMP_CONTAINER_NULL_H
+#define NETSNMP_CONTAINER_NULL_H
+
+
+#include <net-snmp/library/container.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+netsnmp_container *netsnmp_container_get_null(void);
+
+    NETSNMP_IMPORT
+    void netsnmp_container_null_init(void);
+
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif /** NETSNMP_CONTAINER_NULL_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/data_list.h quaggasnmpTrap//include/net-snmp/library/data_list.h
--- quagga-0.99.18//include/net-snmp/library/data_list.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/data_list.h	2010-02-27 05:11:15.000000000 -0800
@@ -0,0 +1,105 @@
+/* Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ */
+/*
+ * Portions of this file are copyrighted by:
+ * Copyright Â© 2003 Sun Microsystems, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+/*
+ * @file netsnmp_data_list.h
+ *
+ * @addtogroup agent
+ * @addtogroup library *
+ *
+ * $Id: data_list.h 18212 2010-02-27 13:11:15Z bvassche $
+ *
+ * External definitions for functions and variables in netsnmp_data_list.c.
+ *
+ * @{
+ */
+
+#ifndef DATA_LIST_H
+#define DATA_LIST_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#include <net-snmp/library/snmp_impl.h>
+#include <net-snmp/library/tools.h>
+
+    typedef void    (Netsnmp_Free_List_Data) (void *);
+    typedef int     (Netsnmp_Save_List_Data) (char *buf, size_t buf_len, void *);
+    typedef void *  (Netsnmp_Read_List_Data) (char *buf, size_t buf_len);
+
+/** @struct netsnmp_data_list_s
+ * used to iterate through lists of data
+ */
+    typedef struct netsnmp_data_list_s {
+        struct netsnmp_data_list_s *next;
+        char           *name;
+ 	/** The pointer to the data passed on. */
+        void           *data;
+        /** must know how to free netsnmp_data_list->data */
+        Netsnmp_Free_List_Data *free_func;
+    } netsnmp_data_list;
+
+    typedef struct netsnmp_data_list_saveinfo_s {
+       netsnmp_data_list **datalist;
+       const char *type;
+       const char *token;
+       Netsnmp_Save_List_Data *data_list_save_ptr;
+       Netsnmp_Read_List_Data *data_list_read_ptr;
+       Netsnmp_Free_List_Data *data_list_free_ptr;
+    } netsnmp_data_list_saveinfo;
+
+    NETSNMP_IMPORT
+    netsnmp_data_list *
+      netsnmp_create_data_list(const char *, void *, Netsnmp_Free_List_Data* );
+    void            netsnmp_data_list_add_node(netsnmp_data_list **head,
+                                               netsnmp_data_list *node);
+    netsnmp_data_list *
+      netsnmp_data_list_add_data(netsnmp_data_list **head,
+                                 const char *name, void *data,
+                                 Netsnmp_Free_List_Data * beer);
+    NETSNMP_IMPORT
+    void           *netsnmp_get_list_data(netsnmp_data_list *head,
+                                          const char *node);
+    NETSNMP_IMPORT
+    void            netsnmp_free_list_data(netsnmp_data_list *head);    /* single */
+    NETSNMP_IMPORT
+    void            netsnmp_free_all_list_data(netsnmp_data_list *head);        /* multiple */
+    NETSNMP_IMPORT
+    int             netsnmp_remove_list_node(netsnmp_data_list **realhead,
+                                             const char *name);
+    NETSNMP_IMPORT
+    netsnmp_data_list *
+    netsnmp_get_list_node(netsnmp_data_list *head,
+                          const char *name);
+
+    /** depreciated: use netsnmp_data_list_add_node() */
+    NETSNMP_IMPORT
+    void            netsnmp_add_list_data(netsnmp_data_list **head,
+                                          netsnmp_data_list *node);
+
+
+    void
+    netsnmp_register_save_list(netsnmp_data_list **datalist,
+                               const char *type, const char *token,
+                               Netsnmp_Save_List_Data *data_list_save_ptr,
+                               Netsnmp_Read_List_Data *data_list_read_ptr,
+                               Netsnmp_Free_List_Data *data_list_free_ptr);
+    int
+    netsnmp_save_all_data(netsnmp_data_list *head,
+                          const char *type, const char *token,
+                          Netsnmp_Save_List_Data * data_list_save_ptr);
+    SNMPCallback netsnmp_save_all_data_callback;
+    void netsnmp_read_data_callback(const char *token, char *line);
+#ifdef __cplusplus
+}
+#endif
+#endif
+/** @} */
diff -rupN quagga-0.99.18//include/net-snmp/library/default_store.h quaggasnmpTrap//include/net-snmp/library/default_store.h
--- quagga-0.99.18//include/net-snmp/library/default_store.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/default_store.h	2010-06-28 12:13:04.000000000 -0700
@@ -0,0 +1,202 @@
+/* Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ */
+/*
+ * Portions of this file are copyrighted by:
+ * Copyright Â© 2003 Sun Microsystems, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+/*
+ * Note:
+ *    If new default_store entries are added to this header file,
+ *    then remember to run 'perl/default_store/gen' to update the
+ *    corresponding perl interface.
+ */
+/*
+ * @file default_store.h: storage space for defaults
+ *
+ * @addtogroup default_store
+ *
+ * @{
+ */
+#ifndef DEFAULT_STORE_H
+#define DEFAULT_STORE_H
+
+#include <net-snmp/net-snmp-config.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#define NETSNMP_DS_MAX_IDS 3
+#define NETSNMP_DS_MAX_SUBIDS 48        /* needs to be a multiple of 8 */
+
+    /*
+     * begin storage definitions 
+     */
+/**
+ * @def NETSNMP_DS_LIBRARY_ID These definitions correspond with the "storid" argument to the API 
+ */
+#define NETSNMP_DS_LIBRARY_ID     0
+#define NETSNMP_DS_APPLICATION_ID 1
+#define NETSNMP_DS_TOKEN_ID       2
+
+    /*
+     * These definitions correspond with the "which" argument to the API,
+     * when the storeid argument is NETSNMP_DS_LIBRARY_ID 
+     */
+    /*
+     * library booleans 
+     */
+#define NETSNMP_DS_LIB_MIB_ERRORS          0
+#define NETSNMP_DS_LIB_SAVE_MIB_DESCRS     1
+#define NETSNMP_DS_LIB_MIB_COMMENT_TERM    2
+#define NETSNMP_DS_LIB_MIB_PARSE_LABEL     3
+#define NETSNMP_DS_LIB_DUMP_PACKET         4
+#define NETSNMP_DS_LIB_LOG_TIMESTAMP       5
+#define NETSNMP_DS_LIB_DONT_READ_CONFIGS   6    /* don't read normal config files */
+#define NETSNMP_DS_LIB_DISABLE_CONFIG_LOAD      NETSNMP_DS_LIB_DONT_READ_CONFIGS
+#define NETSNMP_DS_LIB_MIB_REPLACE         7    /* replace objects from latest module */
+#define NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM  8    /* print only numeric enum values */
+#define NETSNMP_DS_LIB_PRINT_NUMERIC_OIDS  9    /* print only numeric enum values */
+#define NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS 10   /* dont print oid indexes specially */
+#define NETSNMP_DS_LIB_ALARM_DONT_USE_SIG  11   /* don't use the alarm() signal */
+#define NETSNMP_DS_LIB_PRINT_FULL_OID      12   /* print fully qualified oids */
+#define NETSNMP_DS_LIB_QUICK_PRINT         13   /* print very brief output for parsing */
+#define NETSNMP_DS_LIB_RANDOM_ACCESS	   14   /* random access to oid labels */
+#define NETSNMP_DS_LIB_REGEX_ACCESS	   15   /* regex matching to oid labels */
+#define NETSNMP_DS_LIB_DONT_CHECK_RANGE    16   /* don't check values for ranges on send */
+#define NETSNMP_DS_LIB_NO_TOKEN_WARNINGS   17   /* no warn about unknown config tokens */
+#define NETSNMP_DS_LIB_NUMERIC_TIMETICKS   18   /* print timeticks as a number */
+#define NETSNMP_DS_LIB_ESCAPE_QUOTES       19   /* shell escape quote marks in oids */
+#define NETSNMP_DS_LIB_REVERSE_ENCODE      20   /* encode packets from back to front */
+#define NETSNMP_DS_LIB_PRINT_BARE_VALUE	   21   /* just print value (not OID = value) */
+#define NETSNMP_DS_LIB_EXTENDED_INDEX	   22   /* print extended index format [x1][x2] */
+#define NETSNMP_DS_LIB_PRINT_HEX_TEXT      23   /* print ASCII text along with hex strings */
+#define NETSNMP_DS_LIB_PRINT_UCD_STYLE_OID 24   /* print OID's using the UCD-style prefix suppression */
+#define NETSNMP_DS_LIB_READ_UCD_STYLE_OID  25   /* require top-level OIDs to be prefixed with a dot */
+#define NETSNMP_DS_LIB_HAVE_READ_PREMIB_CONFIG 26       /* have the pre-mib parsing config tokens been processed */
+#define NETSNMP_DS_LIB_HAVE_READ_CONFIG    27   /* have the config tokens been processed */
+#define NETSNMP_DS_LIB_QUICKE_PRINT        28   
+#define NETSNMP_DS_LIB_DONT_PRINT_UNITS    29 /* don't print UNITS suffix */
+#define NETSNMP_DS_LIB_NO_DISPLAY_HINT     30 /* don't apply DISPLAY-HINTs */
+#define NETSNMP_DS_LIB_16BIT_IDS           31   /* restrict requestIDs, etc to 16-bit values */
+#define NETSNMP_DS_LIB_DONT_PERSIST_STATE  32	/* don't load config and don't load/save persistent file */
+#define NETSNMP_DS_LIB_2DIGIT_HEX_OUTPUT   33	/* print a leading 0 on hex values <= 'f' */
+#define NETSNMP_DS_LIB_IGNORE_NO_COMMUNITY 34	/* don't complain if no community is specified in the command arguments */
+#define NETSNMP_DS_LIB_DISABLE_PERSISTENT_LOAD  35 /* don't load persistent file */
+#define NETSNMP_DS_LIB_DISABLE_PERSISTENT_SAVE  36 /* don't save persistent file */
+#define NETSNMP_DS_LIB_APPEND_LOGFILES     37 /* append, don't overwrite, log files */
+#define NETSNMP_DS_LIB_NO_DISCOVERY        38 /* don't support RFC5343 contextEngineID discovery */
+#define NETSNMP_DS_LIB_TSM_USE_PREFIX      39 /* TSM's simple security name mapping */
+#define NETSNMP_DS_LIB_DONT_LOAD_HOST_FILES 40 /* don't read host.conf files */
+
+    /*
+     * library integers 
+     */
+#define NETSNMP_DS_LIB_MIB_WARNINGS         0
+#define NETSNMP_DS_LIB_SECLEVEL             1
+#define NETSNMP_DS_LIB_SNMPVERSION          2
+#define NETSNMP_DS_LIB_DEFAULT_PORT         3
+#define NETSNMP_DS_LIB_OID_OUTPUT_FORMAT    4
+#define NETSNMP_DS_LIB_PRINT_SUFFIX_ONLY    NETSNMP_DS_LIB_OID_OUTPUT_FORMAT
+#define NETSNMP_DS_LIB_STRING_OUTPUT_FORMAT 5
+#define NETSNMP_DS_LIB_HEX_OUTPUT_LENGTH    6
+#define NETSNMP_DS_LIB_SERVERSENDBUF        7 /* send buffer (server) */
+#define NETSNMP_DS_LIB_SERVERRECVBUF        8 /* receive buffer (server) */
+#define NETSNMP_DS_LIB_CLIENTSENDBUF        9 /* send buffer (client) */
+#define NETSNMP_DS_LIB_CLIENTRECVBUF       10 /* receive buffer (client) */
+#define NETSNMP_DS_SSHDOMAIN_SOCK_PERM     11
+#define NETSNMP_DS_SSHDOMAIN_DIR_PERM      12
+#define NETSNMP_DS_SSHDOMAIN_SOCK_USER     12
+#define NETSNMP_DS_SSHDOMAIN_SOCK_GROUP    13
+    
+    /*
+     * special meanings for the default SNMP version slot (NETSNMP_DS_LIB_SNMPVERSION) 
+     */
+#ifndef NETSNMP_DISABLE_SNMPV1
+#define NETSNMP_DS_SNMP_VERSION_1    128        /* bogus */
+#endif
+#ifndef NETSNMP_DISABLE_SNMPV2C
+#define NETSNMP_DS_SNMP_VERSION_2c   1  /* real */
+#endif
+#define NETSNMP_DS_SNMP_VERSION_3    3  /* real */
+
+
+    /*
+     * library strings 
+     */
+#define NETSNMP_DS_LIB_SECNAME           0
+#define NETSNMP_DS_LIB_CONTEXT           1
+#define NETSNMP_DS_LIB_PASSPHRASE        2
+#define NETSNMP_DS_LIB_AUTHPASSPHRASE    3
+#define NETSNMP_DS_LIB_PRIVPASSPHRASE    4
+#define NETSNMP_DS_LIB_OPTIONALCONFIG    5
+#define NETSNMP_DS_LIB_APPTYPE           6
+#define NETSNMP_DS_LIB_COMMUNITY         7
+#define NETSNMP_DS_LIB_PERSISTENT_DIR    8
+#define NETSNMP_DS_LIB_CONFIGURATION_DIR 9
+#define NETSNMP_DS_LIB_SECMODEL          10
+#define NETSNMP_DS_LIB_MIBDIRS           11
+#define NETSNMP_DS_LIB_OIDSUFFIX         12
+#define NETSNMP_DS_LIB_OIDPREFIX         13
+#define NETSNMP_DS_LIB_CLIENT_ADDR       14
+#define NETSNMP_DS_LIB_TEMP_FILE_PATTERN 15
+#define NETSNMP_DS_LIB_AUTHMASTERKEY     16
+#define NETSNMP_DS_LIB_PRIVMASTERKEY     17
+#define NETSNMP_DS_LIB_AUTHLOCALIZEDKEY  18
+#define NETSNMP_DS_LIB_PRIVLOCALIZEDKEY  19
+#define NETSNMP_DS_LIB_APPTYPES          20
+#define NETSNMP_DS_LIB_KSM_KEYTAB        21
+#define NETSNMP_DS_LIB_KSM_SERVICE_NAME  22
+#define NETSNMP_DS_LIB_X509_CLIENT_PUB   23
+#define NETSNMP_DS_LIB_X509_SERVER_PUB   24
+#define NETSNMP_DS_LIB_SSHTOSNMP_SOCKET  25
+#define NETSNMP_DS_LIB_CERT_EXTRA_SUBDIR 26
+#define NETSNMP_DS_LIB_HOSTNAME          27
+#define NETSNMP_DS_LIB_X509_CRL_FILE     28
+#define NETSNMP_DS_LIB_TLS_ALGORITMS     29
+
+    /*
+     * end storage definitions 
+     */
+
+    NETSNMP_IMPORT
+    int             netsnmp_ds_set_boolean(int storeid, int which, int value);
+    NETSNMP_IMPORT
+    int             netsnmp_ds_get_boolean(int storeid, int which);
+    NETSNMP_IMPORT
+    int             netsnmp_ds_toggle_boolean(int storeid, int which);
+    NETSNMP_IMPORT
+    int             netsnmp_ds_set_int(int storeid, int which, int value);
+    NETSNMP_IMPORT
+    int             netsnmp_ds_get_int(int storeid, int which);
+    NETSNMP_IMPORT
+    int             netsnmp_ds_set_string(int storeid, int which,
+                                  const char *value);
+    NETSNMP_IMPORT
+    char           *netsnmp_ds_get_string(int storeid, int which);
+    NETSNMP_IMPORT
+    int             netsnmp_ds_set_void(int storeid, int which, void *value);
+    NETSNMP_IMPORT
+    void           *netsnmp_ds_get_void(int storeid, int which);
+    NETSNMP_IMPORT
+    int             netsnmp_ds_register_config(u_char type, const char *ftype,
+                                       const char *token, int storeid,
+                                       int which);
+    NETSNMP_IMPORT
+    int             netsnmp_ds_register_premib(u_char type, const char *ftype,
+                                       const char *token, int storeid,
+                                       int which);
+    NETSNMP_IMPORT
+    int             netsnmp_ds_parse_boolean(char *line);
+    NETSNMP_IMPORT
+    void            netsnmp_ds_shutdown(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* DEFAULT_STORE_H */
+/** @} */
diff -rupN quagga-0.99.18//include/net-snmp/library/dir_utils.h quaggasnmpTrap//include/net-snmp/library/dir_utils.h
--- quagga-0.99.18//include/net-snmp/library/dir_utils.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/dir_utils.h	2010-04-01 03:00:27.000000000 -0700
@@ -0,0 +1,63 @@
+/* Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ */
+/*
+ * Portions of this file are copyrighted by:
+ * Copyright (C) 2007 Apple, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+#ifndef NETSNMP_DIR_UTILS_H
+#define NETSNMP_DIR_UTILS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /*
+     * filter function; return 1 to include file, 0 to exclude
+     */
+#define NETSNMP_DIR_EXCLUDE 0
+#define NETSNMP_DIR_INCLUDE 1
+    typedef int (netsnmp_directory_filter)(const void *text, void *ctx);
+
+
+    /*------------------------------------------------------------------
+     *
+     * Prototypes
+     */
+    netsnmp_container *
+    netsnmp_directory_container_read_some(netsnmp_container *user_container,
+                                          const char *dirname,
+                                          netsnmp_directory_filter *filter,
+                                          void *filter_ctx, u_int flags);
+
+#define netsnmp_directory_container_read(c,d,f) \
+    netsnmp_directory_container_read_some(c,d,NULL,NULL,f);
+
+    void netsnmp_directory_container_free(netsnmp_container *c);
+
+        
+
+    /*------------------------------------------------------------------
+     *
+     * flags
+     */
+#define NETSNMP_DIR_RECURSE                           0x0001
+#define NETSNMP_DIR_RELATIVE_PATH                     0x0002
+#define NETSNMP_DIR_SORTED                            0x0004
+/** don't return null if dir empty */
+#define NETSNMP_DIR_EMPTY_OK                          0x0008
+/** store netsnmp_file instead of filenames */
+#define NETSNMP_DIR_NSFILE                            0x0010
+/** load stats in netsnmp_file */
+#define NETSNMP_DIR_NSFILE_STATS                      0x0020
+
+    
+        
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETSNMP_DIR_UTILS_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/factory.h quaggasnmpTrap//include/net-snmp/library/factory.h
--- quagga-0.99.18//include/net-snmp/library/factory.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/factory.h	2004-09-13 19:29:16.000000000 -0700
@@ -0,0 +1,72 @@
+#ifndef NETSNMP_FACTORY_H
+#define NETSNMP_FACTORY_H
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    typedef void * (netsnmp_factory_produce_f)(void);
+    typedef int (netsnmp_factory_produce_noalloc_f)(void *);
+
+    typedef struct netsnmp_factory_s {
+        /*
+         * a string describing the product the factory creates
+         */
+        const char                           *product;
+
+        /*
+         * a function to create an object in newly allcoated memory
+         */
+        netsnmp_factory_produce_f            *produce;
+
+        /*
+         * a function to create an object in previously allcoated memory
+         */
+        netsnmp_factory_produce_noalloc_f    *produce_noalloc;
+
+    } netsnmp_factory;
+
+    /*
+     * init factory registry
+     */
+    void netsnmp_factory_init(void);
+
+    /*
+     * register a factory type
+     */
+    int  netsnmp_factory_register(netsnmp_factory *f);
+
+    /*
+     * get a factory
+     */
+    netsnmp_factory* netsnmp_factory_get(const char* product);
+
+    /*
+     * ask a factory to produce an object
+     */
+    void * netsnmp_factory_produce(const char* product);
+
+    /*
+     * ask a factory to produce an object in the provided memory
+     */
+    int netsnmp_factory_produce_noalloc(const char *product, void *memory);
+
+    /*
+     * factory return codes
+     */
+    enum {
+        FACTORY_NOERROR = 0,
+        FACTORY_EXISTS,
+        FACTORY_NOTFOUND,
+        FACTORY_NOMEMORY,
+        FACTORY_GENERR,
+        FACTORY_MAXIMUM_ERROR
+    };
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* NETSNMP_FACTORY_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/fd_event_manager.h quaggasnmpTrap//include/net-snmp/library/fd_event_manager.h
--- quagga-0.99.18//include/net-snmp/library/fd_event_manager.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/fd_event_manager.h	2010-02-27 05:11:15.000000000 -0800
@@ -0,0 +1,134 @@
+/**************************************************************************
+ * UNIT: File Descriptor (FD) Event Manager
+ *
+ * OVERVIEW: This unit contains functions to register a FD with the FD
+ *           event manager for callbacks when activity is received on that
+ *           FD.  Notification of read, write, and exception activity can 
+ *           all be registered for individually.  Once a registered FD is
+ *           closed by the user, the FD must be unregistered.  To use
+ *           the FD Event manager you need to make calls to 
+ *           netsnmp_external_event_info() and 
+ *           netsnmp_dispatch_external_events() in your event loop to receive
+ *           callbacks for registered events.  See snmpd.c and snmptrapd.c 
+ *           for examples.
+ *
+ * LIMITATIONS:
+ **************************************************************************/
+#ifndef FD_EVENT_MANAGER_H
+#define FD_EVENT_MANAGER_H
+
+#ifdef HAVE_SYS_SELECT_H
+#include <sys/select.h>
+#endif
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#define NUM_EXTERNAL_FDS 32
+#define FD_REGISTERED_OK                 0
+#define FD_REGISTRATION_FAILED          -2
+#define FD_UNREGISTERED_OK               0
+#define FD_NO_SUCH_REGISTRATION         -1
+
+/* Since the inception of netsnmp_external_event_info and 
+ * netsnmp_dispatch_external_events, there is no longer a need for the data 
+ * below to be globally visible.  We will leave it global for now for 
+ * compatibility purposes. */
+extern int      external_readfd[NUM_EXTERNAL_FDS],   external_readfdlen;
+extern int      external_writefd[NUM_EXTERNAL_FDS],  external_writefdlen;
+extern int      external_exceptfd[NUM_EXTERNAL_FDS], external_exceptfdlen;
+
+extern void     (*external_readfdfunc[NUM_EXTERNAL_FDS])   (int, void *);
+extern void     (*external_writefdfunc[NUM_EXTERNAL_FDS])  (int, void *);
+extern void     (*external_exceptfdfunc[NUM_EXTERNAL_FDS]) (int, void *);
+
+extern void    *external_readfd_data[NUM_EXTERNAL_FDS];
+extern void    *external_writefd_data[NUM_EXTERNAL_FDS];
+extern void    *external_exceptfd_data[NUM_EXTERNAL_FDS];
+
+/* Here are the key functions of this unit.  Use register_xfd to register
+ * a callback to be called when there is x activity on the register fd.  
+ * x can be read, write, or except (for exception).  When registering,
+ * you can pass in a pointer to some data that you have allocated that
+ * you would like to have back when the callback is called. */
+int             register_readfd(int, void (*func)(int, void *),   void *);
+int             register_writefd(int, void (*func)(int, void *),  void *);
+int             register_exceptfd(int, void (*func)(int, void *), void *);
+
+/* Unregisters a given fd for events */
+int             unregister_readfd(int);
+int             unregister_writefd(int);
+int             unregister_exceptfd(int);
+
+/*
+ * External Event Info
+ *
+ * Description:
+ *   Call this function to add an external event fds to your read, write, 
+ *   exception fds that your application already has.  When this function
+ *   returns, your fd_sets will be ready for select().  It returns the
+ *   biggest fd in the fd_sets so far.
+ *
+ * Input Parameters: None
+ *
+ * Output Parameters: None
+ *
+ * In/Out Parameters: 
+ *   numfds - The biggest fd so far.  On exit to this function, numfds
+ *            could of changed since we pass out the new biggest fd.
+ *   readfds - Set of read FDs that we are monitoring.  This function
+ *             can modify this set to have more FDs that we are monitoring.
+ *   writefds - Set of write FDs that we are monitoring.  This function
+ *             can modify this set to have more FDs that we are monitoring.
+ *   exceptfds - Set of exception FDs that we are monitoring.  This function
+ *             can modify this set to have more FDs that we are monitoring.
+ *
+ * Return Value: None
+ *
+ * Side Effects: None
+ */
+NETSNMP_IMPORT
+void netsnmp_external_event_info(int *numfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds);
+
+NETSNMP_IMPORT
+void netsnmp_external_event_info2(int *numfds,
+                                  netsnmp_large_fd_set *readfds,
+                                  netsnmp_large_fd_set *writefds,
+                                  netsnmp_large_fd_set *exceptfds);
+
+/*
+ * Dispatch External Events
+ *
+ * Description:
+ *   Call this function after select returns with pending events.  If any of
+ *   them were NETSNMP external events, the registered callback will be called.
+ *   The corresponding fd_set will have the FD cleared after the event is
+ *   dispatched.
+ *
+ * Input Parameters: None
+ *
+ * Output Parameters: None
+ *
+ * In/Out Parameters: 
+ *   count - Number of FDs that have activity.  In this function, we decrement
+ *           count as we dispatch an event.
+ *   readfds - Set of read FDs that have activity
+ *   writefds - Set of write FDs that have activity
+ *   exceptfds - Set of exception FDs that have activity 
+ *
+ * Return Value: None
+ *
+ * Side Effects: None
+ */
+NETSNMP_IMPORT
+void netsnmp_dispatch_external_events(int *count, fd_set *readfds, fd_set *writefds, fd_set *exceptfds);
+NETSNMP_IMPORT
+void netsnmp_dispatch_external_events2(int *count,
+                                       netsnmp_large_fd_set *readfds,
+                                       netsnmp_large_fd_set *writefds,
+                                       netsnmp_large_fd_set *exceptfds);
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/library/file_utils.h quaggasnmpTrap//include/net-snmp/library/file_utils.h
--- quagga-0.99.18//include/net-snmp/library/file_utils.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/file_utils.h	2010-04-01 03:00:27.000000000 -0700
@@ -0,0 +1,88 @@
+#ifndef NETSNMP_FILE_UTILS_H
+#define NETSNMP_FILE_UTILS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    
+    /*------------------------------------------------------------------
+     *
+     * structures
+     *
+     */
+    typedef struct netsnmp_file_s {
+        
+        /** file name */
+        char                   *name;
+        
+        /** file descriptor for the file */
+        int                     fd;
+
+        /** filesystem flags */
+        int                     fs_flags;
+
+        /** open/create mode */
+        mode_t                  mode;
+
+        /** netsnmp flags */
+        u_int                   ns_flags;
+
+        /** file stats */
+        struct stat            *stats;
+
+        /*
+         * future expansion
+         */
+        netsnmp_data_list      *extras;
+
+    } netsnmp_file;
+
+
+    
+    /*------------------------------------------------------------------
+     *
+     * Prototypes
+     *
+     */
+    netsnmp_file *netsnmp_file_new(const char *name, int fs_flags, mode_t mode,
+                                   u_int ns_flags);
+
+    netsnmp_file * netsnmp_file_create(void);
+    netsnmp_file * netsnmp_file_fill(netsnmp_file * filei, const char* name,
+                                     int fs_flags, mode_t mode, u_int ns_flags);
+    int netsnmp_file_release(netsnmp_file * filei);
+
+    int netsnmp_file_open(netsnmp_file * filei);
+    int netsnmp_file_close(netsnmp_file * filei);
+
+    /** support netsnmp_file containers */
+    int netsnmp_file_compare_name(netsnmp_file *lhs, netsnmp_file *rhs);
+    void netsnmp_file_container_free(netsnmp_file *file, void *context);
+
+
+
+    /*------------------------------------------------------------------
+     *
+     * flags
+     *
+     */
+#define NETSNMP_FILE_NO_AUTOCLOSE                         0x00000001
+#define NETSNMP_FILE_STATS                                0x00000002
+#define NETSNMP_FILE_AUTO_OPEN                            0x00000004
+
+    /*------------------------------------------------------------------
+     *
+     * macros
+     *
+     */
+#define NS_FI_AUTOCLOSE(x) (0 == (x & NETSNMP_FILE_NO_AUTOCLOSE))
+#define NS_FI_(x) (0 == (x & NETSNMP_FILE_))
+
+    
+        
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETSNMP_FILE_UTILS_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/getopt.h quaggasnmpTrap//include/net-snmp/library/getopt.h
--- quagga-0.99.18//include/net-snmp/library/getopt.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/getopt.h	2004-02-21 13:58:57.000000000 -0800
@@ -0,0 +1,15 @@
+#ifndef _GETOPT_H_
+#define _GETOPT_H_ 1
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+NETSNMP_IMPORT int   getopt(int, char *const *, const char *);
+NETSNMP_IMPORT char *optarg;
+NETSNMP_IMPORT int   optind, opterr, optopt, optreset;
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/library/int64.h quaggasnmpTrap//include/net-snmp/library/int64.h
--- quagga-0.99.18//include/net-snmp/library/int64.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/int64.h	2010-02-27 05:11:15.000000000 -0800
@@ -0,0 +1,43 @@
+#ifndef INT64_INCLUDED
+#define INT64_INCLUDED
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    typedef struct counter64 U64;
+
+#define I64CHARSZ 21
+
+    void            divBy10(U64, U64 *, unsigned int *);
+    void            multBy10(U64, U64 *);
+    void            incrByU16(U64 *, unsigned int);
+    void            incrByU32(U64 *, unsigned int);
+    NETSNMP_IMPORT
+    void            zeroU64(U64 *);
+    int             isZeroU64(const U64 *);
+    NETSNMP_IMPORT
+    void            printU64(char *, const U64 *);
+    NETSNMP_IMPORT
+    void            printI64(char *, const U64 *);
+    int             read64(U64 *, const char *);
+    NETSNMP_IMPORT
+    void            u64Subtract(const U64 * pu64one, const U64 * pu64two,
+                                U64 * pu64out);
+    void            u64Incr(U64 * pu64out, const U64 * pu64one);
+    void            u64UpdateCounter(U64 * pu64out, const U64 * pu64one,
+                                     const U64 * pu64two);
+    void            u64Copy(U64 * pu64one, const U64 * pu64two);
+
+    int             netsnmp_c64_check_for_32bit_wrap(U64 *old_val, U64 *new_val,
+                                                     int adjust);
+    NETSNMP_IMPORT
+    int             netsnmp_c64_check32_and_update(struct counter64 *prev_val,
+                                                   struct counter64 *new_val,
+                                                   struct counter64 *old_prev_val,
+                                                   int *need_wrap_check);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/library/keytools.h quaggasnmpTrap//include/net-snmp/library/keytools.h
--- quagga-0.99.18//include/net-snmp/library/keytools.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/keytools.h	2010-05-26 22:16:49.000000000 -0700
@@ -0,0 +1,64 @@
+/*
+ * keytools.h
+ */
+
+#ifndef _KEYTOOLS_H
+#define _KEYTOOLS_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+
+#define USM_LENGTH_EXPANDED_PASSPHRASE	(1024 * 1024)   /* 1Meg. */
+
+#define USM_LENGTH_KU_HASHBLOCK		64      /* In bytes. */
+
+#define USM_LENGTH_P_MIN		8       /* In characters. */
+    /*
+     * Recommended practice given in <draft-ietf-snmpv3-usm-v2-02.txt>,
+     * * Section 11.2 "Defining Users".  Move into cmdline app argument
+     * * parsing, and out of the internal routine?  XXX
+     */
+
+    /*
+     * Prototypes.h
+     */
+    NETSNMP_IMPORT
+    int             generate_Ku(const oid * hashtype, u_int hashtype_len,
+                                const u_char * P, size_t pplen,
+                                u_char * Ku, size_t * kulen);
+
+    NETSNMP_IMPORT
+    int             generate_kul(const oid * hashtype, u_int hashtype_len,
+                                 const u_char * engineID, size_t engineID_len,
+                                 const u_char * Ku, size_t ku_len,
+                                 u_char * Kul, size_t * kul_len);
+
+    NETSNMP_IMPORT
+    int             encode_keychange(const oid * hashtype,
+                                     u_int hashtype_len, u_char * oldkey,
+                                     size_t oldkey_len, u_char * newkey,
+                                     size_t newkey_len, u_char * kcstring,
+                                     size_t * kcstring_len);
+
+    NETSNMP_IMPORT
+    int             decode_keychange(const oid * hashtype,
+                                     u_int hashtype_len, u_char * oldkey,
+                                     size_t oldkey_len, u_char * kcstring,
+                                     size_t kcstring_len, u_char * newkey,
+                                     size_t * newkey_len);
+
+
+    /*
+     * All functions devolve to the following block if we can't do cryptography
+     */
+#define	_KEYTOOLS_NOT_AVAILABLE			\
+{						\
+	return SNMPERR_KT_NOT_AVAILABLE;	\
+}
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* _KEYTOOLS_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/large_fd_set.h quaggasnmpTrap//include/net-snmp/library/large_fd_set.h
--- quagga-0.99.18//include/net-snmp/library/large_fd_set.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/large_fd_set.h	2010-02-27 05:11:15.000000000 -0800
@@ -0,0 +1,150 @@
+/**
+ * @file  large_fd_set.h
+ *
+ * @brief Macro's and functions for manipulation of large file descriptor sets.
+ */
+
+
+#ifndef LARGE_FD_SET_H
+#define LARGE_FD_SET_H
+
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/types.h>
+
+#ifdef HAVE_SYS_SELECT_H
+#include <sys/select.h>
+#endif
+
+#if defined(HAVE_WINSOCK_H) && ! defined(_WINSOCKAPI_) && ! defined(_WINSOCK_H)
+#error <winsock.h> or <winsock2.h> must have been included before this file.
+#endif
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+
+/**
+ * Add socket fd to the set *fdset if not yet present.
+ * Enlarges the set if necessary.
+ */
+#define NETSNMP_LARGE_FD_SET(fd, fdset) \
+                    netsnmp_large_fd_setfd(fd, fdset)
+
+/**
+ * Remove socket fd from the set *fdset.
+ * Do nothing if fd is not present in *fdset.
+ * Do nothing if fd >= fdset->lfs_setsize.
+ */
+#define NETSNMP_LARGE_FD_CLR(fd, fdset) \
+                    netsnmp_large_fd_clr(fd, fdset)
+
+/**
+ * Test whether set *fdset contains socket fd.
+ * Do nothing if fd >= fdset->lfs_setsize.
+ */
+#define NETSNMP_LARGE_FD_ISSET(fd, fdset) \
+                    netsnmp_large_fd_is_set(fd, fdset)
+
+#if ! defined(cygwin) && defined(HAVE_WINSOCK_H)
+
+/** Number of bytes needed to store setsize file descriptors. */
+#define NETSNMP_FD_SET_BYTES(setsize) (sizeof(fd_set) + sizeof(SOCKET) * (setsize - FD_SETSIZE))
+
+/** Remove all sockets from the set *fdset. */
+#define NETSNMP_LARGE_FD_ZERO(fdset) \
+    do { (fdset)->lfs_setptr->fd_count = 0; } while(0)
+
+
+NETSNMP_IMPORT
+void   netsnmp_large_fd_setfd( SOCKET fd, netsnmp_large_fd_set *fdset);
+NETSNMP_IMPORT
+void   netsnmp_large_fd_clr(   SOCKET fd, netsnmp_large_fd_set *fdset);
+NETSNMP_IMPORT
+int    netsnmp_large_fd_is_set(SOCKET fd, netsnmp_large_fd_set *fdset);
+
+#else
+
+/**
+ * Size of a single element of the array with file descriptor bitmasks.
+ *
+ * According to SUSv2, this array must have the name fds_bits. See also
+ * <a href="http://www.opengroup.org/onlinepubs/007908775/xsh/systime.h.html">The Single UNIX Specification, Version 2, &lt;sys/time.h&gt;</a>.
+ */
+#define NETSNMP_FD_MASK_SIZE sizeof(((fd_set*)0)->fds_bits)
+
+/** Number of bits in one element of the fd_set::fds_bits array. */
+#define NETSNMP_BITS_PER_FD_MASK (8 * NETSNMP_FD_MASK_SIZE)
+
+/** Number of elements needed for the fds_bits array. */
+#define NETSNMP_FD_SET_ELEM_COUNT(setsize) \
+    (setsize + NETSNMP_BITS_PER_FD_MASK - 1) / NETSNMP_BITS_PER_FD_MASK
+
+/** Number of bytes needed to store setsize file descriptors. */
+#define NETSNMP_FD_SET_BYTES(setsize) \
+    (NETSNMP_FD_SET_ELEM_COUNT(setsize) * NETSNMP_FD_MASK_SIZE)
+
+/** Remove all file descriptors from the set *fdset. */
+#define NETSNMP_LARGE_FD_ZERO(fdset)                       \
+  do {                                                     \
+    int __i;                                               \
+    fd_set *__arr = &(fdset)->lfs_set;                     \
+    __i = NETSNMP_FD_SET_ELEM_COUNT((fdset)->lfs_setsize); \
+    for ( ; __i > 0; __i--)                                \
+      __arr->fds_bits[__i - 1] = 0;                        \
+  } while (0)
+
+
+void   netsnmp_large_fd_setfd( int fd, netsnmp_large_fd_set *fdset);
+void   netsnmp_large_fd_clr(   int fd, netsnmp_large_fd_set *fdset);
+int    netsnmp_large_fd_is_set(int fd, netsnmp_large_fd_set *fdset);
+
+#endif
+
+/**
+ * Initialize a netsnmp_large_fd_set structure.
+ *
+ * Note: this function only initializes the lfs_setsize and lfs_setptr
+ * members of netsnmp_large_fd_set, not the file descriptor set itself.
+ * The file descriptor set must be initialized separately, e.g. via
+ * NETSNMP_LARGE_FD_CLR().
+ */
+NETSNMP_IMPORT
+void   netsnmp_large_fd_set_init(   netsnmp_large_fd_set *fdset, int setsize);
+
+/**
+ * Modify the size of a file descriptor set and preserve the first
+ * min(fdset->lfs_setsize, setsize) file descriptors.
+ */
+void   netsnmp_large_fd_set_resize( netsnmp_large_fd_set *fdset, int setsize);
+
+/** Deallocate the memory allocated by netsnmp_large_fd_set_init. */
+NETSNMP_IMPORT
+void   netsnmp_large_fd_set_cleanup(netsnmp_large_fd_set *fdset);
+
+/**
+ * Copy an fd_set to a netsnmp_large_fd_set structure.
+ *
+ * @note dst must have been initialized before this function is called.
+ */
+void   netsnmp_copy_fd_set_to_large_fd_set(netsnmp_large_fd_set *dst,
+                                                   const fd_set *src);
+
+/**
+ * Copy a netsnmp_large_fd_set structure into an fd_set.
+ *
+ * @return 0 upon success, -1 when copying fails because *src is too large to
+ *         fit into *dst.
+ */
+int    netsnmp_copy_large_fd_set_to_fd_set(              fd_set *dst,
+                                     const netsnmp_large_fd_set *src);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* LARGE_FD_SET_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/lcd_time.h quaggasnmpTrap//include/net-snmp/library/lcd_time.h
--- quagga-0.99.18//include/net-snmp/library/lcd_time.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/lcd_time.h	2010-05-27 08:15:43.000000000 -0700
@@ -0,0 +1,137 @@
+/*
+ * lcd_time.h
+ */
+
+#ifndef _LCD_TIME_H
+#define _LCD_TIME_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+
+    /*
+     * undefine to enable time synchronization only on authenticated packets 
+     */
+#define LCD_TIME_SYNC_OPT 1
+
+    /*
+     * Macros and definitions.
+     */
+#define ETIMELIST_SIZE	23
+
+
+
+    typedef struct enginetime_struct {
+        u_char         *engineID;
+        u_int           engineID_len;
+
+        u_int           engineTime;
+        u_int           engineBoot;
+        /*
+         * Time & boots values received from last authenticated
+         * *   message within the previous time window.
+         */
+
+        time_t          lastReceivedEngineTime;
+        /*
+         * Timestamp made when engineTime/engineBoots was last
+         * *   updated.  Measured in seconds.
+         */
+
+#ifdef LCD_TIME_SYNC_OPT
+        u_int           authenticatedFlag;
+#endif
+        struct enginetime_struct *next;
+    } enginetime   , *Enginetime;
+
+
+
+
+    /*
+     * Macros for streamlined engineID existence checks --
+     *
+     *      e       is char *engineID,
+     *      e_l     is u_int engineID_len.
+     *
+     *
+     *  ISENGINEKNOWN(e, e_l)
+     *      Returns:
+     *              TRUE    If engineID is recoreded in the EngineID List;
+     *              FALSE   Otherwise.
+     *
+     *  ENSURE_ENGINE_RECORD(e, e_l)
+     *      Adds the given engineID to the EngineID List if it does not exist
+     *              already.  engineID is added with a <enginetime, engineboots>
+     *              tuple of <0,0>.  ALWAYS succeeds -- except in case of a
+     *              fatal internal error.
+     *      Returns:
+     *              SNMPERR_SUCCESS On success;
+     *              SNMPERR_GENERR  Otherwise.
+     *
+     *  MAKENEW_ENGINE_RECORD(e, e_l)
+     *      Returns:
+     *              SNMPERR_SUCCESS If engineID already exists in the EngineID List;
+     *              SNMPERR_GENERR  Otherwise -and- invokes ENSURE_ENGINE_RECORD()
+     *                                      to add an entry to the EngineID List.
+     *
+     * XXX  Requres the following declaration in modules calling ISENGINEKNOWN():
+     *      static u_int    dummy_etime, dummy_eboot;
+     */
+#define ISENGINEKNOWN(e, e_l)					\
+	( (get_enginetime(e, e_l,				\
+		&dummy_eboot, &dummy_etime, TRUE) == SNMPERR_SUCCESS)	\
+		? TRUE						\
+		: FALSE )
+
+#define ENSURE_ENGINE_RECORD(e, e_l)				\
+	( (set_enginetime(e, e_l, 0, 0, FALSE) == SNMPERR_SUCCESS)	\
+		? SNMPERR_SUCCESS				\
+		: SNMPERR_GENERR )
+
+#define MAKENEW_ENGINE_RECORD(e, e_l)				\
+	( (ISENGINEKNOWN(e, e_l) == TRUE)			\
+		? SNMPERR_SUCCESS				\
+		: (ENSURE_ENGINE_RECORD(e, e_l), SNMPERR_GENERR) )
+
+
+
+    /*
+     * Prototypes.
+     */
+    int             get_enginetime(const u_char * engineID, u_int engineID_len,
+                                   u_int * engine_boot,
+                                   u_int * engine_time,
+                                   u_int authenticated);
+
+    int             get_enginetime_ex(u_char * engineID,
+                                      u_int engineID_len,
+                                      u_int * engine_boot,
+                                      u_int * engine_time,
+                                      u_int * last_engine_time,
+                                      u_int authenticated);
+
+    int             set_enginetime(const u_char * engineID, u_int engineID_len,
+                                   u_int engine_boot, u_int engine_time,
+                                   u_int authenticated);
+
+         
+         
+         
+         
+         
+         
+        Enginetime
+        search_enginetime_list(const u_char * engineID, u_int engineID_len);
+
+    int             hash_engineID(const u_char * engineID, u_int engineID_len);
+
+    void            dump_etimelist_entry(Enginetime e, int count);
+    void            dump_etimelist(void);
+    void            free_etimelist(void);
+    void            free_enginetime(unsigned char *engineID, size_t engineID_len);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* _LCD_TIME_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/libsnmp.h quaggasnmpTrap//include/net-snmp/library/libsnmp.h
--- quagga-0.99.18//include/net-snmp/library/libsnmp.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/libsnmp.h	2010-01-24 03:41:03.000000000 -0800
@@ -0,0 +1,174 @@
+#ifndef _LIBSNMP_H_
+#define _LIBSNMP_H_
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    /*
+     * Definitions for the Simple Network Management Protocol (RFC 1067).
+     *
+     */
+/**********************************************************************
+ *
+ *           Copyright 1998 by Carnegie Mellon University
+ * 
+ *                       All Rights Reserved
+ * 
+ * Permission to use, copy, modify, and distribute this software and its
+ * documentation for any purpose and without fee is hereby granted,
+ * provided that the above copyright notice appear in all copies and that
+ * both that copyright notice and this permission notice appear in
+ * supporting documentation, and that the name of CMU not be
+ * used in advertising or publicity pertaining to distribution of the
+ * software without specific, written prior permission.
+ * 
+ * CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ * ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+ * CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ * WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ * ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ * 
+ * $Id: libsnmp.h 18044 2010-01-24 11:41:03Z bvassche $
+ * 
+ **********************************************************************/
+
+#include <ucd-snmp/ucd-snmp-config.h>
+
+#if HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#if HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#if HAVE_STRING_H
+#include <string.h>
+#else
+#include <strings.h>
+#endif
+#include <sys/types.h>
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+#if TIME_WITH_SYS_TIME
+# include <sys/time.h>
+# include <time.h>
+#else
+# if HAVE_SYS_TIME_H
+#  include <sys/time.h>
+# else
+#  include <time.h>
+# endif
+#endif
+#if HAVE_SYS_SELECT_H
+#include <sys/select.h>
+#endif
+#include <stdio.h>
+#include <ctype.h>
+#if HAVE_NETDB_H
+#include <netdb.h>
+#endif
+#if HAVE_ARPA_INET_H
+#include <arpa/inet.h>
+#endif
+
+#ifdef UCD_SNMP_LIBRARY
+
+#define snmp_parse cmu_snmp_parse
+
+#include <ucd-snmp/asn1.h>
+#include <ucd-snmp/snmp_api.h>
+#include <ucd-snmp/snmp_impl.h>
+#include <ucd-snmp/snmp_client.h>
+#include <ucd-snmp/mib.h>
+#include <ucd-snmp/parse.h>
+#include <ucd-snmp/snmp.h>
+#include <ucd-snmp/system.h>
+#include <ucd-snmp/int64.h>
+#include <ucd-snmp/version.h>
+
+#define Version version         /* netsnmp_session member */
+
+#define SMI_NOSUCHOBJECT      SNMP_NOSUCHOBJECT
+#define SMI_NOSUCHINSTANCE    SNMP_NOSUCHINSTANCE
+#define SMI_ENDOFMIBVIEW      SNMP_ENDOFMIBVIEW
+
+
+#else                           /* !UCD_SNMP_LIBRARY */
+
+#include <sys/types.h>
+#ifndef WIN32
+#include <netinet/in.h>
+#endif
+
+#include <snmp/asn1.h>
+#include <snmp/snmp_error.h>
+#include <snmp/mibii.h>
+#include <snmp/snmp_extra.h>
+#include <snmp/snmp_dump.h>
+
+#include <snmp/snmp_session.h>
+
+#include <snmp/snmp_vars.h>
+#include <snmp/snmp_pdu.h>
+#include <snmp/snmp_msg.h>
+
+#include <snmp/snmp_coexist.h>
+#include <snmp/version.h>
+#include <snmp/snmp_api_error.h>
+#include <snmp/mini-client.h>
+
+#include <snmp/snmp_impl.h>
+#include <snmp/snmp_api.h>
+#include <snmp/snmp_client.h>
+#include <snmp/snmp-internal.h>
+#include <snmp/mib.h>
+#include <snmp/parse.h>
+#include <snmp/snmp_compat.h>
+
+    /*
+     * Load UC-Davis differential 
+     */
+
+#define SNMP_MSG_GET GET_REQ_MSG
+#define SNMP_MSG_GETNEXT GETNEXT_REQ_MSG
+#define SNMP_MSG_RESPONSE GET_RSP_MSG
+#define SNMP_MSG_SET SET_REQ_MSG
+#define SNMP_MSG_TRAP TRP_REQ_MSG
+#define SNMP_MSG_GETBULK    (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x5)
+#define SNMP_MSG_INFORM     (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x6)
+#define SNMP_MSG_TRAP2      (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x7)
+#define SNMP_MSG_REPORT     (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x8)
+#define SNMP_NOSUCHOBJECT    SMI_NOSUCHOBJECT
+#define SNMP_NOSUCHINSTANCE  SMI_NOSUCHINSTANCE
+#define SNMP_ENDOFMIBVIEW    SMI_ENDOFMIBVIEW
+
+#define ASN_IPADDRESS   (ASN_APPLICATION | 0)
+#define ASN_UNSIGNED    (ASN_APPLICATION | 2)   /* RFC 1902 - same as GAUGE */
+#define ASN_TIMETICKS   (ASN_APPLICATION | 3)
+
+#define snmp_perror(X) perror(X)
+#define snmp_set_dump_packet(X)
+#define snmp_set_quick_print(X)
+#define snmp_set_do_debugging(X)
+#define snmp_set_full_objid(X)
+#define snmp_set_suffix_only(X)
+
+#define VersionInfo snmp_Version
+#define get_node read_objid
+#define version Version         /* netsnmp_session member */
+
+#define SNMP_VERSION_2c SNMP_VERSION_2
+#define SNMP_VERSION_2p 129
+
+#define SOCK_STARTUP winsock_startup()
+#define SOCK_CLEANUP winsock_cleanup()
+
+#endif                          /* !UCD_SNMP_LIBRARY */
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* _LIBSNMP_H_ */
diff -rupN quagga-0.99.18//include/net-snmp/library/md5.h quaggasnmpTrap//include/net-snmp/library/md5.h
--- quagga-0.99.18//include/net-snmp/library/md5.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/md5.h	2010-05-27 08:15:43.000000000 -0700
@@ -0,0 +1,71 @@
+/*
+ * ** **************************************************************************
+ * ** md5.h -- Header file for implementation of MD5 Message Digest Algorithm **
+ * ** Updated: 2/13/90 by Ronald L. Rivest                                    **
+ * ** (C) 1990 RSA Data Security, Inc.                                        **
+ * ** **************************************************************************
+ */
+
+#ifndef MD5_H
+#define MD5_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+
+    /*
+     * MDstruct is the data structure for a message digest computation.
+     */
+    typedef struct {
+        unsigned int    buffer[4];      /* Holds 4-word result of MD computation */
+        unsigned char   count[8];       /* Number of bits processed so far */
+        unsigned int    done;   /* Nonzero means MD computation finished */
+    } MDstruct     , *MDptr;
+
+    /*
+     * MDbegin(MD)
+     * ** Input: MD -- an MDptr
+     * ** Initialize the MDstruct prepatory to doing a message digest computation.
+     */
+    NETSNMP_IMPORT void MDbegin(MDptr);
+
+    /*
+     * MDupdate(MD,X,count)
+     * ** Input: MD -- an MDptr
+     * **        X -- a pointer to an array of unsigned characters.
+     * **        count -- the number of bits of X to use (an unsigned int).
+     * ** Updates MD using the first ``count'' bits of X.
+     * ** The array pointed to by X is not modified.
+     * ** If count is not a multiple of 8, MDupdate uses high bits of last byte.
+     * ** This is the basic input routine for a user.
+     * ** The routine terminates the MD computation when count < 512, so
+     * ** every MD computation should end with one call to MDupdate with a
+     * ** count less than 512.  Zero is OK for a count.
+     */
+    NETSNMP_IMPORT int MDupdate(MDptr, const unsigned char *, unsigned int);
+
+    /*
+     * MDprint(MD)
+     * ** Input: MD -- an MDptr
+     * ** Prints message digest buffer MD as 32 hexadecimal digits.
+     * ** Order is from low-order byte of buffer[0] to high-order byte of buffer[3].
+     * ** Each byte is printed with high-order hexadecimal digit first.
+     */
+    extern void     MDprint(MDptr);
+
+    int             MDchecksum(const u_char * data, size_t len, u_char * mac,
+                               size_t maclen);
+    int             MDsign(const u_char * data, size_t len, u_char * mac,
+                           size_t maclen, const u_char * secret,
+                           size_t secretlen);
+    void            MDget(MDstruct * MD, u_char * buf, size_t buflen);
+
+    /*
+     * ** End of md5.h
+     * ****************************(cut)****************************************
+     */
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* MD5_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/mib.h quaggasnmpTrap//include/net-snmp/library/mib.h
--- quagga-0.99.18//include/net-snmp/library/mib.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/mib.h	2010-03-20 13:21:03.000000000 -0700
@@ -0,0 +1,518 @@
+#ifndef MIB_H
+#define MIB_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+    /*
+     * mib.h - Definitions for the variables as defined in the MIB
+     *
+     * Update: 1998-07-17 <jhy@gsu.edu>
+     * Added prototypes for print_oid_report* functions.
+     */
+/***********************************************************
+	Copyright 1988, 1989 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of CMU not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+******************************************************************/
+
+#include <stdio.h>              /* for FILE */
+
+#include <net-snmp/mib_api.h>
+
+#define NETSNMP_MIB2_OID 1, 3, 6, 1, 2, 1
+
+#ifndef NETSNMP_NO_LEGACY_DEFINITIONS
+#define MIB NETSNMP_MIB2_OID
+#endif
+
+#define MIB_IFTYPE_OTHER		    1
+#define MIB_IFTYPE_REGULAR1822		    2
+#define MIB_IFTYPE_HDH1822		    3
+#define MIB_IFTYPE_DDNX25		    4
+#define MIB_IFTYPE_RFC877X25		    5
+#define MIB_IFTYPE_ETHERNETCSMACD	    6
+#define MIB_IFTYPE_ISO88023CSMACD	    7
+#define MIB_IFTYPE_ISO88024TOKENBUS	    8
+#define MIB_IFTYPE_ISO88025TOKENRING	    9
+#define MIB_IFTYPE_ISO88026MAN		    10
+#define MIB_IFTYPE_STARLAN		    11
+#define MIB_IFTYPE_PROTEON10MBIT	    12
+#define MIB_IFTYPE_PROTEON80MBIT	    13
+#define MIB_IFTYPE_HYPERCHANNEL		    14
+#define MIB_IFTYPE_FDDI			    15
+#define MIB_IFTYPE_LAPB			    16
+#define MIB_IFTYPE_SDLC			    17
+#define MIB_IFTYPE_T1CARRIER		    18
+#define MIB_IFTYPE_CEPT			    19
+#define MIB_IFTYPE_BASICISDN		    20
+#define MIB_IFTYPE_PRIMARYISDN		    21
+#define MIB_IFTYPE_PROPPOINTTOPOINTSERIAL   22
+
+#define MIB_IFSTATUS_UP		1
+#define MIB_IFSTATUS_DOWN	2
+#define MIB_IFSTATUS_TESTING	3
+
+#define MIB_FORWARD_GATEWAY	1
+#define MIB_FORWARD_HOST	2
+
+#define MIB_IPROUTETYPE_OTHER	1
+#define MIB_IPROUTETYPE_INVALID	2
+#define MIB_IPROUTETYPE_DIRECT	3
+#define MIB_IPROUTETYPE_REMOTE	4
+
+#define MIB_IPROUTEPROTO_OTHER	    1
+#define MIB_IPROUTEPROTO_LOCAL	    2
+#define MIB_IPROUTEPROTO_NETMGMT    3
+#define MIB_IPROUTEPROTO_ICMP	    4
+#define MIB_IPROUTEPROTO_EGP	    5
+#define MIB_IPROUTEPROTO_GGP	    6
+#define MIB_IPROUTEPROTO_HELLO	    7
+#define MIB_IPROUTEPROTO_RIP	    8
+#define MIB_IPROUTEPROTO_ISIS	    9
+#define MIB_IPROUTEPROTO_ESIS	    10
+#define MIB_IPROUTEPROTO_CISCOIGRP  11
+#define MIB_IPROUTEPROTO_BBNSPFIGP  12
+#define MIB_IPROUTEPROTO_OIGP	    13
+
+#define MIB_TCPRTOALG_OTHER	1
+#define MIB_TCPRTOALG_CONSTANT	2
+#define MIB_TCPRTOALG_RSRE	3
+#define MIB_TCPRTOALG_VANJ	4
+
+#define MIB_TCPCONNSTATE_CLOSED		1
+#define MIB_TCPCONNSTATE_LISTEN		2
+#define MIB_TCPCONNSTATE_SYNSENT	3
+#define MIB_TCPCONNSTATE_SYNRECEIVED	4
+#define MIB_TCPCONNSTATE_ESTABLISHED	5
+#define MIB_TCPCONNSTATE_FINWAIT1	6
+#define MIB_TCPCONNSTATE_FINWAIT2	7
+#define MIB_TCPCONNSTATE_CLOSEWAIT	8
+#define MIB_TCPCONNSTATE_LASTACK	9
+#define MIB_TCPCONNSTATE_CLOSING	10
+#define MIB_TCPCONNSTATE_TIMEWAIT	11
+
+#define MIB_EGPNEIGHSTATE_IDLE		1
+#define MIB_EGPNEIGHSTATE_AQUISITION	2
+#define MIB_EGPNEIGHSTATE_DOWN		3
+#define MIB_EGPNEIGHSTATE_UP		4
+#define MIB_EGPNEIGHSTATE_CEASE		5
+
+    struct variable_list;
+    struct enum_list;
+
+    NETSNMP_IMPORT
+    void            print_ascii_dump(FILE *);
+    void            register_mib_handlers(void);
+    void            netsnmp_set_mib_directory(const char *dir);
+    NETSNMP_IMPORT
+    char            *netsnmp_get_mib_directory(void);
+    void            netsnmp_fixup_mib_directory(void);
+    void            netsnmp_mibindex_load( void );
+    char *          netsnmp_mibindex_lookup( const char * );
+    FILE *          netsnmp_mibindex_new( const char * );
+    int             sprint_realloc_description(u_char ** buf, size_t * buf_len,
+                                size_t * out_len, int allow_realloc,
+                                oid * objid, size_t objidlen, int width);
+    NETSNMP_IMPORT
+    int             get_wild_node(const char *, oid *, size_t *);
+    NETSNMP_IMPORT
+    int             get_node(const char *, oid *, size_t *);
+    NETSNMP_IMPORT
+    struct tree    *get_tree(const oid *, size_t, struct tree *);
+    NETSNMP_IMPORT
+    struct tree    *get_tree_head(void);
+    void            set_function(struct tree *);
+
+    NETSNMP_IMPORT
+    int             parse_one_oid_index(oid ** oidStart, size_t * oidLen,
+                                        netsnmp_variable_list * data,
+                                        int complete);
+    NETSNMP_IMPORT
+    int             parse_oid_indexes(oid * oidIndex, size_t oidLen,
+                                      netsnmp_variable_list * data);
+    NETSNMP_IMPORT
+    int             build_oid_noalloc(oid * in, size_t in_len,
+                                      size_t * out_len, oid * prefix,
+                                      size_t prefix_len,
+                                      netsnmp_variable_list * indexes);
+    NETSNMP_IMPORT
+    int             build_oid(oid ** out, size_t * out_len, oid * prefix,
+                              size_t prefix_len,
+                              netsnmp_variable_list * indexes);
+    int             build_oid_segment(netsnmp_variable_list * var);
+
+    NETSNMP_IMPORT
+    int             sprint_realloc_variable(u_char ** buf, size_t * buf_len,
+                                   size_t * out_len, int allow_realloc,
+                                   const oid * objid, size_t objidlen,
+                                   const netsnmp_variable_list * variable);
+
+    NETSNMP_IMPORT
+#ifndef NETSNMP_DISABLE_MIB_LOADING
+    struct tree    *
+#else
+    void
+#endif
+                    netsnmp_sprint_realloc_objid_tree(u_char ** buf,
+                                                      size_t * buf_len,
+                                                      size_t * out_len,
+                                                      int allow_realloc,
+                                                      int *buf_overflow,
+                                                      const oid * objid,
+                                                      size_t objidlen);
+
+    NETSNMP_IMPORT
+    void
+                    netsnmp_sprint_realloc_objid(u_char ** buf,
+                                                 size_t * buf_len,
+                                                 size_t * out_len,
+                                                 int allow_realloc,
+                                                 int *buf_overflow,
+                                                 const oid * objid,
+                                                 size_t objidlen);
+
+    NETSNMP_IMPORT
+    int             sprint_realloc_value(u_char ** buf, size_t * buf_len,
+                                 size_t * out_len, int allow_realloc,
+                                 const oid * objid, size_t objidlen,
+                                 const netsnmp_variable_list * variable);
+
+    NETSNMP_IMPORT
+    int             sprint_realloc_objid(u_char ** buf, size_t * buf_len,
+                                 size_t * out_len, int allow_realloc,
+                                 const oid * objid, size_t objidlen);
+
+    NETSNMP_IMPORT
+    int             sprint_realloc_by_type(u_char ** buf, size_t * buf_len,
+                                           size_t * out_len,
+                                           int allow_realloc,
+                                           const netsnmp_variable_list * var,
+                                           const struct enum_list *enums,
+                                           const char *hint,
+                                           const char *units);
+
+    NETSNMP_IMPORT
+    int             sprint_realloc_hexstring(u_char ** buf,
+                                             size_t * buf_len,
+                                             size_t * out_len,
+                                             int allow_realloc,
+                                             const u_char *, size_t);
+
+    NETSNMP_IMPORT
+    int             sprint_realloc_asciistring(u_char ** buf,
+                                               size_t * buf_len,
+                                               size_t * out_len,
+                                               int allow_realloc,
+                                               const u_char * cp,
+                                               size_t len);
+
+    int             sprint_realloc_octet_string(u_char ** buf,
+                                                size_t * buf_len,
+                                                size_t * out_len,
+                                                int allow_realloc,
+                                                const netsnmp_variable_list *,
+                                                const struct enum_list *,
+                                                const char *,
+                                                const char *);
+
+    int             sprint_realloc_opaque(u_char ** buf, size_t * buf_len,
+                                          size_t * out_len,
+                                          int allow_realloc,
+                                          const netsnmp_variable_list *,
+                                          const struct enum_list *, const char *,
+                                          const char *);
+
+    int             sprint_realloc_object_identifier(u_char ** buf,
+                                                     size_t * buf_len,
+                                                     size_t * out_len,
+                                                     int allow_realloc,
+                                                     const netsnmp_variable_list
+                                                     *, const struct enum_list *,
+                                                     const char *,
+                                                     const char *);
+
+    int             sprint_realloc_timeticks(u_char ** buf,
+                                             size_t * buf_len,
+                                             size_t * out_len,
+                                             int allow_realloc,
+                                             const netsnmp_variable_list *,
+                                             const struct enum_list *,
+                                             const char *, const char *);
+
+    int             sprint_realloc_hinted_integer(u_char ** buf,
+                                                  size_t * buf_len,
+                                                  size_t * out_len,
+                                                  int allow_realloc, long,
+                                                  const char, const char *,
+                                                  const char *);
+
+    int             sprint_realloc_integer(u_char ** buf, size_t * buf_len,
+                                           size_t * out_len,
+                                           int allow_realloc,
+                                           const netsnmp_variable_list *,
+                                           const struct enum_list *,
+                                           const char *, const char *);
+
+    int             sprint_realloc_uinteger(u_char ** buf,
+                                            size_t * buf_len,
+                                            size_t * out_len,
+                                            int allow_realloc,
+                                            const netsnmp_variable_list *,
+                                            const struct enum_list *,
+                                            const char *, const char *);
+
+    int             sprint_realloc_gauge(u_char ** buf, size_t * buf_len,
+                                         size_t * out_len,
+                                         int allow_realloc,
+                                         const netsnmp_variable_list *,
+                                         const struct enum_list *, const char *,
+                                         const char *);
+
+    int             sprint_realloc_counter(u_char ** buf, size_t * buf_len,
+                                           size_t * out_len,
+                                           int allow_realloc,
+                                           const netsnmp_variable_list *,
+                                           const struct enum_list *,
+                                           const char *, const char *);
+
+    int             sprint_realloc_networkaddress(u_char ** buf,
+                                                  size_t * buf_len,
+                                                  size_t * out_len,
+                                                  int allow_realloc,
+                                                  const netsnmp_variable_list *,
+                                                  const struct enum_list *,
+                                                  const char *,
+                                                  const char *);
+
+    int             sprint_realloc_ipaddress(u_char ** buf,
+                                             size_t * buf_len,
+                                             size_t * out_len,
+                                             int allow_realloc,
+                                             const netsnmp_variable_list *,
+                                             const struct enum_list *,
+                                             const char *, const char *);
+
+    int             sprint_realloc_null(u_char ** buf, size_t * buf_len,
+                                        size_t * out_len,
+                                        int allow_realloc,
+                                        const netsnmp_variable_list *,
+                                        const struct enum_list *, const char *,
+                                        const char *);
+
+    int             sprint_realloc_bitstring(u_char ** buf,
+                                             size_t * buf_len,
+                                             size_t * out_len,
+                                             int allow_realloc,
+                                             const netsnmp_variable_list *,
+                                             const struct enum_list *,
+                                             const char *, const char *);
+
+    int             sprint_realloc_nsapaddress(u_char ** buf,
+                                               size_t * buf_len,
+                                               size_t * out_len,
+                                               int allow_realloc,
+                                               const netsnmp_variable_list *,
+                                               const struct enum_list *,
+                                               const char *, const char *);
+
+    int             sprint_realloc_counter64(u_char ** buf,
+                                             size_t * buf_len,
+                                             size_t * out_len,
+                                             int allow_realloc,
+                                             const netsnmp_variable_list *,
+                                             const struct enum_list *,
+                                             const char *, const char *);
+
+    int             sprint_realloc_badtype(u_char ** buf, size_t * buf_len,
+                                           size_t * out_len,
+                                           int allow_realloc,
+                                           const netsnmp_variable_list *,
+                                           const struct enum_list *,
+                                           const char *, const char *);
+
+#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES
+    int             sprint_realloc_float(u_char ** buf, size_t * buf_len,
+                                         size_t * out_len,
+                                         int allow_realloc,
+                                         const netsnmp_variable_list *,
+                                         const struct enum_list *, const char *,
+                                         const char *);
+
+    int             sprint_realloc_double(u_char ** buf, size_t * buf_len,
+                                          size_t * out_len,
+                                          int allow_realloc,
+                                          const netsnmp_variable_list *,
+                                          const struct enum_list *, const char *,
+                                          const char *);
+#endif
+
+
+    int             snprint_by_type(char *buf, size_t buf_len,
+                                    netsnmp_variable_list * var,
+                                    const struct enum_list *enums,
+                                    const char *hint, const char *units);
+
+    int             snprint_hexstring(char *buf, size_t buf_len,
+                                      const u_char *, size_t);
+
+    int             snprint_asciistring(char *buf, size_t buf_len,
+                                        const u_char * cp, size_t len);
+
+    int             snprint_octet_string(char *buf, size_t buf_len,
+                                         const netsnmp_variable_list *,
+                                         const struct enum_list *, const char *,
+                                         const char *);
+
+    int             snprint_opaque(char *buf, size_t buf_len,
+                                   const netsnmp_variable_list *,
+                                   const struct enum_list *, const char *,
+                                   const char *);
+
+    int             snprint_object_identifier(char *buf, size_t buf_len,
+                                              const netsnmp_variable_list *,
+                                              const struct enum_list *,
+                                              const char *, const char *);
+
+    int             snprint_timeticks(char *buf, size_t buf_len,
+                                      const netsnmp_variable_list *,
+                                      const struct enum_list *, const char *,
+                                      const char *);
+
+    int             snprint_hinted_integer(char *buf, size_t buf_len,
+                                           long, const char *,
+                                           const char *);
+
+    int             snprint_integer(char *buf, size_t buf_len,
+                                    const netsnmp_variable_list *,
+                                    const struct enum_list *, const char *,
+                                    const char *);
+
+    int             snprint_uinteger(char *buf, size_t buf_len,
+                                     const netsnmp_variable_list *,
+                                     const struct enum_list *, const char *,
+                                     const char *);
+
+    int             snprint_gauge(char *buf, size_t buf_len,
+                                  const netsnmp_variable_list *,
+                                  const struct enum_list *, const char *,
+                                  const char *);
+
+    int             snprint_counter(char *buf, size_t buf_len,
+                                    const netsnmp_variable_list *,
+                                    const struct enum_list *, const char *,
+                                    const char *);
+
+    int             snprint_networkaddress(char *buf, size_t buf_len,
+                                           const netsnmp_variable_list *,
+                                           const struct enum_list *,
+                                           const char *, const char *);
+
+    int             snprint_ipaddress(char *buf, size_t buf_len,
+                                      const netsnmp_variable_list *,
+                                      const struct enum_list *, const char *,
+                                      const char *);
+
+    int             snprint_null(char *buf, size_t buf_len,
+                                 const netsnmp_variable_list *,
+                                 const struct enum_list *, const char *,
+                                 const char *);
+
+    NETSNMP_IMPORT
+    int             snprint_bitstring(char *buf, size_t buf_len,
+                                      const netsnmp_variable_list *,
+                                      const struct enum_list *, const char *,
+                                      const char *);
+
+    int             snprint_nsapaddress(char *buf, size_t buf_len,
+                                        const netsnmp_variable_list *,
+                                        const struct enum_list *, const char *,
+                                        const char *);
+
+    int             snprint_counter64(char *buf, size_t buf_len,
+                                      const netsnmp_variable_list *,
+                                      const struct enum_list *, const char *,
+                                      const char *);
+
+    int             snprint_badtype(char *buf, size_t buf_len,
+                                    const netsnmp_variable_list *,
+                                    const struct enum_list *, const char *,
+                                    const char *);
+
+#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES
+    int             snprint_float(char *buf, size_t buf_len,
+                                  const netsnmp_variable_list *,
+                                  const struct enum_list *, const char *,
+                                  const char *);
+
+    int             snprint_double(char *buf, size_t buf_len,
+                                   const netsnmp_variable_list *,
+                                   const struct enum_list *, const char *,
+                                   const char *);
+#endif
+
+    NETSNMP_IMPORT
+    void            print_oid_report(FILE *);
+    NETSNMP_IMPORT
+    void            print_oid_report_enable_labeledoid(void);
+    NETSNMP_IMPORT
+    void            print_oid_report_enable_oid(void);
+    NETSNMP_IMPORT
+    void            print_oid_report_enable_suffix(void);
+    NETSNMP_IMPORT
+    void            print_oid_report_enable_symbolic(void);
+    NETSNMP_IMPORT
+    void            print_oid_report_enable_mibchildoid(void);
+
+    const char     *parse_octet_hint(const char *hint, const char *value,
+	                             unsigned char **new_val, int *new_val_len);
+
+    NETSNMP_IMPORT
+    void            clear_tree_flags(register struct tree *tp);
+
+    NETSNMP_IMPORT
+    char           *snmp_out_toggle_options(char *);
+    NETSNMP_IMPORT
+    void            snmp_out_toggle_options_usage(const char *, FILE *);
+    NETSNMP_IMPORT
+    char           *snmp_in_toggle_options(char *);
+    char           *snmp_in_options(char *, int, char * const *);
+    NETSNMP_IMPORT
+    void            snmp_in_toggle_options_usage(const char *, FILE *);
+    NETSNMP_IMPORT
+    u_char          mib_to_asn_type(int mib_type);
+
+
+    int             netsnmp_str2oid(const char *S, oid * O, int L);
+
+
+#define NETSNMP_STRING_OUTPUT_GUESS  1
+#define NETSNMP_STRING_OUTPUT_ASCII  2
+#define NETSNMP_STRING_OUTPUT_HEX    3
+
+#define NETSNMP_OID_OUTPUT_SUFFIX  1
+#define NETSNMP_OID_OUTPUT_MODULE  2
+#define NETSNMP_OID_OUTPUT_FULL    3
+#define NETSNMP_OID_OUTPUT_NUMERIC 4
+#define NETSNMP_OID_OUTPUT_UCD     5
+#define NETSNMP_OID_OUTPUT_NONE    6
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* MIB_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/mt_support.h quaggasnmpTrap//include/net-snmp/library/mt_support.h
--- quagga-0.99.18//include/net-snmp/library/mt_support.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/mt_support.h	2010-02-27 05:11:15.000000000 -0800
@@ -0,0 +1,89 @@
+/*
+ * mt_support.h - multi-thread resource locking support declarations 
+ */
+/*
+ * Author: Markku Laukkanen
+ * Created: 6-Sep-1999
+ * History:
+ *  8-Sep-1999 M. Slifcak method names changed;
+ *                        use array of resource locking structures.
+ */
+
+#ifndef MT_SUPPORT_H
+#define MT_SUPPORT_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+  
+/*
+ * Lock group identifiers 
+ */
+
+#define MT_LIBRARY_ID      0
+#define MT_APPLICATION_ID  1
+#define MT_TOKEN_ID        2
+
+#define MT_MAX_IDS         3    /* one greater than last from above */
+#define MT_MAX_SUBIDS      10
+
+
+/*
+ * Lock resource identifiers for library resources 
+ */
+
+#define MT_LIB_NONE        0
+#define MT_LIB_SESSION     1
+#define MT_LIB_REQUESTID   2
+#define MT_LIB_MESSAGEID   3
+#define MT_LIB_SESSIONID   4
+#define MT_LIB_TRANSID     5
+
+#define MT_LIB_MAXIMUM     6    /* must be one greater than the last one */
+
+
+#if defined(NETSNMP_REENTRANT) || defined(WIN32)
+
+#if HAVE_PTHREAD_H
+#include <pthread.h>
+typedef pthread_mutex_t mutex_type;
+#ifdef pthread_mutexattr_default
+#define MT_MUTEX_INIT_DEFAULT pthread_mutexattr_default
+#else
+#define MT_MUTEX_INIT_DEFAULT 0
+#endif
+
+#elif defined(WIN32) || defined(cygwin)
+
+#include <windows.h>
+typedef CRITICAL_SECTION mutex_type;
+
+#else  /*  HAVE_PTHREAD_H  */
+error "There is no re-entrant support as defined."
+#endif /*  HAVE_PTHREAD_H  */
+
+
+NETSNMP_IMPORT
+int             snmp_res_init(void);
+NETSNMP_IMPORT
+int             snmp_res_lock(int groupID, int resourceID);
+NETSNMP_IMPORT
+int             snmp_res_unlock(int groupID, int resourceID);
+NETSNMP_IMPORT
+int             snmp_res_destroy_mutex(int groupID, int resourceID);
+
+#else /*  NETSNMP_REENTRANT  */
+
+#ifndef WIN32
+#define snmp_res_init() do {} while (0)
+#define snmp_res_lock(x,y) do {} while (0)
+#define snmp_res_unlock(x,y) do {} while (0)
+#define snmp_res_destroy_mutex(x,y) do {} while (0)
+#endif /*  WIN32  */
+
+#endif /*  NETSNMP_REENTRANT  */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /*  MT_SUPPORT_H  */
diff -rupN quagga-0.99.18//include/net-snmp/library/oid.h quaggasnmpTrap//include/net-snmp/library/oid.h
--- quagga-0.99.18//include/net-snmp/library/oid.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/oid.h	2009-10-30 02:51:01.000000000 -0700
@@ -0,0 +1,18 @@
+#ifndef NETSNMP_LIBRARY_OID_H
+#define NETSNMP_LIBRARY_OID_H
+
+#ifdef HAVE_INTTYPES_H
+#include <inttypes.h>
+#endif
+
+#ifndef EIGHTBIT_SUBIDS
+typedef uint32_t oid;
+#define MAX_SUBID   0xFFFFFFFF
+#define NETSNMP_PRIo NETSNMP_PRI32
+#else
+typedef uint8_t oid;
+#define MAX_SUBID   0xFF
+#define NETSNMP_PRIo ""
+#endif
+
+#endif /* NETSNMP_LIBRARY_OID_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/oid_stash.h quaggasnmpTrap//include/net-snmp/library/oid_stash.h
--- quagga-0.99.18//include/net-snmp/library/oid_stash.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/oid_stash.h	2010-02-27 05:11:15.000000000 -0800
@@ -0,0 +1,82 @@
+#ifndef OID_STASH_H
+#define OID_STASH_H
+
+/*
+ * designed to store/retrieve information associated with a given oid.
+ * Storage is done in an efficient tree manner for fast lookups.
+ */
+
+#define OID_STASH_CHILDREN_SIZE 31
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    struct netsnmp_oid_stash_node_s;
+
+    /* args: buffer, sizeof(buffer), yourdata, stashnode */
+    typedef int     (NetSNMPStashDump) (char *, size_t,
+                                        void *,
+                                        struct netsnmp_oid_stash_node_s *);
+
+    typedef void    (NetSNMPStashFreeNode) (void *);
+    
+    typedef struct netsnmp_oid_stash_node_s {
+        oid             value;
+        struct netsnmp_oid_stash_node_s **children;     /* array of children */
+        size_t          children_size;
+        struct netsnmp_oid_stash_node_s *next_sibling;  /* cache too small links */
+        struct netsnmp_oid_stash_node_s *prev_sibling;
+        struct netsnmp_oid_stash_node_s *parent; 
+
+        void           *thedata;
+    } netsnmp_oid_stash_node;
+
+    typedef struct netsnmp_oid_stash_save_info_s {
+       const char *token;
+       netsnmp_oid_stash_node **root;
+       NetSNMPStashDump *dumpfn;
+    } netsnmp_oid_stash_save_info;
+
+    NETSNMP_IMPORT
+    int             netsnmp_oid_stash_add_data(netsnmp_oid_stash_node **root,
+					       const oid * lookup,
+                                               size_t lookup_len,
+                                               void *mydata);
+    SNMPCallback netsnmp_oid_stash_store_all;
+
+
+    netsnmp_oid_stash_node
+        *netsnmp_oid_stash_get_node(netsnmp_oid_stash_node *root,
+                                    const oid * lookup, size_t lookup_len);
+    NETSNMP_IMPORT
+    void           *netsnmp_oid_stash_get_data(netsnmp_oid_stash_node *root,
+					       const oid * lookup,
+                                               size_t lookup_len);
+    NETSNMP_IMPORT
+    netsnmp_oid_stash_node *
+    netsnmp_oid_stash_getnext_node(netsnmp_oid_stash_node *root,
+                                   oid * lookup, size_t lookup_len);
+
+    netsnmp_oid_stash_node *netsnmp_oid_stash_create_sized_node(size_t
+                                                                mysize);
+    netsnmp_oid_stash_node *netsnmp_oid_stash_create_node(void);        /* returns a malloced node */
+
+    void netsnmp_oid_stash_store(netsnmp_oid_stash_node *root,
+                                 const char *tokenname,
+                                 NetSNMPStashDump *dumpfn,
+                                 oid *curoid, size_t curoid_len);
+
+    /* frees all data in the stash and cleans it out.  Sets root = NULL */
+    NETSNMP_IMPORT
+    void netsnmp_oid_stash_free(netsnmp_oid_stash_node **root,
+                                NetSNMPStashFreeNode *freefn);
+                                
+
+    /* a noop function that can be passed to netsnmp_oid_stash_node to
+       NOT free the data */
+    NetSNMPStashFreeNode netsnmp_oid_stash_no_free;
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* OID_STASH_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/openssl_aes.h quaggasnmpTrap//include/net-snmp/library/openssl_aes.h
--- quagga-0.99.18//include/net-snmp/library/openssl_aes.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/openssl_aes.h	2010-05-26 21:15:53.000000000 -0700
@@ -0,0 +1,140 @@
+/* crypto/aes/aes.h -*- mode:C; c-file-style: "eay" -*- */
+/* ====================================================================
+ * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer. 
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ */
+
+#ifndef HEADER_AES_H
+#define HEADER_AES_H
+
+#ifdef OPENSSL_NO_AES
+#error AES is disabled.
+#endif
+
+#include <stddef.h>
+
+#define AES_ENCRYPT	1
+#define AES_DECRYPT	0
+
+/* Because array size can't be a const in C, the following two are macros.
+   Both sizes are in bytes. */
+#define AES_MAXNR 14
+#define AES_BLOCK_SIZE 16
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+/* This should be a hidden type, but EVP requires that the size be known */
+struct aes_key_st {
+#ifdef AES_LONG
+    unsigned long rd_key[4 *(AES_MAXNR + 1)];
+#else
+    unsigned int rd_key[4 *(AES_MAXNR + 1)];
+#endif
+    int rounds;
+};
+typedef struct aes_key_st AES_KEY;
+
+const char *AES_options(void);
+
+int AES_set_encrypt_key(const unsigned char *userKey, const int bits,
+	AES_KEY *key);
+int AES_set_decrypt_key(const unsigned char *userKey, const int bits,
+	AES_KEY *key);
+
+void AES_encrypt(const unsigned char *in, unsigned char *out,
+	const AES_KEY *key);
+void AES_decrypt(const unsigned char *in, unsigned char *out,
+	const AES_KEY *key);
+
+void AES_ecb_encrypt(const unsigned char *in, unsigned char *out,
+	const AES_KEY *key, const int enc);
+void AES_cbc_encrypt(const unsigned char *in, unsigned char *out,
+	size_t length, const AES_KEY *key,
+	unsigned char *ivec, const int enc);
+void AES_cfb128_encrypt(const unsigned char *in, unsigned char *out,
+	size_t length, const AES_KEY *key,
+	unsigned char *ivec, int *num, const int enc);
+void AES_cfb1_encrypt(const unsigned char *in, unsigned char *out,
+	size_t length, const AES_KEY *key,
+	unsigned char *ivec, int *num, const int enc);
+void AES_cfb8_encrypt(const unsigned char *in, unsigned char *out,
+	size_t length, const AES_KEY *key,
+	unsigned char *ivec, int *num, const int enc);
+void AES_ofb128_encrypt(const unsigned char *in, unsigned char *out,
+	size_t length, const AES_KEY *key,
+	unsigned char *ivec, int *num);
+void AES_ctr128_encrypt(const unsigned char *in, unsigned char *out,
+	size_t length, const AES_KEY *key,
+	unsigned char ivec[AES_BLOCK_SIZE],
+	unsigned char ecount_buf[AES_BLOCK_SIZE],
+	unsigned int *num);
+/* NB: the IV is _two_ blocks long */
+void AES_ige_encrypt(const unsigned char *in, unsigned char *out,
+		     size_t length, const AES_KEY *key,
+		     unsigned char *ivec, const int enc);
+/* NB: the IV is _four_ blocks long */
+void AES_bi_ige_encrypt(const unsigned char *in, unsigned char *out,
+			size_t length, const AES_KEY *key,
+			const AES_KEY *key2, const unsigned char *ivec,
+			const int enc);
+
+int AES_wrap_key(AES_KEY *key, const unsigned char *iv,
+		unsigned char *out,
+		const unsigned char *in, unsigned int inlen);
+int AES_unwrap_key(AES_KEY *key, const unsigned char *iv,
+		unsigned char *out,
+		const unsigned char *in, unsigned int inlen);
+
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif /* !HEADER_AES_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/openssl_des.h quaggasnmpTrap//include/net-snmp/library/openssl_des.h
--- quagga-0.99.18//include/net-snmp/library/openssl_des.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/openssl_des.h	2010-05-26 21:15:53.000000000 -0700
@@ -0,0 +1,236 @@
+/* crypto/des/des.h */
+/* Copyright (C) 1995-1997 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+/* Copied roughly from opensslconf.h which it's a little more complex */
+#define DES_LONG unsigned long
+
+#ifndef HEADER_NEW_DES_H
+#define HEADER_NEW_DES_H
+
+#ifdef OPENSSL_NO_DES
+#error DES is disabled.
+#endif
+
+#ifdef OPENSSL_BUILD_SHLIBCRYPTO
+# undef OPENSSL_EXTERN
+# define OPENSSL_EXTERN OPENSSL_EXPORT
+#endif
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+typedef unsigned char DES_cblock[8];
+typedef /* const */ unsigned char const_DES_cblock[8];
+/* With "const", gcc 2.8.1 on Solaris thinks that DES_cblock *
+ * and const_DES_cblock * are incompatible pointer types. */
+
+typedef struct DES_ks
+    {
+    union
+	{
+	DES_cblock cblock;
+	/* make sure things are correct size on machines with
+	 * 8 byte longs */
+	DES_LONG deslong[2];
+	} ks[16];
+    } DES_key_schedule;
+
+#ifndef OPENSSL_DISABLE_OLD_DES_SUPPORT
+# ifndef OPENSSL_ENABLE_OLD_DES_SUPPORT
+#  define OPENSSL_ENABLE_OLD_DES_SUPPORT
+# endif
+#endif
+
+#define DES_KEY_SZ 	(sizeof(DES_cblock))
+#define DES_SCHEDULE_SZ (sizeof(DES_key_schedule))
+
+#define DES_ENCRYPT	1
+#define DES_DECRYPT	0
+
+#define DES_CBC_MODE	0
+#define DES_PCBC_MODE	1
+
+#define DES_ecb2_encrypt(i,o,k1,k2,e) \
+	DES_ecb3_encrypt((i),(o),(k1),(k2),(k1),(e))
+
+#define DES_ede2_cbc_encrypt(i,o,l,k1,k2,iv,e) \
+	DES_ede3_cbc_encrypt((i),(o),(l),(k1),(k2),(k1),(iv),(e))
+
+#define DES_ede2_cfb64_encrypt(i,o,l,k1,k2,iv,n,e) \
+	DES_ede3_cfb64_encrypt((i),(o),(l),(k1),(k2),(k1),(iv),(n),(e))
+
+#define DES_ede2_ofb64_encrypt(i,o,l,k1,k2,iv,n) \
+	DES_ede3_ofb64_encrypt((i),(o),(l),(k1),(k2),(k1),(iv),(n))
+
+const char *DES_options(void);
+void DES_ecb3_encrypt(const_DES_cblock *input, DES_cblock *output,
+		      DES_key_schedule *ks1,DES_key_schedule *ks2,
+		      DES_key_schedule *ks3, int enc);
+DES_LONG DES_cbc_cksum(const unsigned char *input,DES_cblock *output,
+		       long length,DES_key_schedule *schedule,
+		       const_DES_cblock *ivec);
+/* DES_cbc_encrypt does not update the IV!  Use DES_ncbc_encrypt instead. */
+void DES_cbc_encrypt(const unsigned char *input,unsigned char *output,
+		     long length,DES_key_schedule *schedule,DES_cblock *ivec,
+		     int enc);
+void DES_ncbc_encrypt(const unsigned char *input,unsigned char *output,
+		      long length,DES_key_schedule *schedule,DES_cblock *ivec,
+		      int enc);
+void DES_xcbc_encrypt(const unsigned char *input,unsigned char *output,
+		      long length,DES_key_schedule *schedule,DES_cblock *ivec,
+		      const_DES_cblock *inw,const_DES_cblock *outw,int enc);
+void DES_cfb_encrypt(const unsigned char *in,unsigned char *out,int numbits,
+		     long length,DES_key_schedule *schedule,DES_cblock *ivec,
+		     int enc);
+void DES_ecb_encrypt(const_DES_cblock *input,DES_cblock *output,
+		     DES_key_schedule *ks,int enc);
+
+/* 	This is the DES encryption function that gets called by just about
+	every other DES routine in the library.  You should not use this
+	function except to implement 'modes' of DES.  I say this because the
+	functions that call this routine do the conversion from 'char *' to
+	long, and this needs to be done to make sure 'non-aligned' memory
+	access do not occur.  The characters are loaded 'little endian'.
+	Data is a pointer to 2 unsigned long's and ks is the
+	DES_key_schedule to use.  enc, is non zero specifies encryption,
+	zero if decryption. */
+void DES_encrypt1(DES_LONG *data,DES_key_schedule *ks, int enc);
+
+/* 	This functions is the same as DES_encrypt1() except that the DES
+	initial permutation (IP) and final permutation (FP) have been left
+	out.  As for DES_encrypt1(), you should not use this function.
+	It is used by the routines in the library that implement triple DES.
+	IP() DES_encrypt2() DES_encrypt2() DES_encrypt2() FP() is the same
+	as DES_encrypt1() DES_encrypt1() DES_encrypt1() except faster :-). */
+void DES_encrypt2(DES_LONG *data,DES_key_schedule *ks, int enc);
+
+void DES_encrypt3(DES_LONG *data, DES_key_schedule *ks1,
+		  DES_key_schedule *ks2, DES_key_schedule *ks3);
+void DES_decrypt3(DES_LONG *data, DES_key_schedule *ks1,
+		  DES_key_schedule *ks2, DES_key_schedule *ks3);
+void DES_ede3_cbc_encrypt(const unsigned char *input,unsigned char *output, 
+			  long length,
+			  DES_key_schedule *ks1,DES_key_schedule *ks2,
+			  DES_key_schedule *ks3,DES_cblock *ivec,int enc);
+void DES_ede3_cbcm_encrypt(const unsigned char *in,unsigned char *out,
+			   long length,
+			   DES_key_schedule *ks1,DES_key_schedule *ks2,
+			   DES_key_schedule *ks3,
+			   DES_cblock *ivec1,DES_cblock *ivec2,
+			   int enc);
+void DES_ede3_cfb64_encrypt(const unsigned char *in,unsigned char *out,
+			    long length,DES_key_schedule *ks1,
+			    DES_key_schedule *ks2,DES_key_schedule *ks3,
+			    DES_cblock *ivec,int *num,int enc);
+void DES_ede3_cfb_encrypt(const unsigned char *in,unsigned char *out,
+			  int numbits,long length,DES_key_schedule *ks1,
+			  DES_key_schedule *ks2,DES_key_schedule *ks3,
+			  DES_cblock *ivec,int enc);
+void DES_ede3_ofb64_encrypt(const unsigned char *in,unsigned char *out,
+			    long length,DES_key_schedule *ks1,
+			    DES_key_schedule *ks2,DES_key_schedule *ks3,
+			    DES_cblock *ivec,int *num);
+#if 0
+void DES_xwhite_in2out(const_DES_cblock *DES_key,const_DES_cblock *in_white,
+		       DES_cblock *out_white);
+#endif
+
+int DES_enc_read(int fd,void *buf,int len,DES_key_schedule *sched,
+		 DES_cblock *iv);
+int DES_enc_write(int fd,const void *buf,int len,DES_key_schedule *sched,
+		  DES_cblock *iv);
+char *DES_fcrypt(const char *buf,const char *salt, char *ret);
+char *DES_crypt(const char *buf,const char *salt);
+void DES_ofb_encrypt(const unsigned char *in,unsigned char *out,int numbits,
+		     long length,DES_key_schedule *schedule,DES_cblock *ivec);
+void DES_pcbc_encrypt(const unsigned char *input,unsigned char *output,
+		      long length,DES_key_schedule *schedule,DES_cblock *ivec,
+		      int enc);
+DES_LONG DES_quad_cksum(const unsigned char *input,DES_cblock output[],
+			long length,int out_count,DES_cblock *seed);
+int DES_random_key(DES_cblock *ret);
+void DES_set_odd_parity(DES_cblock *key);
+int DES_check_key_parity(const_DES_cblock *key);
+int DES_is_weak_key(const_DES_cblock *key);
+/* DES_set_key (= set_key = DES_key_sched = key_sched) calls
+ * DES_set_key_checked if global variable DES_check_key is set,
+ * DES_set_key_unchecked otherwise. */
+int DES_set_key(const_DES_cblock *key,DES_key_schedule *schedule);
+int DES_key_sched(const_DES_cblock *key,DES_key_schedule *schedule);
+int DES_set_key_checked(const_DES_cblock *key,DES_key_schedule *schedule);
+void DES_set_key_unchecked(const_DES_cblock *key,DES_key_schedule *schedule);
+void DES_string_to_key(const char *str,DES_cblock *key);
+void DES_string_to_2keys(const char *str,DES_cblock *key1,DES_cblock *key2);
+void DES_cfb64_encrypt(const unsigned char *in,unsigned char *out,long length,
+		       DES_key_schedule *schedule,DES_cblock *ivec,int *num,
+		       int enc);
+void DES_ofb64_encrypt(const unsigned char *in,unsigned char *out,long length,
+		       DES_key_schedule *schedule,DES_cblock *ivec,int *num);
+
+int DES_read_password(DES_cblock *key, const char *prompt, int verify);
+int DES_read_2passwords(DES_cblock *key1, DES_cblock *key2, const char *prompt,
+	int verify);
+
+#define DES_fixup_key_parity DES_set_odd_parity
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/library/openssl_md5.h quaggasnmpTrap//include/net-snmp/library/openssl_md5.h
--- quagga-0.99.18//include/net-snmp/library/openssl_md5.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/openssl_md5.h	2010-05-26 21:08:26.000000000 -0700
@@ -0,0 +1,116 @@
+/* crypto/md5/md5.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#ifndef HEADER_MD5_H
+#define HEADER_MD5_H
+
+#include <stddef.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#ifdef OPENSSL_NO_MD5
+#error MD5 is disabled.
+#endif
+
+/*
+ * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+ * ! MD5_LONG has to be at least 32 bits wide. If it's wider, then !
+ * ! MD5_LONG_LOG2 has to be defined along.			   !
+ * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+ */
+
+#if defined(__LP32__)
+#define MD5_LONG unsigned long
+#elif defined(OPENSSL_SYS_CRAY) || defined(__ILP64__)
+#define MD5_LONG unsigned long
+#define MD5_LONG_LOG2 3
+/*
+ * _CRAY note. I could declare short, but I have no idea what impact
+ * does it have on performance on none-T3E machines. I could declare
+ * int, but at least on C90 sizeof(int) can be chosen at compile time.
+ * So I've chosen long...
+ *					<appro@fy.chalmers.se>
+ */
+#else
+#define MD5_LONG unsigned int
+#endif
+
+#define MD5_CBLOCK	64
+#define MD5_LBLOCK	(MD5_CBLOCK/4)
+#define MD5_DIGEST_LENGTH 16
+
+typedef struct MD5state_st
+	{
+	MD5_LONG A,B,C,D;
+	MD5_LONG Nl,Nh;
+	MD5_LONG data[MD5_LBLOCK];
+	unsigned int num;
+	} MD5_CTX;
+
+int MD5_Init(MD5_CTX *c);
+int MD5_Update(MD5_CTX *c, const void *data, size_t len);
+int MD5_Final(unsigned char *md, MD5_CTX *c);
+unsigned char *MD5(const unsigned char *d, size_t n, unsigned char *md);
+void MD5_Transform(MD5_CTX *c, const unsigned char *b);
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/library/openssl_sha.h quaggasnmpTrap//include/net-snmp/library/openssl_sha.h
--- quagga-0.99.18//include/net-snmp/library/openssl_sha.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/openssl_sha.h	2010-05-26 21:08:26.000000000 -0700
@@ -0,0 +1,199 @@
+/* crypto/sha/sha.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#ifndef HEADER_SHA_H
+#define HEADER_SHA_H
+
+#include <stddef.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#if defined(OPENSSL_NO_SHA) || (defined(OPENSSL_NO_SHA0) && defined(OPENSSL_NO_SHA1))
+#error SHA is disabled.
+#endif
+
+#if defined(OPENSSL_FIPS)
+#define FIPS_SHA_SIZE_T size_t
+#endif
+
+/*
+ * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+ * ! SHA_LONG has to be at least 32 bits wide. If it's wider, then !
+ * ! SHA_LONG_LOG2 has to be defined along.                        !
+ * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+ */
+
+#if defined(__LP32__)
+#define SHA_LONG unsigned long
+#elif defined(OPENSSL_SYS_CRAY) || defined(__ILP64__)
+#define SHA_LONG unsigned long
+#define SHA_LONG_LOG2 3
+#else
+#define SHA_LONG unsigned int
+#endif
+
+#define SHA_LBLOCK	16
+#define SHA_CBLOCK	(SHA_LBLOCK*4)	/* SHA treats input data as a
+					 * contiguous array of 32 bit
+					 * wide big-endian values. */
+#define SHA_LAST_BLOCK  (SHA_CBLOCK-8)
+#define SHA_DIGEST_LENGTH 20
+
+typedef struct SHAstate_st
+	{
+	SHA_LONG h0,h1,h2,h3,h4;
+	SHA_LONG Nl,Nh;
+	SHA_LONG data[SHA_LBLOCK];
+	unsigned int num;
+	} SHA_CTX;
+
+#ifndef OPENSSL_NO_SHA0
+int SHA_Init(SHA_CTX *c);
+int SHA_Update(SHA_CTX *c, const void *data, size_t len);
+int SHA_Final(unsigned char *md, SHA_CTX *c);
+unsigned char *SHA(const unsigned char *d, size_t n, unsigned char *md);
+void SHA_Transform(SHA_CTX *c, const unsigned char *data);
+#endif
+#ifndef OPENSSL_NO_SHA1
+int SHA1_Init(SHA_CTX *c);
+int SHA1_Update(SHA_CTX *c, const void *data, size_t len);
+int SHA1_Final(unsigned char *md, SHA_CTX *c);
+unsigned char *SHA1(const unsigned char *d, size_t n, unsigned char *md);
+void SHA1_Transform(SHA_CTX *c, const unsigned char *data);
+#endif
+
+#define SHA256_CBLOCK	(SHA_LBLOCK*4)	/* SHA-256 treats input data as a
+					 * contiguous array of 32 bit
+					 * wide big-endian values. */
+#define SHA224_DIGEST_LENGTH	28
+#define SHA256_DIGEST_LENGTH	32
+
+typedef struct SHA256state_st
+	{
+	SHA_LONG h[8];
+	SHA_LONG Nl,Nh;
+	SHA_LONG data[SHA_LBLOCK];
+	unsigned int num,md_len;
+	} SHA256_CTX;
+
+#ifndef OPENSSL_NO_SHA256
+int SHA224_Init(SHA256_CTX *c);
+int SHA224_Update(SHA256_CTX *c, const void *data, size_t len);
+int SHA224_Final(unsigned char *md, SHA256_CTX *c);
+unsigned char *SHA224(const unsigned char *d, size_t n,unsigned char *md);
+int SHA256_Init(SHA256_CTX *c);
+int SHA256_Update(SHA256_CTX *c, const void *data, size_t len);
+int SHA256_Final(unsigned char *md, SHA256_CTX *c);
+unsigned char *SHA256(const unsigned char *d, size_t n,unsigned char *md);
+void SHA256_Transform(SHA256_CTX *c, const unsigned char *data);
+#endif
+
+#define SHA384_DIGEST_LENGTH	48
+#define SHA512_DIGEST_LENGTH	64
+
+#ifndef OPENSSL_NO_SHA512
+/*
+ * Unlike 32-bit digest algorithms, SHA-512 *relies* on SHA_LONG64
+ * being exactly 64-bit wide. See Implementation Notes in sha512.c
+ * for further details.
+ */
+#define SHA512_CBLOCK	(SHA_LBLOCK*8)	/* SHA-512 treats input data as a
+					 * contiguous array of 64 bit
+					 * wide big-endian values. */
+#if (defined(_WIN32) || defined(_WIN64)) && !defined(__MINGW32__)
+#define SHA_LONG64 unsigned __int64
+#define U64(C)     C##UI64
+#elif defined(__arch64__)
+#define SHA_LONG64 unsigned long
+#define U64(C)     C##UL
+#else
+#define SHA_LONG64 unsigned long long
+#define U64(C)     C##ULL
+#endif
+
+typedef struct SHA512state_st
+	{
+	SHA_LONG64 h[8];
+	SHA_LONG64 Nl,Nh;
+	union {
+		SHA_LONG64	d[SHA_LBLOCK];
+		unsigned char	p[SHA512_CBLOCK];
+	} u;
+	unsigned int num,md_len;
+	} SHA512_CTX;
+#endif
+
+#ifndef OPENSSL_NO_SHA512
+int SHA384_Init(SHA512_CTX *c);
+int SHA384_Update(SHA512_CTX *c, const void *data, size_t len);
+int SHA384_Final(unsigned char *md, SHA512_CTX *c);
+unsigned char *SHA384(const unsigned char *d, size_t n,unsigned char *md);
+int SHA512_Init(SHA512_CTX *c);
+int SHA512_Update(SHA512_CTX *c, const void *data, size_t len);
+int SHA512_Final(unsigned char *md, SHA512_CTX *c);
+unsigned char *SHA512(const unsigned char *d, size_t n,unsigned char *md);
+void SHA512_Transform(SHA512_CTX *c, const unsigned char *data);
+#endif
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/library/parse.h quaggasnmpTrap//include/net-snmp/library/parse.h
--- quagga-0.99.18//include/net-snmp/library/parse.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/parse.h	2010-02-27 05:11:15.000000000 -0800
@@ -0,0 +1,240 @@
+#ifndef PARSE_H
+#define PARSE_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#include <net-snmp/mib_api.h>
+
+    /*
+     * parse.h
+     */
+/***********************************************************
+        Copyright 1989 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of CMU not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+******************************************************************/
+
+#define MAXLABEL        64      /* maximum characters in a label */
+#define MAXTOKEN        128     /* maximum characters in a token */
+#define MAXQUOTESTR     4096    /* maximum characters in a quoted string */
+
+    struct variable_list;
+
+    /*
+     * A linked list of tag-value pairs for enumerated integers.
+     */
+    struct enum_list {
+        struct enum_list *next;
+        int             value;
+        char           *label;
+    };
+
+    /*
+     * A linked list of ranges
+     */
+    struct range_list {
+        struct range_list *next;
+        int             low, high;
+    };
+
+    /*
+     * A linked list of indexes
+     */
+    struct index_list {
+        struct index_list *next;
+        char           *ilabel;
+        char            isimplied;
+    };
+
+    /*
+     * A linked list of varbinds
+     */
+    struct varbind_list {
+        struct varbind_list *next;
+        char           *vblabel;
+    };
+
+    /*
+     * A tree in the format of the tree structure of the MIB.
+     */
+    struct tree {
+        struct tree    *child_list;     /* list of children of this node */
+        struct tree    *next_peer;      /* Next node in list of peers */
+        struct tree    *next;   /* Next node in hashed list of names */
+        struct tree    *parent;
+        char           *label;  /* This node's textual name */
+        u_long          subid;  /* This node's integer subidentifier */
+        int             modid;  /* The module containing this node */
+        int             number_modules;
+        int            *module_list;    /* To handle multiple modules */
+        int             tc_index;       /* index into tclist (-1 if NA) */
+        int             type;   /* This node's object type */
+        int             access; /* This nodes access */
+        int             status; /* This nodes status */
+        struct enum_list *enums;        /* (optional) list of enumerated integers */
+        struct range_list *ranges;
+        struct index_list *indexes;
+        char           *augments;
+        struct varbind_list *varbinds;
+        char           *hint;
+        char           *units;
+        int             (*printomat) (u_char **, size_t *, size_t *, int,
+                                      const netsnmp_variable_list *,
+                                      const struct enum_list *, const char *,
+                                      const char *);
+        void            (*printer) (char *, const netsnmp_variable_list *, const struct enum_list *, const char *, const char *);   /* Value printing function */
+        char           *description;    /* description (a quoted string) */
+        char           *reference;    /* references (a quoted string) */
+        int             reported;       /* 1=report started in print_subtree... */
+        char           *defaultValue;
+    };
+
+    /*
+     * Information held about each MIB module
+     */
+    struct module_import {
+        char           *label;  /* The descriptor being imported */
+        int             modid;  /* The module imported from */
+    };
+
+    struct module {
+        char           *name;   /* This module's name */
+        char           *file;   /* The file containing the module */
+        struct module_import *imports;  /* List of descriptors being imported */
+        int             no_imports;     /* The number of such import descriptors */
+        /*
+         * -1 implies the module hasn't been read in yet 
+         */
+        int             modid;  /* The index number of this module */
+        struct module  *next;   /* Linked list pointer */
+    };
+
+    struct module_compatability {
+        const char     *old_module;
+        const char     *new_module;
+        const char     *tag;    /* NULL implies unconditional replacement,
+                                 * otherwise node identifier or prefix */
+        size_t          tag_len;        /* 0 implies exact match (or unconditional) */
+        struct module_compatability *next;      /* linked list */
+    };
+
+
+    /*
+     * non-aggregate types for tree end nodes 
+     */
+#define TYPE_OTHER          0
+#define TYPE_OBJID          1
+#define TYPE_OCTETSTR       2
+#define TYPE_INTEGER        3
+#define TYPE_NETADDR        4
+#define TYPE_IPADDR         5
+#define TYPE_COUNTER        6
+#define TYPE_GAUGE          7
+#define TYPE_TIMETICKS      8
+#define TYPE_OPAQUE         9
+#define TYPE_NULL           10
+#define TYPE_COUNTER64      11
+#define TYPE_BITSTRING      12
+#define TYPE_NSAPADDRESS    13
+#define TYPE_UINTEGER       14
+#define TYPE_UNSIGNED32     15
+#define TYPE_INTEGER32      16
+
+#define TYPE_SIMPLE_LAST    16
+
+#define TYPE_TRAPTYPE	    20
+#define TYPE_NOTIFTYPE      21
+#define TYPE_OBJGROUP	    22
+#define TYPE_NOTIFGROUP	    23
+#define TYPE_MODID	    24
+#define TYPE_AGENTCAP       25
+#define TYPE_MODCOMP        26
+#define TYPE_OBJIDENTITY    27
+
+#define MIB_ACCESS_READONLY    18
+#define MIB_ACCESS_READWRITE   19
+#define	MIB_ACCESS_WRITEONLY   20
+#define MIB_ACCESS_NOACCESS    21
+#define MIB_ACCESS_NOTIFY      67
+#define MIB_ACCESS_CREATE      48
+
+#define MIB_STATUS_MANDATORY   23
+#define MIB_STATUS_OPTIONAL    24
+#define MIB_STATUS_OBSOLETE    25
+#define MIB_STATUS_DEPRECATED  39
+#define MIB_STATUS_CURRENT     57
+
+#define	ANON	"anonymous#"
+#define	ANON_LEN  strlen(ANON)
+
+    int             netsnmp_unload_module(const char *name);
+#ifndef NETSNMP_NO_LEGACY_DEFINITIONS
+    int             unload_module(const char *name);
+#endif
+    void            netsnmp_init_mib_internals(void);
+    void            unload_all_mibs(void);
+    int             add_mibfile(const char*, const char*, FILE *);
+    int             which_module(const char *);
+    NETSNMP_IMPORT
+    char           *module_name(int, char *);
+    NETSNMP_IMPORT
+    void            print_subtree(FILE *, struct tree *, int);
+    NETSNMP_IMPORT
+    void            print_ascii_dump_tree(FILE *, struct tree *, int);
+    NETSNMP_IMPORT
+    struct tree    *find_tree_node(const char *, int);
+    NETSNMP_IMPORT
+    const char     *get_tc_descriptor(int);
+    NETSNMP_IMPORT
+    const char     *get_tc_description(int);
+    NETSNMP_IMPORT
+    struct tree    *find_best_tree_node(const char *, struct tree *,
+                                        u_int *);
+    /*
+     * backwards compatability 
+     */
+    NETSNMP_IMPORT
+    struct tree    *find_node(const char *, struct tree *);
+    struct tree    *find_node2(const char *, const char *); 
+    NETSNMP_IMPORT
+    struct module  *find_module(int);
+    void            adopt_orphans(void);
+    NETSNMP_IMPORT
+    char           *snmp_mib_toggle_options(char *options);
+    NETSNMP_IMPORT
+    void            snmp_mib_toggle_options_usage(const char *lead,
+                                                  FILE * outf);
+    NETSNMP_IMPORT
+    void            print_mib(FILE *);
+    NETSNMP_IMPORT
+    void            print_mib_tree(FILE *, struct tree *, int);
+    int             get_mib_parse_error_count(void);
+    NETSNMP_IMPORT
+    int             snmp_get_token(FILE * fp, char *token, int maxtlen);
+    NETSNMP_IMPORT
+    struct tree    *find_best_tree_node(const char *name,
+                                        struct tree *tree_top,
+                                        u_int * match);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* PARSE_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/read_config.h quaggasnmpTrap//include/net-snmp/library/read_config.h
--- quagga-0.99.18//include/net-snmp/library/read_config.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/read_config.h	2010-07-29 03:47:14.000000000 -0700
@@ -0,0 +1,156 @@
+/*
+ *  read_config.h: reads configuration files for extensible sections.
+ *
+ */
+#ifndef READ_CONFIG_H
+#define READ_CONFIG_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#define STRINGMAX 1024
+
+#define NORMAL_CONFIG 0
+#define PREMIB_CONFIG 1
+#define EITHER_CONFIG 2
+
+#include <net-snmp/config_api.h>
+
+    /*
+     * Defines a set of file types and the parse and free functions
+     * which process the syntax following a given token in a given file.
+     */
+    struct config_files {
+        char           *fileHeader;     /* Label for entire file. */
+        struct config_line *start;
+        struct config_files *next;
+    };
+
+    struct config_line {
+        char           *config_token;   /* Label for each line parser
+                                         * in the given file. */
+        void            (*parse_line) (const char *, char *);
+        void            (*free_func) (void);
+        struct config_line *next;
+        char            config_time;    /* {NORMAL,PREMIB,EITHER}_CONFIG */
+        char           *help;
+    };
+
+    struct read_config_memory {
+        char           *line;
+        struct read_config_memory *next;
+    };
+
+
+    NETSNMP_IMPORT
+    int             netsnmp_config(char *);     /* parse a simple line: token=values */
+    NETSNMP_IMPORT
+    void            netsnmp_config_remember(char *);    /* process later, during snmp_init() */
+    void            netsnmp_config_process_memories(void);      /* run all memories through parser */
+    int             read_config(const char *, struct config_line *, int);
+    int             read_config_files(int);
+    NETSNMP_IMPORT
+    void            free_config(void);
+#if !defined(__GNUC__) || __GNUC__ < 2 || (__GNUC__ == 2&& __GNUC_MINOR__ < 8)
+    NETSNMP_IMPORT
+    void            netsnmp_config_error(const char *, ...);
+    void            netsnmp_config_warn(const char *, ...);
+#else
+    NETSNMP_IMPORT
+    void            netsnmp_config_error(const char *, ...)
+	__attribute__((__format__(__printf__, 1, 2)));
+    void            netsnmp_config_warn(const char *, ...)
+	__attribute__((__format__(__printf__, 1, 2)));
+#endif
+
+    NETSNMP_IMPORT
+    char           *skip_white(char *);
+    const char     *skip_white_const(const char *);
+    NETSNMP_IMPORT
+    char           *skip_not_white(char *);
+    const char     *skip_not_white_const(const char *);
+    NETSNMP_IMPORT
+    char           *skip_token(char *);
+    NETSNMP_IMPORT
+    const char     *skip_token_const(const char *);
+    NETSNMP_IMPORT
+    char           *copy_nword(char *, char *, int);
+    NETSNMP_IMPORT
+    const char     *copy_nword_const(const char *, char *, int);
+    NETSNMP_IMPORT
+    char           *copy_word(char *, char *);  /* do not use */
+    NETSNMP_IMPORT
+    int             read_config_with_type(const char *, const char *);
+    NETSNMP_IMPORT
+    char           *read_config_save_octet_string(char *saveto,
+                                                  u_char * str,
+                                                  size_t len);
+    NETSNMP_IMPORT
+    char           *read_config_read_octet_string(const char *readfrom,
+                                                  u_char ** str,
+                                                  size_t * len);
+    const char     *read_config_read_octet_string_const(const char *readfrom,
+                                                        u_char ** str,
+                                                        size_t * len);
+    NETSNMP_IMPORT
+    char           *read_config_read_objid(char *readfrom, oid ** objid,
+                                           size_t * len);
+    const char     *read_config_read_objid_const(const char *readfrom,
+                                                 oid ** objid,
+                                                 size_t * len);
+    NETSNMP_IMPORT
+    char           *read_config_save_objid(char *saveto, oid * objid,
+                                           size_t len);
+    NETSNMP_IMPORT
+    char           *read_config_read_data(int type, char *readfrom,
+                                          void *dataptr, size_t * len);
+    NETSNMP_IMPORT
+    char           *read_config_read_memory(int type, char *readfrom,
+                                            char *dataptr, size_t * len);
+    NETSNMP_IMPORT
+    char           *read_config_store_data(int type, char *storeto,
+                                           void *dataptr, size_t * len);
+    char           *read_config_store_data_prefix(char prefix, int type,
+                                                  char *storeto,
+                                                  void *dataptr, size_t len);
+    int  read_config_files_of_type(int when, struct config_files *ctmp);
+    NETSNMP_IMPORT
+    void            read_config_store(const char *type, const char *line);
+    NETSNMP_IMPORT
+    void            read_app_config_store(const char *line);
+    NETSNMP_IMPORT
+    void            snmp_save_persistent(const char *type);
+    NETSNMP_IMPORT
+    void            snmp_clean_persistent(const char *type);
+    struct config_line *read_config_get_handlers(const char *type);
+
+    /*
+     * external memory list handlers 
+     */
+    void            snmp_config_remember_in_list(char *line,
+                                                 struct read_config_memory
+                                                 **mem);
+    void            snmp_config_process_memory_list(struct
+                                                    read_config_memory
+                                                    **mem, int, int);
+    void            snmp_config_remember_free_list(struct
+                                                   read_config_memory
+                                                   **mem);
+
+    void            set_configuration_directory(const char *dir);
+    NETSNMP_IMPORT
+    const char     *get_configuration_directory(void);
+    void            set_persistent_directory(const char *dir);
+    const char     *get_persistent_directory(void);
+    void            set_temp_file_pattern(const char *pattern);
+    NETSNMP_IMPORT
+    const char     *get_temp_file_pattern(void);
+    NETSNMP_IMPORT
+    void            handle_long_opt(const char *myoptarg);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* READ_CONFIG_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/README quaggasnmpTrap//include/net-snmp/library/README
--- quagga-0.99.18//include/net-snmp/library/README	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/README	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,67 @@
+One of the goals of the Net-SNMP v5 development line, is to try and
+clarify the distinction between the "public" library API, and routines
+that are regarded as being more "internal" to the library.
+
+  This doesn't mean that application writers are discouraged from
+making use of such internal routines.  There is a strong feeling
+within the development team that as much as possible of the library
+should be made externally visible, to support writing as wide a
+range of applications as possible.  To that end, most routines
+will be declared within an installed header file, rather than
+privately within the library code files themselves.
+
+  The public/internal categorisation is rather concerned with issues
+of documentation, stability, and ease of programming.  The public
+API routines have been selected as those covering the more common
+requirements (e.g. creating SNMP requests, sending them to other SNMP
+agents, and interpreting the results), together with certain supporting
+activities (e.g. run-time configuration).
+
+  The intention is that these routines should be properly documented,
+and remain relatively stable.  We will attempt to avoid changing the
+profile of these interfaces, and would normally provide some mechanism
+to retain backward compatability if need be.
+
+  On the other hand, the internal API routines are regarded as just
+that - "internal" - so may legitimately be changed without providing
+any compatability mechanism.  You are perfectly free to make use of
+these routines, but be aware that you do so "at your own risk".
+
+[This statement is in no way intended to challenge or amend the status
+ of the disclaimers in the top-level 'COPYING' file, which remain
+ unchanged  as the legal basis for using this code]
+
+
+  There are (currently) eight main "public API" header files, relating
+to various areas of SNMP programming, plus a combined "all-in-one"
+header file (net-snmp-includes.h).
+  Currently these simply include the relevant library header files
+following the UCD-SNMP organisation.  However, the intention is for
+future releases to declare the public API calls directly within these
+top-level header files, and use the 'library/*.h' files for the more
+internal calls.  (i.e. those that are more likely to change over time).
+
+  Until this process can be started, the best approximation to the
+"public API" list is probably those routines that are documented
+in manual pages.  Apologies for any confusion, but hopefully this
+process will result in a clearer end result than at present.
+
+Applications writers are encouraged to start #including the new header
+files as soon as possible - either individually, or using the combined
+wrapper file.  Hopefully, with only a handful of top-level files, it
+will be reasonably clear which file(s) might be appropriate for any
+particular programming requirement.
+
+
+
+  One final disclaimer:  The above description represents my own
+personal aims and understanding of the likely development of the
+library API.  While I have every confidence in having the support of
+the other developers (or being able to persuade them of the benefits
+of this approach!), it may turn out that things actually take a different
+route.  Anyone wishing to influence the organisation of the eventual
+library API is encouraged to subscribe to the net-snmp-coders mailing
+list, and contribute to the discussions there.
+
+Dave Shield
+February 2002
diff -rupN quagga-0.99.18//include/net-snmp/library/scapi.h quaggasnmpTrap//include/net-snmp/library/scapi.h
--- quagga-0.99.18//include/net-snmp/library/scapi.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/scapi.h	2010-05-27 08:15:43.000000000 -0700
@@ -0,0 +1,107 @@
+/*
+ * scapi.h
+ */
+
+#ifndef _SCAPI_H
+#define _SCAPI_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    /*
+     * Authentication/privacy transform bitlengths.
+     */
+#define SNMP_TRANS_AUTHLEN_HMACMD5	128
+#define SNMP_TRANS_AUTHLEN_HMACSHA1	160
+
+#define SNMP_TRANS_AUTHLEN_HMAC96	96
+
+#define SNMP_TRANS_PRIVLEN_1DES		64
+#define SNMP_TRANS_PRIVLEN_1DES_IV	64
+
+#define SNMP_TRANS_PRIVLEN_AES		128
+#define SNMP_TRANS_PRIVLEN_AES_IV	128
+#define SNMP_TRANS_AES_PADSIZE	   	128  /* backwards compat */
+#define SNMP_TRANS_PRIVLEN_AES128	128  /* backwards compat */
+#define SNMP_TRANS_PRIVLEN_AES128_IV	128  /* backwards compat */
+#define SNMP_TRANS_AES_AES128_PADSIZE   128  /* backwards compat */
+
+    /*
+     * Prototypes.
+     */
+    int             sc_get_properlength(const oid * hashtype,
+                                        u_int hashtype_len);
+    int             sc_get_proper_priv_length(const oid * privtype,
+                                              u_int privtype_len);
+
+    NETSNMP_IMPORT
+    int             sc_init(void);
+    int             sc_shutdown(int majorID, int minorID, void *serverarg,
+                                void *clientarg);
+
+    int             sc_random(u_char * buf, size_t * buflen);
+
+    int             sc_generate_keyed_hash(const oid * authtype,
+                                           size_t authtypelen,
+                                           const u_char * key, u_int keylen,
+                                           const u_char * message, u_int msglen,
+                                           u_char * MAC, size_t * maclen);
+
+    int             sc_check_keyed_hash(const oid * authtype,
+                                        size_t authtypelen, const u_char * key,
+                                        u_int keylen, const u_char * message,
+                                        u_int msglen, const u_char * MAC,
+                                        u_int maclen);
+
+    int             sc_encrypt(const oid * privtype, size_t privtypelen,
+                               u_char * key, u_int keylen,
+                               u_char * iv, u_int ivlen,
+                               const u_char * plaintext, u_int ptlen,
+                               u_char * ciphertext, size_t * ctlen);
+
+    int             sc_decrypt(const oid * privtype, size_t privtypelen,
+                               u_char * key, u_int keylen,
+                               u_char * iv, u_int ivlen,
+                               u_char * ciphertext, u_int ctlen,
+                               u_char * plaintext, size_t * ptlen);
+
+    int             sc_hash(const oid * hashtype, size_t hashtypelen,
+                            const u_char * buf, size_t buf_len,
+                            u_char * MAC, size_t * MAC_len);
+
+    int             sc_get_transform_type(oid * hashtype,
+                                          u_int hashtype_len,
+                                          int (**hash_fn) (const int mode,
+                                                           void **context,
+                                                           const u_char *
+                                                           data,
+                                                           const int
+                                                           data_len,
+                                                           u_char **
+                                                           digest,
+                                                           size_t *
+                                                           digest_len));
+
+
+    /*
+     * All functions devolve to the following block if we can't do cryptography
+     */
+#define	_SCAPI_NOT_CONFIGURED					\
+{								\
+        snmp_log(LOG_ERR, "Encryption support not enabled.\n"); \
+        DEBUGMSGTL(("scapi", "SCAPI not configured"));		\
+	return SNMPERR_SC_NOT_CONFIGURED;			\
+}
+
+    /*
+     * define a transform type if we're using the internal md5 support 
+     */
+#ifdef NETSNMP_USE_INTERNAL_MD5
+#define INTERNAL_MD5 1
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* _SCAPI_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpAAL5PVCDomain.h quaggasnmpTrap//include/net-snmp/library/snmpAAL5PVCDomain.h
--- quagga-0.99.18//include/net-snmp/library/snmpAAL5PVCDomain.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpAAL5PVCDomain.h	2010-02-09 15:45:10.000000000 -0800
@@ -0,0 +1,39 @@
+#ifndef _SNMPAAL5PVCDOMAIN_H
+#define _SNMPAAL5PVCDOMAIN_H
+
+#ifdef NETSNMP_TRANSPORT_AAL5PVC_DOMAIN
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#if HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+
+#ifndef linux
+    config_error(AAL5 PVC support unavailable for this platform -Linux only-);
+#endif
+
+#include <atm.h>
+
+#include <net-snmp/library/snmp_transport.h>
+#include <net-snmp/library/asn1.h>
+
+extern oid  netsnmp_AAL5PVCDomain[]; /* = { NETSNMP_ENTERPRISE_MIB, 3, 3, 3 }; */
+
+netsnmp_transport *netsnmp_aal5pvc_transport(struct sockaddr_atmpvc *addr,
+                                             int local);
+
+/*
+ * "Constructor" for transport domain object.  
+ */
+
+void            netsnmp_aal5pvc_ctor(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /*NETSNMP_TRANSPORT_AAL5PVC_DOMAIN */
+
+#endif/*_SNMPAAL5PVCDOMAIN_H*/
diff -rupN quagga-0.99.18//include/net-snmp/library/snmp_alarm.h quaggasnmpTrap//include/net-snmp/library/snmp_alarm.h
--- quagga-0.99.18//include/net-snmp/library/snmp_alarm.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmp_alarm.h	2010-08-13 16:50:12.000000000 -0700
@@ -0,0 +1,64 @@
+#ifndef SNMP_ALARM_H
+#define SNMP_ALARM_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    typedef void    (SNMPAlarmCallback) (unsigned int clientreg,
+                                         void *clientarg);
+
+    /*
+     * alarm flags 
+     */
+#define SA_REPEAT 0x01          /* keep repeating every X seconds */
+#define SA_FIRED 0x10          /* Being processed in run_alarms */
+
+    struct snmp_alarm {
+        struct timeval  t;
+        unsigned int    flags;
+        unsigned int    clientreg;
+        struct timeval  t_last;
+        struct timeval  t_next;
+        void           *clientarg;
+        SNMPAlarmCallback *thecallback;
+        struct snmp_alarm *next;
+    };
+
+    /*
+     * the ones you should need 
+     */
+    NETSNMP_IMPORT
+    void            snmp_alarm_unregister(unsigned int clientreg);
+    void	    snmp_alarm_unregister_all(void);
+    NETSNMP_IMPORT
+    unsigned int    snmp_alarm_register(unsigned int when,
+                                        unsigned int flags,
+                                        SNMPAlarmCallback * thecallback,
+                                        void *clientarg);
+
+    unsigned int    snmp_alarm_register_hr(struct timeval t,
+                                           unsigned int flags,
+                                           SNMPAlarmCallback * cb,
+                                           void *cd);
+
+
+    /*
+     * the ones you shouldn't 
+     */
+    NETSNMP_IMPORT void init_snmp_alarm(void);
+    int             init_alarm_post_config(int majorid, int minorid,
+                                           void *serverarg,
+                                           void *clientarg);
+    void            sa_update_entry(struct snmp_alarm *alrm);
+    struct snmp_alarm *sa_find_next(void);
+    NETSNMP_IMPORT void run_alarms(void);
+    RETSIGTYPE      alarm_handler(int a);
+    void            set_an_alarm(void);
+    int             get_next_alarm_delay_time(struct timeval *delta);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* SNMP_ALARM_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpAliasDomain.h quaggasnmpTrap//include/net-snmp/library/snmpAliasDomain.h
--- quagga-0.99.18//include/net-snmp/library/snmpAliasDomain.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpAliasDomain.h	2008-05-12 14:07:39.000000000 -0700
@@ -0,0 +1,32 @@
+#ifndef _SNMPALIASDOMAIN_H
+#define _SNMPALIASDOMAIN_H
+
+#ifdef NETSNMP_TRANSPORT_ALIAS_DOMAIN
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#include <net-snmp/library/snmp_transport.h>
+#include <net-snmp/library/asn1.h>
+
+/*
+ * Simple aliases for complex transport strings that can be specified
+ * via the snmp.conf file and the 'alias' token.
+ */
+
+#define TRANSPORT_DOMAIN_ALIAS_IP		1,3,6,1,2,1,100,1,5
+NETSNMP_IMPORT oid netsnmp_snmpALIASDomain[];
+
+/*
+ * "Constructor" for transport domain object.  
+ */
+
+void            netsnmp_alias_ctor(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /*NETSNMP_TRANSPORT_ALIAS_DOMAIN */
+
+#endif/*_SNMPALIASDOMAIN_H*/
diff -rupN quagga-0.99.18//include/net-snmp/library/snmp_api.h quaggasnmpTrap//include/net-snmp/library/snmp_api.h
--- quagga-0.99.18//include/net-snmp/library/snmp_api.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmp_api.h	2010-10-13 09:30:51.000000000 -0700
@@ -0,0 +1,684 @@
+/* Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ */
+/*
+ * Portions of this file are copyrighted by:
+ * Copyright Â© 2003 Sun Microsystems, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+#ifndef SNMP_API_H
+#define SNMP_API_H
+
+/*
+ * @file snmp_api.h - API for access to snmp.
+ * 
+ * @addtogroup library
+ *
+ * Caution: when using this library in a multi-threaded application,
+ * the values of global variables "snmp_errno" and "snmp_detail"
+ * cannot be reliably determined.  Suggest using snmp_error()
+ * to obtain the library error codes.
+ *
+ * @{
+ */
+
+#include <net-snmp/types.h>
+#include <net-snmp/varbind_api.h>
+#include <net-snmp/output_api.h>
+#include <net-snmp/pdu_api.h>
+#include <net-snmp/session_api.h>
+
+#ifndef DONT_SHARE_ERROR_WITH_OTHER_THREADS
+#define SET_SNMP_ERROR(x) snmp_errno=(x)
+#else
+#define SET_SNMP_ERROR(x)
+#endif
+
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/***********************************************************
+	Copyright 1989 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of CMU not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+******************************************************************/
+
+struct timeval;
+/*
+ * A list of all the outstanding requests for a particular session.
+ */
+#ifdef SNMP_NEED_REQUEST_LIST
+typedef struct request_list {
+    struct request_list *next_request;
+    long            request_id;     /* request id */
+    long            message_id;     /* message id */
+    netsnmp_callback callback;      /* user callback per request (NULL if unused) */
+    void           *cb_data;        /* user callback data per request (NULL if unused) */
+    int             retries;        /* Number of retries */
+    u_long          timeout;        /* length to wait for timeout */
+    struct timeval  time;   /* Time this request was made */
+    struct timeval  expire; /* time this request is due to expire */
+    struct snmp_session *session;
+    netsnmp_pdu    *pdu;    /* The pdu for this request
+			     * (saved so it can be retransmitted */
+} netsnmp_request_list;
+#endif                          /* SNMP_NEED_REQUEST_LIST */
+
+    /*
+     * Set fields in session and pdu to the following to get a default or unconfigured value.
+     */
+#define SNMP_DEFAULT_COMMUNITY_LEN  0   /* to get a default community name */
+#define SNMP_DEFAULT_RETRIES	    -1
+#define SNMP_DEFAULT_TIMEOUT	    -1
+#define SNMP_DEFAULT_REMPORT	    0
+#define SNMP_DEFAULT_REQID	    -1
+#define SNMP_DEFAULT_MSGID	    -1
+#define SNMP_DEFAULT_ERRSTAT	    -1
+#define SNMP_DEFAULT_ERRINDEX	    -1
+#define SNMP_DEFAULT_ADDRESS	    0
+#define SNMP_DEFAULT_PEERNAME	    NULL
+#define SNMP_DEFAULT_ENTERPRISE_LENGTH	0
+#define SNMP_DEFAULT_TIME	    0
+#define SNMP_DEFAULT_VERSION	    -1
+#define SNMP_DEFAULT_SECMODEL	    -1
+#define SNMP_DEFAULT_CONTEXT        ""
+#ifndef NETSNMP_DISABLE_MD5
+#define SNMP_DEFAULT_AUTH_PROTO     usmHMACMD5AuthProtocol
+#else
+#define SNMP_DEFAULT_AUTH_PROTO     usmHMACSHA1AuthProtocol
+#endif
+#define SNMP_DEFAULT_AUTH_PROTOLEN  USM_LENGTH_OID_TRANSFORM
+#ifndef NETSNMP_DISABLE_DES
+#define SNMP_DEFAULT_PRIV_PROTO     usmDESPrivProtocol
+#else
+#define SNMP_DEFAULT_PRIV_PROTO     usmAESPrivProtocol
+#endif
+#define SNMP_DEFAULT_PRIV_PROTOLEN  USM_LENGTH_OID_TRANSFORM
+
+    NETSNMP_IMPORT void     snmp_set_detail(const char *);
+
+#define SNMP_MAX_MSG_SIZE          1472 /* ethernet MTU minus IP/UDP header */
+#define SNMP_MAX_MSG_V3_HDRS       (4+3+4+7+7+3+7+16)   /* fudge factor=16 */
+#define SNMP_MAX_ENG_SIZE          32
+#define SNMP_MAX_SEC_NAME_SIZE     256
+#define SNMP_MAX_CONTEXT_SIZE      256
+#define SNMP_SEC_PARAM_BUF_SIZE    256
+
+    /*
+     * set to one to ignore unauthenticated Reports 
+     */
+#define SNMPV3_IGNORE_UNAUTH_REPORTS 0
+
+    /*
+     * authoritative engine definitions 
+     */
+#define SNMP_SESS_NONAUTHORITATIVE 0    /* should be 0 to default to this */
+#define SNMP_SESS_AUTHORITATIVE    1    /* don't learn engineIDs */
+#define SNMP_SESS_UNKNOWNAUTH      2    /* sometimes (like NRs) */
+
+    /*
+     * to determine type of Report from varbind_list 
+     */
+#define REPORT_STATS_LEN 9
+#define REPORT_snmpUnknownSecurityModels_NUM 1
+#define REPORT_snmpInvalidMsgs_NUM 2
+#define REPORT_usmStatsUnsupportedSecLevels_NUM 1
+#define REPORT_usmStatsNotInTimeWindows_NUM 2
+#define REPORT_usmStatsUnknownUserNames_NUM 3
+#define REPORT_usmStatsUnknownEngineIDs_NUM 4
+#define REPORT_usmStatsWrongDigests_NUM 5
+#define REPORT_usmStatsDecryptionErrors_NUM 6
+
+#define SNMP_DETAIL_SIZE        512
+
+#define SNMP_FLAGS_UDP_BROADCAST   0x800
+#define SNMP_FLAGS_RESP_CALLBACK   0x400      /* Additional callback on response */
+#define SNMP_FLAGS_USER_CREATED    0x200      /* USM user has been created */
+#define SNMP_FLAGS_DONT_PROBE      0x100      /* don't probe for an engineID */
+#define SNMP_FLAGS_STREAM_SOCKET   0x80
+#define SNMP_FLAGS_LISTENING       0x40 /* Server stream sockets only */
+#define SNMP_FLAGS_SUBSESSION      0x20
+#define SNMP_FLAGS_STRIKE2         0x02
+#define SNMP_FLAGS_STRIKE1         0x01
+
+#define CLEAR_SNMP_STRIKE_FLAGS(x) \
+	x &= ~(SNMP_FLAGS_STRIKE2|SNMP_FLAGS_STRIKE1)
+
+    /*
+     * returns '1' if the session is to be regarded as dead,
+     * otherwise set the strike flags appropriately, and return 0
+     */
+#define SET_SNMP_STRIKE_FLAGS(x) \
+	((   x & SNMP_FLAGS_STRIKE2 ) ? 1 :				\
+	 ((( x & SNMP_FLAGS_STRIKE1 ) ? ( x |= SNMP_FLAGS_STRIKE2 ) :	\
+	                                ( x |= SNMP_FLAGS_STRIKE1 )),	\
+	                                0))
+
+    /*
+     * Error return values.
+     *
+     * SNMPERR_SUCCESS is the non-PDU "success" code.
+     *
+     * XXX  These should be merged with SNMP_ERR_* defines and confined
+     *      to values < 0.  ???
+     */
+#define SNMPERR_SUCCESS			(0)     /* XXX  Non-PDU "success" code. */
+#define SNMPERR_GENERR			(-1)
+#define SNMPERR_BAD_LOCPORT		(-2)
+#define SNMPERR_BAD_ADDRESS		(-3)
+#define SNMPERR_BAD_SESSION		(-4)
+#define SNMPERR_TOO_LONG		(-5)
+#define SNMPERR_NO_SOCKET		(-6)
+#define SNMPERR_V2_IN_V1		(-7)
+#define SNMPERR_V1_IN_V2		(-8)
+#define SNMPERR_BAD_REPEATERS		(-9)
+#define SNMPERR_BAD_REPETITIONS		(-10)
+#define SNMPERR_BAD_ASN1_BUILD		(-11)
+#define SNMPERR_BAD_SENDTO		(-12)
+#define SNMPERR_BAD_PARSE		(-13)
+#define SNMPERR_BAD_VERSION		(-14)
+#define SNMPERR_BAD_SRC_PARTY		(-15)
+#define SNMPERR_BAD_DST_PARTY		(-16)
+#define SNMPERR_BAD_CONTEXT		(-17)
+#define SNMPERR_BAD_COMMUNITY		(-18)
+#define SNMPERR_NOAUTH_DESPRIV		(-19)
+#define SNMPERR_BAD_ACL			(-20)
+#define SNMPERR_BAD_PARTY		(-21)
+#define SNMPERR_ABORT			(-22)
+#define SNMPERR_UNKNOWN_PDU		(-23)
+#define SNMPERR_TIMEOUT 		(-24)
+#define SNMPERR_BAD_RECVFROM 		(-25)
+#define SNMPERR_BAD_ENG_ID 		(-26)
+#define SNMPERR_BAD_SEC_NAME 		(-27)
+#define SNMPERR_BAD_SEC_LEVEL 		(-28)
+#define SNMPERR_ASN_PARSE_ERR           (-29)
+#define SNMPERR_UNKNOWN_SEC_MODEL 	(-30)
+#define SNMPERR_INVALID_MSG             (-31)
+#define SNMPERR_UNKNOWN_ENG_ID          (-32)
+#define SNMPERR_UNKNOWN_USER_NAME 	(-33)
+#define SNMPERR_UNSUPPORTED_SEC_LEVEL 	(-34)
+#define SNMPERR_AUTHENTICATION_FAILURE 	(-35)
+#define SNMPERR_NOT_IN_TIME_WINDOW 	(-36)
+#define SNMPERR_DECRYPTION_ERR          (-37)
+#define SNMPERR_SC_GENERAL_FAILURE	(-38)
+#define SNMPERR_SC_NOT_CONFIGURED	(-39)
+#define SNMPERR_KT_NOT_AVAILABLE	(-40)
+#define SNMPERR_UNKNOWN_REPORT          (-41)
+#define SNMPERR_USM_GENERICERROR		(-42)
+#define SNMPERR_USM_UNKNOWNSECURITYNAME		(-43)
+#define SNMPERR_USM_UNSUPPORTEDSECURITYLEVEL	(-44)
+#define SNMPERR_USM_ENCRYPTIONERROR		(-45)
+#define SNMPERR_USM_AUTHENTICATIONFAILURE	(-46)
+#define SNMPERR_USM_PARSEERROR			(-47)
+#define SNMPERR_USM_UNKNOWNENGINEID		(-48)
+#define SNMPERR_USM_NOTINTIMEWINDOW		(-49)
+#define SNMPERR_USM_DECRYPTIONERROR		(-50)
+#define SNMPERR_NOMIB			(-51)
+#define SNMPERR_RANGE			(-52)
+#define SNMPERR_MAX_SUBID		(-53)
+#define SNMPERR_BAD_SUBID		(-54)
+#define SNMPERR_LONG_OID		(-55)
+#define SNMPERR_BAD_NAME		(-56)
+#define SNMPERR_VALUE			(-57)
+#define SNMPERR_UNKNOWN_OBJID		(-58)
+#define SNMPERR_NULL_PDU		(-59)
+#define SNMPERR_NO_VARS			(-60)
+#define SNMPERR_VAR_TYPE		(-61)
+#define SNMPERR_MALLOC			(-62)
+#define SNMPERR_KRB5			(-63)
+#define SNMPERR_PROTOCOL		(-64)
+#define SNMPERR_OID_NONINCREASING       (-65)
+#define SNMPERR_JUST_A_CONTEXT_PROBE    (-66)
+#define SNMPERR_TRANSPORT_NO_CONFIG     (-67)
+#define SNMPERR_TRANSPORT_CONFIG_ERROR  (-68)
+#define SNMPERR_TLS_NO_CERTIFICATE      (-69)
+
+#define SNMPERR_MAX			(-69)
+
+
+    /*
+     * General purpose memory allocation functions. Use these functions to
+     * allocate memory that may be reallocated or freed by the Net-SNMP
+     * library or to reallocate or free memory that has been allocated by the
+     * Net-SNMP library, and when working in a context where there is more than
+     * one heap. Examples are:
+     * - Perl XSUB's.
+     * - MSVC or MinGW with the Net-SNMP library compiled as a DLL instead of
+     *   a static library.
+     */
+    NETSNMP_IMPORT void *netsnmp_malloc(size_t size);
+    NETSNMP_IMPORT void *netsnmp_calloc(size_t nelem, size_t elsize);
+    NETSNMP_IMPORT void *netsnmp_realloc(void *ptr, size_t size);
+    NETSNMP_IMPORT void netsnmp_free(void *ptr);
+    NETSNMP_IMPORT char *netsnmp_strdup(const char *s1);
+
+    /*
+     * void
+     * snmp_free_pdu(pdu)
+     *     netsnmp_pdu *pdu;
+     *
+     * Frees the pdu and any malloc'd data associated with it.
+     */
+
+    NETSNMP_IMPORT void snmp_free_var_internals(netsnmp_variable_list *);     /* frees contents only */
+
+
+    /*
+     * This routine must be supplied by the application:
+     *
+     * u_char *authenticator(pdu, length, community, community_len)
+     * u_char *pdu;         The rest of the PDU to be authenticated
+     * int *length;         The length of the PDU (updated by the authenticator)
+     * u_char *community;   The community name to authenticate under.
+     * int  community_len   The length of the community name.
+     *
+     * Returns the authenticated pdu, or NULL if authentication failed.
+     * If null authentication is used, the authenticator in snmp_session can be
+     * set to NULL(0).
+     */
+
+
+
+    /*
+     * This routine must be supplied by the application:
+     *
+     * int callback(operation, session, reqid, pdu, magic)
+     * int operation;
+     * netsnmp_session *session;    The session authenticated under.
+     * int reqid;                       The request id of this pdu (0 for TRAP)
+     * netsnmp_pdu *pdu;        The pdu information.
+     * void *magic                      A link to the data for this routine.
+     *
+     * Returns 1 if request was successful, 0 if it should be kept pending.
+     * Any data in the pdu must be copied because it will be freed elsewhere.
+     * Operations are defined below:
+     */
+
+#define NETSNMP_CALLBACK_OP_RECEIVED_MESSAGE	1
+#define NETSNMP_CALLBACK_OP_TIMED_OUT		2
+#define NETSNMP_CALLBACK_OP_SEND_FAILED		3
+#define NETSNMP_CALLBACK_OP_CONNECT		4
+#define NETSNMP_CALLBACK_OP_DISCONNECT		5
+
+    long            snmp_get_next_msgid(void);
+    long            snmp_get_next_reqid(void);
+    NETSNMP_IMPORT
+    long            snmp_get_next_sessid(void);
+    NETSNMP_IMPORT
+    long            snmp_get_next_transid(void);
+
+    NETSNMP_IMPORT
+    int             snmp_oid_compare(const oid *, size_t, const oid *,
+                                     size_t);
+    int             snmp_oid_ncompare(const oid *, size_t, const oid *,
+                                      size_t, size_t);
+    NETSNMP_IMPORT
+    int             snmp_oidtree_compare(const oid *, size_t, const oid *,
+                                         size_t);
+    NETSNMP_IMPORT
+    int             snmp_oidsubtree_compare(const oid *, size_t, const oid *,
+                                         size_t);
+    NETSNMP_IMPORT
+    int             netsnmp_oid_compare_ll(const oid * in_name1,
+                                           size_t len1, const oid * in_name2,
+                                           size_t len2, size_t *offpt);
+    NETSNMP_IMPORT
+    int             netsnmp_oid_equals(const oid *, size_t, const oid *,
+                                       size_t);
+    int             netsnmp_oid_tree_equals(const oid *, size_t, const oid *,
+                                            size_t);
+    NETSNMP_IMPORT
+    int             netsnmp_oid_is_subtree(const oid *, size_t, const oid *,
+                                           size_t);
+    NETSNMP_IMPORT
+    int             netsnmp_oid_find_prefix(const oid * in_name1, size_t len1,
+                                            const oid * in_name2, size_t len2);
+    NETSNMP_IMPORT
+    void            init_snmp(const char *);
+    u_char         *snmp_pdu_build(netsnmp_pdu *, u_char *, size_t *);
+#ifdef NETSNMP_USE_REVERSE_ASNENCODING
+    u_char         *snmp_pdu_rbuild(netsnmp_pdu *, u_char *, size_t *);
+#endif
+    int             snmpv3_parse(netsnmp_pdu *, u_char *, size_t *,
+                                 u_char **, netsnmp_session *);
+    int             snmpv3_packet_build(netsnmp_session *,
+                                        netsnmp_pdu *pdu, u_char * packet,
+                                        size_t * out_length,
+                                        u_char * pdu_data,
+                                        size_t pdu_data_len);
+    int             snmpv3_packet_rbuild(netsnmp_session *,
+                                         netsnmp_pdu *pdu, u_char * packet,
+                                         size_t * out_length,
+                                         u_char * pdu_data,
+                                         size_t pdu_data_len);
+    int             snmpv3_make_report(netsnmp_pdu *pdu, int error);
+    int             snmpv3_get_report_type(netsnmp_pdu *pdu);
+    int             snmp_pdu_parse(netsnmp_pdu *pdu, u_char * data,
+                                   size_t * length);
+    u_char         *snmpv3_scopedPDU_parse(netsnmp_pdu *pdu, u_char * cp,
+                                           size_t * length);
+    NETSNMP_IMPORT
+    void            snmp_store_needed(const char *type);
+    NETSNMP_IMPORT
+    void            snmp_store_if_needed(void);
+    NETSNMP_IMPORT
+    void            snmp_store(const char *type);
+    NETSNMP_IMPORT
+    void            snmp_shutdown(const char *type);
+    NETSNMP_IMPORT
+    int             snmp_add_var(netsnmp_pdu *, const oid *, size_t, char,
+                                 const char *);
+    NETSNMP_IMPORT
+    oid            *snmp_duplicate_objid(const oid * objToCopy, size_t);
+    NETSNMP_IMPORT
+    u_int           snmp_increment_statistic(int which);
+    NETSNMP_IMPORT
+    u_int           snmp_increment_statistic_by(int which, int count);
+    NETSNMP_IMPORT
+    u_int           snmp_get_statistic(int which);
+    void            snmp_init_statistics(void);
+    int             create_user_from_session(netsnmp_session * session);
+    int snmp_get_fd_for_session(struct snmp_session *sessp);
+    int snmpv3_probe_contextEngineID_rfc5343(void *slp,
+                                             netsnmp_session *session);
+
+    /*
+     * New re-allocating reverse encoding functions.  
+     */
+#ifdef NETSNMP_USE_REVERSE_ASNENCODING
+
+    int        snmpv3_packet_realloc_rbuild(u_char ** pkt, size_t * pkt_len,
+                                     size_t * offset,
+                                     netsnmp_session * session,
+                                     netsnmp_pdu *pdu, u_char * pdu_data,
+                                     size_t pdu_data_len);
+
+    int        snmp_pdu_realloc_rbuild(u_char ** pkt, size_t * pkt_len,
+                                size_t * offset, netsnmp_pdu *pdu);
+#endif
+
+
+
+struct netsnmp_transport_s;
+
+    /*
+     * Extended open; fpre_parse has changed.  
+     */
+
+    NETSNMP_IMPORT
+    netsnmp_session *snmp_open_ex(netsnmp_session *,
+                                  int (*fpre_parse) (netsnmp_session *,
+                                                     struct
+                                                     netsnmp_transport_s *,
+                                                     void *, int),
+                                  int (*fparse) (netsnmp_session *,
+                                                 netsnmp_pdu *, u_char *,
+                                                 size_t),
+                                  int (*fpost_parse) (netsnmp_session *,
+                                                      netsnmp_pdu *, int),
+                                  int (*fbuild) (netsnmp_session *,
+                                                 netsnmp_pdu *, u_char *,
+                                                 size_t *),
+                                  int (*frbuild) (netsnmp_session *,
+                                                  netsnmp_pdu *, u_char **,
+                                                  size_t *, size_t *),
+                                  int (*fcheck) (u_char *, size_t));
+
+    /*
+     * provided for backwards compatability.  Don't use these functions.
+     * See snmp_debug.h and snmp_debug.c instead.
+     */
+
+    NETSNMP_IMPORT
+    void            snmp_set_do_debugging(int);
+    NETSNMP_IMPORT
+    int             snmp_get_do_debugging(void);
+
+
+    NETSNMP_IMPORT
+    void            netsnmp_sess_log_error(int priority,
+                                           const char *prog_string,
+                                           netsnmp_session * ss);
+    const char *    snmp_pdu_type(int type);
+
+    /*
+     * Return the netsnmp_transport structure associated with the given opaque
+     * pointer.  
+     */
+
+    NETSNMP_IMPORT
+    struct netsnmp_transport_s *snmp_sess_transport(void *);
+    void            snmp_sess_transport_set(void *,
+					    struct netsnmp_transport_s *);
+
+    NETSNMP_IMPORT int
+    netsnmp_sess_config_transport(struct netsnmp_container_s *transport_configuration,
+                                  struct netsnmp_transport_s *transport);
+
+    NETSNMP_IMPORT int
+    netsnmp_sess_config_and_open_transport(netsnmp_session *in_session,
+                                           struct netsnmp_transport_s *transport);
+
+    /*
+     * EXPERIMENTAL API EXTENSIONS ------------------------------------------ 
+     * 
+     * snmp_sess_add_ex, snmp_sess_add, snmp_add 
+     * 
+     * Analogous to snmp_open family of functions, but taking an
+     * netsnmp_transport pointer as an extra argument.  Unlike snmp_open et
+     * al. it doesn't attempt to interpret the in_session->peername as a
+     * transport endpoint specifier, but instead uses the supplied transport.
+     * JBPN
+     * 
+     */
+
+    void           *snmp_sess_add_ex(netsnmp_session *,
+                                     struct netsnmp_transport_s *,
+                                     int (*fpre_parse) (netsnmp_session *,
+                                                        struct
+                                                        netsnmp_transport_s
+                                                        *, void *, int),
+                                     int (*fparse) (netsnmp_session *,
+                                                    struct snmp_pdu *,
+                                                    u_char *, size_t),
+                                     int (*fpost_parse) (netsnmp_session *,
+                                                         struct snmp_pdu *,
+                                                         int),
+                                     int (*fbuild) (netsnmp_session *,
+                                                    struct snmp_pdu *,
+                                                    u_char *, size_t *),
+                                     int (*frbuild) (netsnmp_session *,
+                                                     struct snmp_pdu *,
+                                                     u_char **, size_t *,
+                                                     size_t *),
+                                     int (*fcheck) (u_char *, size_t),
+                                     netsnmp_pdu *(*fcreate_pdu) (struct
+                                                                  netsnmp_transport_s
+                                                                  *,
+                                                                  void *,
+                                                                  size_t));
+
+    void           *snmp_sess_add(netsnmp_session *,
+                                  struct netsnmp_transport_s *,
+                                  int (*fpre_parse) (netsnmp_session *,
+                                                     struct
+                                                     netsnmp_transport_s *,
+                                                     void *, int),
+                                  int (*fpost_parse) (netsnmp_session *,
+                                                      netsnmp_pdu *, int));
+
+    NETSNMP_IMPORT
+    netsnmp_session *snmp_add(netsnmp_session *,
+                              struct netsnmp_transport_s *,
+                              int (*fpre_parse) (netsnmp_session *,
+                                                 struct netsnmp_transport_s
+                                                 *, void *, int),
+                              int (*fpost_parse) (netsnmp_session *,
+                                                  netsnmp_pdu *, int));
+    NETSNMP_IMPORT
+    netsnmp_session *snmp_add_full(netsnmp_session * in_session,
+                                   struct netsnmp_transport_s *transport,
+                                   int (*fpre_parse) (netsnmp_session *,
+                                                      struct
+                                                      netsnmp_transport_s
+                                                      *, void *, int),
+                                   int (*fparse) (netsnmp_session *,
+                                                  netsnmp_pdu *, u_char *,
+                                                  size_t),
+                                   int (*fpost_parse) (netsnmp_session *,
+                                                       netsnmp_pdu *, int),
+                                   int (*fbuild) (netsnmp_session *,
+                                                  netsnmp_pdu *, u_char *,
+                                                  size_t *),
+                                   int (*frbuild) (netsnmp_session *,
+                                                   netsnmp_pdu *,
+                                                   u_char **, size_t *,
+                                                   size_t *),
+                                   int (*fcheck) (u_char *, size_t),
+                                   netsnmp_pdu *(*fcreate_pdu) (struct
+                                                                netsnmp_transport_s
+                                                                *, void *,
+                                                                size_t)
+        );
+    /*
+     * end single session API 
+     */
+
+    /*
+     * generic statistic counters 
+     */
+
+    /*
+     * snmpv3 statistics 
+     */
+
+    /*
+     * mpd stats 
+     */
+#define   STAT_SNMPUNKNOWNSECURITYMODELS     0
+#define   STAT_SNMPINVALIDMSGS               1
+#define   STAT_SNMPUNKNOWNPDUHANDLERS        2
+#define   STAT_MPD_STATS_START               STAT_SNMPUNKNOWNSECURITYMODELS
+#define   STAT_MPD_STATS_END                 STAT_SNMPUNKNOWNPDUHANDLERS
+
+    /*
+     * usm stats 
+     */
+#define   STAT_USMSTATSUNSUPPORTEDSECLEVELS  3
+#define   STAT_USMSTATSNOTINTIMEWINDOWS      4
+#define   STAT_USMSTATSUNKNOWNUSERNAMES      5
+#define   STAT_USMSTATSUNKNOWNENGINEIDS      6
+#define   STAT_USMSTATSWRONGDIGESTS          7
+#define   STAT_USMSTATSDECRYPTIONERRORS      8
+#define   STAT_USM_STATS_START               STAT_USMSTATSUNSUPPORTEDSECLEVELS
+#define   STAT_USM_STATS_END                 STAT_USMSTATSDECRYPTIONERRORS
+
+    /*
+     * snmp counters 
+     */
+#define  STAT_SNMPINPKTS                     9
+#define  STAT_SNMPOUTPKTS                    10
+#define  STAT_SNMPINBADVERSIONS              11
+#define  STAT_SNMPINBADCOMMUNITYNAMES        12
+#define  STAT_SNMPINBADCOMMUNITYUSES         13
+#define  STAT_SNMPINASNPARSEERRS             14
+    /*
+     * #define  STAT_SNMPINBADTYPES              15 
+     */
+#define  STAT_SNMPINTOOBIGS                  16
+#define  STAT_SNMPINNOSUCHNAMES              17
+#define  STAT_SNMPINBADVALUES                18
+#define  STAT_SNMPINREADONLYS                19
+#define  STAT_SNMPINGENERRS                  20
+#define  STAT_SNMPINTOTALREQVARS             21
+#define  STAT_SNMPINTOTALSETVARS             22
+#define  STAT_SNMPINGETREQUESTS              23
+#define  STAT_SNMPINGETNEXTS                 24
+#define  STAT_SNMPINSETREQUESTS              25
+#define  STAT_SNMPINGETRESPONSES             26
+#define  STAT_SNMPINTRAPS                    27
+#define  STAT_SNMPOUTTOOBIGS                 28
+#define  STAT_SNMPOUTNOSUCHNAMES             29
+#define  STAT_SNMPOUTBADVALUES               30
+    /*
+     * #define  STAT_SNMPOUTREADONLYS            31 
+     */
+#define  STAT_SNMPOUTGENERRS                 32
+#define  STAT_SNMPOUTGETREQUESTS             33
+#define  STAT_SNMPOUTGETNEXTS                34
+#define  STAT_SNMPOUTSETREQUESTS             35
+#define  STAT_SNMPOUTGETRESPONSES            36
+#define  STAT_SNMPOUTTRAPS                   37
+    /*
+     * AUTHTRAPENABLE                            38 
+     */
+#define  STAT_SNMPSILENTDROPS		     39
+#define  STAT_SNMPPROXYDROPS		     40
+#define  STAT_SNMP_STATS_START               STAT_SNMPINPKTS
+#define  STAT_SNMP_STATS_END                 STAT_SNMPPROXYDROPS
+
+    /*
+     * target mib counters 
+     */
+#define  STAT_SNMPUNAVAILABLECONTEXTS	     41
+#define  STAT_SNMPUNKNOWNCONTEXTS	     42
+#define  STAT_TARGET_STATS_START             STAT_SNMPUNAVAILABLECONTEXTS
+#define  STAT_TARGET_STATS_END               STAT_SNMPUNKNOWNCONTEXTS
+
+    /*
+     * TSM counters
+     */
+#define  STAT_TSM_SNMPTSMINVALIDCACHES             43
+#define  STAT_TSM_SNMPTSMINADEQUATESECURITYLEVELS  44
+#define  STAT_TSM_SNMPTSMUNKNOWNPREFIXES           45
+#define  STAT_TSM_SNMPTSMINVALIDPREFIXES           46
+#define  STAT_TSM_STATS_START                 STAT_TSM_SNMPTSMINVALIDCACHES
+#define  STAT_TSM_STATS_END                   STAT_TSM_SNMPTSMINVALIDPREFIXES
+
+    /*
+     * TLSTM counters
+     */
+#define  STAT_TLSTM_SNMPTLSTMSESSIONOPENS                      47
+#define  STAT_TLSTM_SNMPTLSTMSESSIONCLIENTCLOSES               48
+#define  STAT_TLSTM_SNMPTLSTMSESSIONOPENERRORS                 49
+#define  STAT_TLSTM_SNMPTLSTMSESSIONACCEPTS                    50
+#define  STAT_TLSTM_SNMPTLSTMSESSIONSERVERCLOSES               51
+#define  STAT_TLSTM_SNMPTLSTMSESSIONNOSESSIONS                 52
+#define  STAT_TLSTM_SNMPTLSTMSESSIONINVALIDCLIENTCERTIFICATES  53
+#define  STAT_TLSTM_SNMPTLSTMSESSIONUNKNOWNSERVERCERTIFICATE   54
+#define  STAT_TLSTM_SNMPTLSTMSESSIONINVALIDSERVERCERTIFICATES  55
+#define  STAT_TLSTM_SNMPTLSTMSESSIONINVALIDCACHES              56
+
+#define  STAT_TLSTM_STATS_START                 STAT_TLSTM_SNMPTLSTMSESSIONOPENS
+#define  STAT_TLSTM_STATS_END          STAT_TLSTM_SNMPTLSTMSESSIONINVALIDCACHES
+
+    /* this previously was end+1; don't know why the +1 is needed;
+       XXX: check the code */
+#define  NETSNMP_STAT_MAX_STATS              (STAT_TLSTM_STATS_END+1)
+/** backwards compatability */
+#define MAX_STATS NETSNMP_STAT_MAX_STATS
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* SNMP_API_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/snmp_assert.h quaggasnmpTrap//include/net-snmp/library/snmp_assert.h
--- quagga-0.99.18//include/net-snmp/library/snmp_assert.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmp_assert.h	2010-11-07 08:35:21.000000000 -0800
@@ -0,0 +1,127 @@
+#ifndef SNMP_ASSERT_H
+#define SNMP_ASSERT_H
+
+#ifdef NETSNMP_USE_ASSERT
+#   include <assert.h>
+#else
+#   include <net-snmp/library/snmp_logging.h>
+#endif
+
+
+/*
+ * MACROs don't need extern "C"
+ */
+
+/*
+ * define __STRING for systems (*cough* sun *cough*) that don't have it
+ */
+#ifndef __STRING
+#  if defined(__STDC__) || defined(_MSC_VER)
+#    define __STRING(x) #x
+#  else
+#    define __STRING(x) "x"
+#  endif /* __STDC__ */
+#endif /* __STRING */
+
+/*
+ * always use assert if requested
+ */
+#ifdef NETSNMP_USE_ASSERT
+/*   void netsnmp_assert( int );*/
+#   define netsnmp_assert(x)  assert( x )
+#   define netsnmp_assert_or_return(x, y)  assert( x )
+#   define netsnmp_assert_or_msgreturn(x, y, z)  assert( x )
+#else
+/*
+ *  if asserts weren't requested, just log, unless NETSNMP_NO_DEBUGGING specified
+ */
+#   ifndef NETSNMP_NO_DEBUGGING
+#      ifdef  NETSNMP_FUNCTION
+#          define NETSNMP_FUNC_FMT " %s()\n"
+#          define NETSNMP_FUNC_PARAM NETSNMP_FUNCTION
+#      else
+#          define NETSNMP_FUNC_FMT "%c"
+#          define NETSNMP_FUNC_PARAM '\n'
+#      endif
+#
+#      define netsnmp_assert(x)  do { \
+              if ( x ) \
+                 ; \
+              else \
+                 snmp_log(LOG_ERR, \
+                          "netsnmp_assert %s failed %s:%d" NETSNMP_FUNC_FMT, \
+                          __STRING(x),__FILE__,__LINE__, \
+                          NETSNMP_FUNC_PARAM); \
+           }while(0)
+#      define netsnmp_assert_or_return(x, y)  do {        \
+              if ( x ) \
+                 ; \
+              else { \
+                 snmp_log(LOG_ERR, \
+                          "netsnmp_assert %s failed %s:%d" NETSNMP_FUNC_FMT, \
+                          __STRING(x),__FILE__,__LINE__, \
+                          NETSNMP_FUNC_PARAM); \
+                 return y; \
+              } \
+           }while(0)
+#      define netsnmp_assert_or_msgreturn(x, y, z)  do {       \
+              if ( x ) \
+                 ; \
+              else { \
+                 snmp_log(LOG_ERR, \
+                          "netsnmp_assert %s failed %s:%d" NETSNMP_FUNC_FMT, \
+                          __STRING(x),__FILE__,__LINE__, \
+                          NETSNMP_FUNC_PARAM); \
+                 snmp_log(LOG_ERR, y); \
+                 return z; \
+              } \
+           }while(0)
+#   else /* NO DEBUGGING */
+#      define netsnmp_assert(x)
+#      define netsnmp_assert_or_return(x, y)  do {        \
+                 if ( x ) \
+                    ; \
+                 else { \
+                    return y; \
+                 } \
+              }while(0)
+#      define netsnmp_assert_or_msgreturn(x, y, z)  do {       \
+                 if ( x ) \
+                    ; \
+                 else { \
+                    return z; \
+                 } \
+              }while(0)
+#   endif /* NO DEBUGGING */
+#endif /* not NETSNMP_USE_ASSERT */
+
+
+#define netsnmp_static_assert(x) \
+    do { switch(0) { case (x): case 0: ; } } while(0)
+
+
+/*
+ *  EXPERIMENTAL macros. May be removed without warning in future
+ * releases. Use at your own risk
+ *
+ * The series of uppercase letters at or near the end of these macros give
+ * an indication of what they do. The letters used are:
+ *
+ *   L  : log a message
+ *   RN : return NULL
+ *   RE : return a specific hardcoded error appropriate for the condition
+ *   RV : return user specified value
+ *
+ */
+#define netsnmp_malloc_check_LRN(ptr)           \
+    netsnmp_assert_or_return( (ptr) != NULL, NULL)
+#define netsnmp_malloc_check_LRE(ptr)           \
+    netsnmp_assert_or_return( (ptr) != NULL, SNMPERR_MALLOC)
+#define netsnmp_malloc_check_LRV(ptr, val)                          \
+    netsnmp_assert_or_return( (ptr) != NULL, val)
+
+#define netsnmp_require_ptr_LRV( ptr, val ) \
+    netsnmp_assert_or_return( (ptr) != NULL, val)
+
+
+#endif /* SNMP_ASSERT_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpCallbackDomain.h quaggasnmpTrap//include/net-snmp/library/snmpCallbackDomain.h
--- quagga-0.99.18//include/net-snmp/library/snmpCallbackDomain.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpCallbackDomain.h	2010-05-30 05:00:00.000000000 -0700
@@ -0,0 +1,73 @@
+#ifndef _SNMPCALLBACKDOMAIN_H
+#define _SNMPCALLBACKDOMAIN_H
+
+#ifndef NET_SNMP_CONFIG_H
+#error "Please include <netsnmp/net-snmp-config.h> before this file"
+#endif
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#ifdef NETSNMP_TRANSPORT_CALLBACK_DOMAIN
+
+#include <net-snmp/types.h>
+#include <net-snmp/library/snmp_transport.h>
+
+typedef struct netsnmp_callback_pass_s {
+    int             return_transport_num;
+    netsnmp_pdu    *pdu;
+    struct netsnmp_callback_pass_s *next;
+} netsnmp_callback_pass;
+
+typedef struct netsnmp_callback_info_s {
+    int             linkedto;
+    void           *parent_data;
+    netsnmp_callback_pass *data;
+    int             callback_num;
+    int             pipefds[2];
+} netsnmp_callback_info;
+
+netsnmp_transport *netsnmp_callback_transport(int);
+int             netsnmp_callback_hook_parse(netsnmp_session * sp,
+                                            netsnmp_pdu *pdu,
+                                            u_char * packetptr,
+                                            size_t len);
+int             netsnmp_callback_hook_build(netsnmp_session * sp,
+                                            netsnmp_pdu *pdu,
+                                            u_char * ptk, size_t * len);
+int             netsnmp_callback_check_packet(u_char * pkt, size_t len);
+netsnmp_pdu    *netsnmp_callback_create_pdu(netsnmp_transport *transport,
+                                            void *opaque, size_t olength);
+NETSNMP_IMPORT
+netsnmp_session *netsnmp_callback_open(int attach_to,
+                                       int (*return_func) (int op,
+                                                           netsnmp_session
+                                                           * session,
+                                                           int reqid,
+                                                           netsnmp_pdu
+                                                           *pdu,
+                                                           void *magic),
+                                       int (*fpre_parse) (netsnmp_session
+                                                          *,
+                                                          struct
+                                                          netsnmp_transport_s
+                                                          *, void *, int),
+                                       int (*fpost_parse) (netsnmp_session
+                                                           *,
+                                                           netsnmp_pdu *,
+                                                           int));
+NETSNMP_IMPORT
+void             netsnmp_clear_callback_list(void);
+
+#else
+
+#define netsnmp_clear_callback_list()
+
+     
+#endif /*NETSNMP_TRANSPORT_CALLBACK_DOMAIN*/
+
+#ifdef __cplusplus
+}
+#endif
+#endif/*_SNMPCALLBACKDOMAIN_H*/
diff -rupN quagga-0.99.18//include/net-snmp/library/snmp_client.h quaggasnmpTrap//include/net-snmp/library/snmp_client.h
--- quagga-0.99.18//include/net-snmp/library/snmp_client.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmp_client.h	2010-10-11 22:35:33.000000000 -0700
@@ -0,0 +1,165 @@
+/*
+ * snmp_client.h
+ */
+/***********************************************************
+	Copyright 1988, 1989 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of CMU not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+******************************************************************/
+
+#ifndef SNMP_CLIENT_H
+#define SNMP_CLIENT_H
+
+#include <net-snmp/types.h>
+#include <net-snmp/varbind_api.h>
+#include <net-snmp/pdu_api.h>
+#include <net-snmp/output_api.h>
+#include <net-snmp/session_api.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+
+    struct snmp_pdu;
+    struct snmp_session;
+    struct variable_list;
+
+    struct synch_state {
+        int             waiting;
+        int             status;
+        /*
+         * status codes 
+         */
+#define STAT_SUCCESS	0
+#define STAT_ERROR	1
+#define STAT_TIMEOUT 2
+        int             reqid;
+        netsnmp_pdu    *pdu;
+    };
+
+    NETSNMP_IMPORT
+    void            snmp_replace_var_types(netsnmp_variable_list * vbl,
+                                           u_char old_type,
+                                           u_char new_type);
+    NETSNMP_IMPORT
+    void            snmp_reset_var_buffers(netsnmp_variable_list * var);
+    void            snmp_reset_var_types(netsnmp_variable_list * vbl,
+                                         u_char new_type);
+    NETSNMP_IMPORT
+    int             count_varbinds(netsnmp_variable_list * var_ptr);
+    NETSNMP_IMPORT
+    int             count_varbinds_of_type(netsnmp_variable_list * var_ptr,
+                                           u_char type);
+    netsnmp_variable_list *find_varbind_of_type(netsnmp_variable_list *
+                                                var_ptr, u_char type);
+    NETSNMP_IMPORT
+    netsnmp_variable_list *find_varbind_in_list(netsnmp_variable_list *vblist,
+                                                const oid *name, size_t len);
+
+    netsnmp_pdu    *snmp_split_pdu(netsnmp_pdu *, int skipCount,
+                                   int copyCount);
+
+    unsigned long   snmp_varbind_len(netsnmp_pdu *pdu);
+    NETSNMP_IMPORT
+    int             snmp_clone_var(netsnmp_variable_list *,
+                                   netsnmp_variable_list *);
+    NETSNMP_IMPORT
+    int             snmp_synch_response_cb(netsnmp_session *,
+                                           netsnmp_pdu *, netsnmp_pdu **,
+                                           snmp_callback);
+    NETSNMP_IMPORT
+    int             snmp_clone_mem(void **, const void *, unsigned);
+
+
+NETSNMP_IMPORT
+void              netsnmp_query_set_default_session(netsnmp_session *);
+NETSNMP_IMPORT
+netsnmp_session * netsnmp_query_get_default_session_unchecked( void );
+NETSNMP_IMPORT
+netsnmp_session * netsnmp_query_get_default_session( void );
+NETSNMP_IMPORT
+int netsnmp_query_get(     netsnmp_variable_list *, netsnmp_session *);
+NETSNMP_IMPORT
+int netsnmp_query_getnext( netsnmp_variable_list *, netsnmp_session *);
+NETSNMP_IMPORT
+int netsnmp_query_walk(    netsnmp_variable_list *, netsnmp_session *);
+NETSNMP_IMPORT
+int netsnmp_query_set(     netsnmp_variable_list *, netsnmp_session *);
+
+/** **************************************************************************
+ *
+ * state machine
+ *
+ */
+    /** forward declare */
+    struct netsnmp_state_machine_step_s;
+    struct netsnmp_state_machine_input_s;
+
+    /** state machine process */
+    typedef int (netsnmp_state_machine_func)(struct netsnmp_state_machine_input_s *input,
+                                             struct netsnmp_state_machine_step_s *step);
+
+    typedef struct netsnmp_state_machine_step_s {
+
+        const char   *name; /* primarily for logging/debugging */
+        u_int         sm_flags;
+        
+        netsnmp_state_machine_func *run;
+        int                         result; /* return code for this step */
+        
+        
+        struct netsnmp_state_machine_step_s *on_success;
+        struct netsnmp_state_machine_step_s *on_error;
+        
+        /*
+         * user fields (not touched by state machine functions)
+         */
+        u_int         flags;
+        void         *step_context;
+        
+    } netsnmp_state_machine_step;
+
+    typedef struct netsnmp_state_machine_input_s {
+        const char                  *name;
+        int                          steps_so_far;
+        netsnmp_state_machine_step  *steps;
+        netsnmp_state_machine_step  *cleanup;
+        netsnmp_state_machine_step  *last_run;
+
+        /*
+         * user fields (not touched by state machine functions)
+         */
+        void         *input_context;
+
+    } netsnmp_state_machine_input;
+
+
+    NETSNMP_IMPORT int
+    netsnmp_state_machine_run( netsnmp_state_machine_input *input );
+
+    NETSNMP_IMPORT int
+    netsnmp_row_create(netsnmp_session *sess, netsnmp_variable_list *vars,
+                       int row_status_index);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* SNMP_CLIENT_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/snmp_debug.h quaggasnmpTrap//include/net-snmp/library/snmp_debug.h
--- quagga-0.99.18//include/net-snmp/library/snmp_debug.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmp_debug.h	2010-10-11 22:35:33.000000000 -0700
@@ -0,0 +1,242 @@
+#ifndef SNMP_DEBUG_H
+#define SNMP_DEBUG_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    /*
+     * snmp_debug.h:
+     * 
+     * - prototypes for snmp debugging routines.
+     * - easy to use macros to wrap around the functions.  This also provides
+     * the ability to remove debugging code easily from the applications at
+     * compile time.
+     */
+
+
+    /*
+     * These functions should not be used, if at all possible.  Instead, use
+     * the macros below. 
+     */
+#if !defined(__GNUC__) || __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 8)
+#define NETSNMP_ATTRIBUTE_FORMAT(type, formatArg, firstArg)
+#else
+#define NETSNMP_ATTRIBUTE_FORMAT(type, formatArg, firstArg) \
+  __attribute__((__format__( __ ## type ## __, formatArg, firstArg )))
+#endif
+
+    NETSNMP_IMPORT
+    void            debugmsg(const char *token, const char *format, ...)
+                        NETSNMP_ATTRIBUTE_FORMAT(printf, 2, 3);
+    NETSNMP_IMPORT
+    void            debugmsgtoken(const char *token, const char *format,
+                                  ...)
+                        NETSNMP_ATTRIBUTE_FORMAT(printf, 2, 3);
+    void            debug_combo_nc(const char *token, const char *format,
+                                   ...)
+                        NETSNMP_ATTRIBUTE_FORMAT(printf, 2, 3);
+
+#undef NETSNMP_ATTRIBUTE_FORMAT
+
+    NETSNMP_IMPORT
+    void            debugmsg_oid(const char *token, const oid * theoid,
+                                 size_t len);
+    void            debugmsg_suboid(const char *token, const oid * theoid,
+                                    size_t len);
+    NETSNMP_IMPORT
+    void            debugmsg_var(const char *token,
+                                 netsnmp_variable_list * var);
+    NETSNMP_IMPORT
+    void            debugmsg_oidrange(const char *token,
+                                      const oid * theoid, size_t len,
+                                      size_t var_subid, oid range_ubound);
+    NETSNMP_IMPORT
+    void            debugmsg_hex(const char *token, const u_char * thedata,
+                                 size_t len);
+    NETSNMP_IMPORT
+    void            debugmsg_hextli(const char *token, const u_char * thedata,
+                                    size_t len);
+    NETSNMP_IMPORT
+    void            debug_indent_add(int amount);
+    NETSNMP_IMPORT
+    int             debug_indent_get(void);
+    /*
+     * What is said above is true for this function as well. Further this
+     * function is deprecated and only provided for backwards compatibility.
+     * Please use "%*s", debug_indent_get(), "" if you used this one before.
+     */
+    NETSNMP_IMPORT
+    const char     *debug_indent(void);
+
+    /*
+     * Use these macros instead of the functions above to allow them to be
+     * re-defined at compile time to NOP for speed optimization.
+     * 
+     * They need to be called enclosing all the arguments in a single set of ()s.
+     * Example:
+     * DEBUGMSGTL(("token", "debugging of something %s related\n", "snmp"));
+     * 
+     * Usage:
+     * All of the functions take a "token" argument that helps determine when
+     * the output in question should be printed.  See the snmpcmd.1 manual page
+     * on the -D flag to turn on/off output for a given token on the command line.
+     * 
+     * DEBUGMSG((token, format, ...)):      equivalent to printf(format, ...)
+     * (if "token" debugging output
+     * is requested by the user)
+     * 
+     * DEBUGMSGT((token, format, ...)):     equivalent to DEBUGMSG, but prints
+     * "token: " at the beginning of the
+     * line for you.
+     * 
+     * DEBUGTRACE                           Insert this token anywhere you want
+     * tracing output displayed when the
+     * "trace" debugging token is selected.
+     * 
+     * DEBUGMSGL((token, format, ...)):     equivalent to DEBUGMSG, but includes
+     * DEBUGTRACE debugging line just before
+     * yours.
+     * 
+     * DEBUGMSGTL((token, format, ...)):    Same as DEBUGMSGL and DEBUGMSGT
+     * combined.
+     * 
+     * Important:
+     * It is considered best if you use DEBUGMSGTL() everywhere possible, as it
+     * gives the nicest format output and provides tracing support just before
+     * every debugging statement output.
+     * 
+     * To print multiple pieces to a single line in one call, use:
+     * 
+     * DEBUGMSGTL(("token", "line part 1"));
+     * DEBUGMSG  (("token", " and part 2\n"));
+     * 
+     * to get:
+     * 
+     * token: line part 1 and part 2
+     * 
+     * as debugging output.
+     *
+     *
+     * Each of these macros also have a version with a suffix of '_NC'. The
+     * NC suffix stands for 'No Check', which means that no check will be
+     * performed to see if debug is enabled or if the token has been turned
+     * on. These NC versions are intended for use within a DEBUG_IF {} block,
+     * where the debug/token check has already been performed.
+     */
+
+#ifndef NETSNMP_NO_DEBUGGING       /* make sure we're wanted */
+
+    /*
+     * define two macros : one macro with, one without,
+     *                     a test if debugging is enabled.
+     * 
+     * Generally, use the macro with _DBG_IF_
+     */
+
+/******************* Start private macros ************************/
+#define _DBG_IF_            snmp_get_do_debugging()
+#define DEBUGIF(x)         if (_DBG_IF_ && debug_is_token_registered(x) == SNMPERR_SUCCESS)
+
+#define __DBGMSGT(x)     debugmsgtoken x,  debugmsg x
+#define __DBGMSG_NC(x)   debugmsg x
+#define __DBGMSGT_NC(x)  debug_combo_nc x
+#define __DBGMSGL_NC(x)  __DBGTRACE; debugmsg x
+#define __DBGMSGTL_NC(x) __DBGTRACE; debug_combo_nc x
+
+#ifdef  NETSNMP_FUNCTION
+#define __DBGTRACE       __DBGMSGT(("trace","%s(): %s, %d:\n",\
+				NETSNMP_FUNCTION,__FILE__,__LINE__))
+#define __DBGTRACETOK(x) __DBGMSGT((x,"%s(): %s, %d:\n",       \
+                                    NETSNMP_FUNCTION,__FILE__,__LINE__))
+#else
+#define __DBGTRACE       __DBGMSGT(("trace"," %s, %d:\n", __FILE__,__LINE__))
+#define __DBGTRACETOK(x) __DBGMSGT((x," %s, %d:\n", __FILE__,__LINE__))
+#endif
+
+#define __DBGMSGL(x)     __DBGTRACE, debugmsg x
+#define __DBGMSGTL(x)    __DBGTRACE, debugmsgtoken x, debugmsg x
+#define __DBGMSGOID(x)     debugmsg_oid x
+#define __DBGMSGSUBOID(x)  debugmsg_suboid x
+#define __DBGMSGVAR(x)     debugmsg_var x
+#define __DBGMSGOIDRANGE(x) debugmsg_oidrange x
+#define __DBGMSGHEX(x)     debugmsg_hex x
+#define __DBGMSGHEXTLI(x)  debugmsg_hextli x
+#define __DBGINDENT()      debug_indent_get()
+#define __DBGINDENTADD(x)  debug_indent_add(x)
+#define __DBGINDENTMORE()  debug_indent_add(2)
+#define __DBGINDENTLESS()  debug_indent_add(-2)
+#define __DBGPRINTINDENT(token) __DBGMSGTL((token, "%*s", __DBGINDENT(), ""))
+
+#define __DBGDUMPHEADER(token,x) \
+        __DBGPRINTINDENT("dumph_" token); \
+        debugmsg("dumph_" token,x); \
+        if (debug_is_token_registered("dumpx" token) == SNMPERR_SUCCESS ||    \
+            debug_is_token_registered("dumpv" token) == SNMPERR_SUCCESS ||    \
+            (debug_is_token_registered("dumpx_" token) != SNMPERR_SUCCESS &&  \
+             debug_is_token_registered("dumpv_" token) != SNMPERR_SUCCESS)) { \
+            debugmsg("dumph_" token,"\n"); \
+        } else { \
+            debugmsg("dumph_" token,"  "); \
+        } \
+        __DBGINDENTMORE()
+
+#define __DBGDUMPSECTION(token,x) \
+        __DBGPRINTINDENT("dumph_" token); \
+        debugmsg("dumph_" token,"%s\n",x);\
+        __DBGINDENTMORE()
+
+#define __DBGDUMPSETUP(token,buf,len) \
+        debugmsg("dumpx" token, "dumpx_%s:%*s", token, __DBGINDENT(), ""); \
+        __DBGMSGHEX(("dumpx_" token,buf,len)); \
+        if (debug_is_token_registered("dumpv" token) == SNMPERR_SUCCESS || \
+            debug_is_token_registered("dumpv_" token) != SNMPERR_SUCCESS) { \
+            debugmsg("dumpx_" token,"\n"); \
+        } else { \
+            debugmsg("dumpx_" token,"  "); \
+        } \
+        debugmsg("dumpv" token, "dumpv_%s:%*s", token, __DBGINDENT(), "");
+
+/******************* End   private macros ************************/
+/*****************************************************************/
+#endif /* NETSNMP_NO_DEBUGGING */
+
+#ifdef __cplusplus
+}
+#endif
+
+    /* Public macros moved to top-level API header file */
+#include <net-snmp/output_api.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    void            snmp_debug_init(void);
+
+#define MAX_DEBUG_TOKENS 256
+#define MAX_DEBUG_TOKEN_LEN 128
+#define DEBUG_TOKEN_DELIMITER ","
+#define DEBUG_ALWAYS_TOKEN "all"
+
+#ifndef NETSNMP_NO_DEBUGGING
+
+/*
+ * internal:
+ * You probably shouldn't be using this information unless the word
+ * "expert" applies to you.  I know it looks tempting.
+ */
+typedef struct netsnmp_token_descr_s {
+    char *token_name;
+    char  enabled;
+} netsnmp_token_descr;
+
+NETSNMP_IMPORT int                 debug_num_tokens;
+NETSNMP_IMPORT netsnmp_token_descr dbg_tokens[MAX_DEBUG_TOKENS];
+
+#endif /* NETSNMP_NO_DEBUGGING */
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* SNMP_DEBUG_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpDTLSUDPDomain.h quaggasnmpTrap//include/net-snmp/library/snmpDTLSUDPDomain.h
--- quagga-0.99.18//include/net-snmp/library/snmpDTLSUDPDomain.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpDTLSUDPDomain.h	2010-05-30 05:00:00.000000000 -0700
@@ -0,0 +1,41 @@
+#ifndef _SNMPDTLSUDPDOMAIN_H
+#define _SNMPDTLSUDPDOMAIN_H
+
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+
+config_require(UDP)
+config_require(TLSBase)
+
+#include <net-snmp/types.h>
+#include <net-snmp/library/snmp_transport.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#define TRANSPORT_DOMAIN_DTLS_UDP_IP	1,3,6,1,6,1,9
+NETSNMP_IMPORT oid netsnmpDTLSUDPDomain[7];
+NETSNMP_IMPORT size_t netsnmpDTLSUDPDomain_len;
+
+netsnmp_transport *netsnmp_dtlsudp_transport(struct sockaddr_in *addr,
+                                             int local);
+
+
+/*
+ * Register any configuration tokens specific to the agent.  
+ */
+
+void            netsnmp_dtlsudp_agent_config_tokens_register(void);
+
+/*
+ * "Constructor" for transport domain object.  
+ */
+
+void            netsnmp_dtlsudp_ctor(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif/*_SNMPDTLSUDPDOMAIN_H*/
diff -rupN quagga-0.99.18//include/net-snmp/library/snmp_enum.h quaggasnmpTrap//include/net-snmp/library/snmp_enum.h
--- quagga-0.99.18//include/net-snmp/library/snmp_enum.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmp_enum.h	2010-10-12 07:02:45.000000000 -0700
@@ -0,0 +1,114 @@
+#ifndef SNMP_ENUM_H
+#define SNMP_ENUM_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    struct snmp_enum_list {
+        struct snmp_enum_list *next;
+        int             value;
+        char           *label;
+    };
+
+#define SE_MAX_IDS 5
+#define SE_MAX_SUBIDS 32        /* needs to be a multiple of 8 */
+
+    /*
+     * begin storage definitions 
+     */
+    /*
+     * These definitions correspond with the "storid" argument to the API 
+     */
+#define SE_LIBRARY_ID     0
+#define SE_MIB_ID         1
+#define SE_APPLICATION_ID 2
+#define SE_ASSIGNED_ID    3
+
+    /*
+     * library specific enum locations 
+     */
+
+    /*
+     * error codes 
+     */
+#define SE_OK            0
+#define SE_NOMEM         1
+#define SE_ALREADY_THERE 2
+#define SE_DNE           -2
+
+    int             init_snmp_enum(const char *type);
+    struct snmp_enum_list *se_find_list(unsigned int major,
+                                        unsigned int minor);
+    struct snmp_enum_list *se_find_slist(const char *listname);
+    int             se_store_in_list(struct snmp_enum_list *,
+                                     unsigned int major, unsigned int minor);
+    int             se_find_value(unsigned int major, unsigned int minor,
+                                  const char *label);
+    int             se_find_free_value(unsigned int major, unsigned int minor);
+    char           *se_find_label(unsigned int major, unsigned int minor,
+                                  int value);
+    /**
+     * Add the pair (label, value) to the list (major, minor). Transfers
+     * ownership of the memory pointed to by label to the list:
+     * clear_snmp_enum() deallocates that memory.
+     */
+    int             se_add_pair(unsigned int major, unsigned int minor,
+                                char *label, int value);
+
+    /*
+     * finds a list of enums in a list of enum structs associated by a name. 
+     */
+    /*
+     * find a list, and then operate on that list
+     *   ( direct methods further below if you already have the list pointer)
+     */
+    NETSNMP_IMPORT
+    char           *se_find_label_in_slist(const char *listname,
+                                           int value);
+    NETSNMP_IMPORT
+    int             se_find_value_in_slist(const char *listname,
+                                           const char *label);
+    int             se_find_free_value_in_slist(const char *listname);
+    /**
+     * Add the pair (label, value) to the slist with name listname. Transfers
+     * ownership of the memory pointed to by label to the list:
+     * clear_snmp_enum() deallocates that memory.
+     */
+    NETSNMP_IMPORT
+    int             se_add_pair_to_slist(const char *listname, char *label,
+                                         int value);
+
+    /*
+     * operates directly on a possibly external list 
+     */
+    char           *se_find_label_in_list(struct snmp_enum_list *list,
+                                          int value);
+    int             se_find_value_in_list(struct snmp_enum_list *list,
+                                          const char *label);
+    int             se_find_free_value_in_list(struct snmp_enum_list *list);
+    int             se_add_pair_to_list(struct snmp_enum_list **list,
+                                        char *label, int value);
+
+    /*
+     * Persistent enumeration lists
+     */
+    void            se_store_enum_list(struct snmp_enum_list *new_list,
+                                       const char *token, char *type);
+    void            se_store_list(unsigned int major, unsigned int minor, char *type);
+    void            se_clear_slist(const char *listname);
+    void            se_store_slist(const char *listname, char *type);
+    int             se_store_slist_callback(int majorID, int minorID,
+                                           void *serverargs, void *clientargs);
+    void            se_read_conf(const char *word, char *cptr);
+    /**
+     * Deallocate the memory allocated by init_snmp_enum(): remove all key/value
+     * pairs stored by se_add_*() calls.
+     */
+    NETSNMP_IMPORT
+    void            clear_snmp_enum(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* SNMP_ENUM_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/snmp.h quaggasnmpTrap//include/net-snmp/library/snmp.h
--- quagga-0.99.18//include/net-snmp/library/snmp.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmp.h	2010-06-10 12:46:42.000000000 -0700
@@ -0,0 +1,351 @@
+#ifndef SNMP_H
+#define SNMP_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+    /*
+     * Definitions for the Simple Network Management Protocol (RFC 1067).
+     *
+     *
+     */
+/***********************************************************
+	Copyright 1988, 1989 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of CMU not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+******************************************************************/
+
+
+#define SNMP_PORT	    161 /* standard UDP port for SNMP agents
+                                 * to receive requests messages */
+#define SNMP_TRAP_PORT	    162 /* standard UDP port for SNMP
+                                 * managers to receive notificaion
+                                 * (trap and inform) messages */
+
+#define SNMP_MAX_LEN	    1500        /* typical maximum message size */
+#define SNMP_MIN_MAX_LEN    484 /* minimum maximum message size */
+
+    /*
+     * SNMP versions 
+     */
+    /*
+     * There currently exists the following SNMP versions.
+     * * (Note that only SNMPv1 is in widespread usage, and this code supports
+     * *  only SNMPv1, SNMPv2c, and SNMPv3.
+     * *
+     * *  SNMPv1 - (full) the original version, defined by RFC 1157
+     * *  SNMPsec - (historic) the first attempt to add strong security
+     * *             to SNMPv1, defined by RFCs 1351, 1352, and 1353.
+     * *  SNMPv2p - (historic) party-based SNMP, which was another
+     * *             attempt to add strong security to SNMP, defined
+     * *             by RFCs 1441, 1445, 1446, 1448, and 1449.
+     * *  SNMPv2c - (experimental) community string-based SNMPv2,
+     * *             which was an attempt to combine the protocol
+     * *             operations of SNMPv2 with the security of
+     * *             SNMPv1, defined by RFCs 1901, 1905, and 1906.
+     * *  SNMPv2u - (experimental) user-based SNMPv2, which provided
+     * *             security based on user names and protocol
+     * *             operations of SNMPv2, defined by RFCs 1905,
+     * *             1909, and 1910.
+     * *  SNMPv2* (or SNMPv2star) - (experimental) an attempt to add the
+     * *             best features of SNMPv2p and SNMPv2u, defined
+     * *             by unpublished documents found at WEB site
+     * *             owned by SNMP Research (a leading SNMP vendor)
+     * *  SNMPv3 - the current attempt by the IETF working group to merge
+     * *             the SNMPv2u and SNMPv2* proposals into a more widly
+     * *             accepted SNMPv3.  It is defined by not yet published
+     * *             documents of the IETF SNMPv3 WG.
+     * *
+     * * SNMPv1, SNMPv2c, SNMPv2u, and SNMPv3 messages have a common
+     * * form, which is an ASN.1 sequence containing a message version 
+     * * field, followed by version dependent fields.
+     * * SNMPsec, SNMPv2p, and SNMPv2* messages have a common form,
+     * * which is a tagged ASN.1 context specific sequence containing
+     * * message dependent fields.
+     * *
+     * * In the #defines for the message versions below, the value
+     * * for SNMPv1, SNMPv2c, SNMPv2u, and SNMPv3 messages is the
+     * * value of the message version field. Since SNMPsec, SNMPv2p,
+     * * and SNMPv2* messages do not have a message version field,
+     * * the value in the defines for them is choosen to be a large
+     * * arbitrary number.
+     * *
+     * * Note that many of the version ID's are defined below purely for
+     * * documentational purposes.  At this point the only protocol planned
+     * * for future implementations is SNMP3, as the other v2 protocols will
+     * * not be supported by the IETF (ie, v2u, v2sec, v2star) or used by
+     * * the snmp community at large (at the time of this writing).  
+     */
+
+    /*
+     * versions based on version field 
+     */
+#ifndef NETSNMP_DISABLE_SNMPV1
+#define SNMP_VERSION_1	   0
+#endif
+#ifndef NETSNMP_DISABLE_SNMPV2C
+#define SNMP_VERSION_2c    1
+#endif
+#define SNMP_VERSION_2u    2    /* not (will never be) supported by this code */
+#define SNMP_VERSION_3     3
+
+    /*
+     * versions not based on a version field 
+     */
+#define SNMP_VERSION_sec   128  /* not (will never be) supported by this code */
+#define SNMP_VERSION_2p	   129  /* no longer supported by this code (> 4.0) */
+#define SNMP_VERSION_2star 130  /* not (will never be) supported by this code */
+
+    /*
+     * PDU types in SNMPv1, SNMPsec, SNMPv2p, SNMPv2c, SNMPv2u, SNMPv2*, and SNMPv3 
+     */
+#define SNMP_MSG_GET        (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x0) /* a0=160 */
+#define SNMP_MSG_GETNEXT    (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x1) /* a1=161 */
+#define SNMP_MSG_RESPONSE   (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x2) /* a2=162 */
+#define SNMP_MSG_SET        (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x3) /* a3=163 */
+
+    /*
+     * PDU types in SNMPv1 and SNMPsec 
+     */
+#define SNMP_MSG_TRAP       (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x4) /* a4=164 */
+
+    /*
+     * PDU types in SNMPv2p, SNMPv2c, SNMPv2u, SNMPv2*, and SNMPv3 
+     */
+#define SNMP_MSG_GETBULK    (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x5) /* a5=165 */
+#define SNMP_MSG_INFORM     (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x6) /* a6=166 */
+#define SNMP_MSG_TRAP2      (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x7) /* a7=167 */
+
+    /*
+     * PDU types in SNMPv2u, SNMPv2*, and SNMPv3 
+     */
+#define SNMP_MSG_REPORT     (ASN_CONTEXT | ASN_CONSTRUCTOR | 0x8) /* a8=168 */
+
+    /*
+     * internal modes that should never be used by the protocol for the
+     * pdu type.
+     *
+     * All modes < 128 are reserved for SET requests.
+     */
+#define SNMP_MSG_INTERNAL_SET_BEGIN        -1
+#define SNMP_MSG_INTERNAL_SET_RESERVE1     0    /* these should match snmp.h */
+#define SNMP_MSG_INTERNAL_SET_RESERVE2     1
+#define SNMP_MSG_INTERNAL_SET_ACTION       2
+#define SNMP_MSG_INTERNAL_SET_COMMIT       3
+#define SNMP_MSG_INTERNAL_SET_FREE         4
+#define SNMP_MSG_INTERNAL_SET_UNDO         5
+#define SNMP_MSG_INTERNAL_SET_MAX          6
+
+#define SNMP_MSG_INTERNAL_CHECK_VALUE           17
+#define SNMP_MSG_INTERNAL_ROW_CREATE            18
+#define SNMP_MSG_INTERNAL_UNDO_SETUP            19
+#define SNMP_MSG_INTERNAL_SET_VALUE             20
+#define SNMP_MSG_INTERNAL_CHECK_CONSISTENCY     21
+#define SNMP_MSG_INTERNAL_UNDO_SET              22
+#define SNMP_MSG_INTERNAL_COMMIT                23
+#define SNMP_MSG_INTERNAL_UNDO_COMMIT           24
+#define SNMP_MSG_INTERNAL_IRREVERSIBLE_COMMIT   25
+#define SNMP_MSG_INTERNAL_UNDO_CLEANUP          26
+
+    /*
+     * modes > 128 for non sets.
+     * Note that 160-168 overlap with SNMP ASN1 pdu types
+     */
+#define SNMP_MSG_INTERNAL_PRE_REQUEST           128
+#define SNMP_MSG_INTERNAL_OBJECT_LOOKUP         129
+#define SNMP_MSG_INTERNAL_POST_REQUEST          130
+#define SNMP_MSG_INTERNAL_GET_STASH             131
+
+    /*
+     * test for member of Confirmed Class i.e., reportable 
+     */
+#define SNMP_CMD_CONFIRMED(c) (c == SNMP_MSG_INFORM || c == SNMP_MSG_GETBULK ||\
+                               c == SNMP_MSG_GETNEXT || c == SNMP_MSG_GET || \
+                               c == SNMP_MSG_SET)
+
+    /*
+     * Exception values for SNMPv2p, SNMPv2c, SNMPv2u, SNMPv2*, and SNMPv3 
+     */
+#define SNMP_NOSUCHOBJECT    (ASN_CONTEXT | ASN_PRIMITIVE | 0x0) /* 80=128 */
+#define SNMP_NOSUCHINSTANCE  (ASN_CONTEXT | ASN_PRIMITIVE | 0x1) /* 81=129 */
+#define SNMP_ENDOFMIBVIEW    (ASN_CONTEXT | ASN_PRIMITIVE | 0x2) /* 82=130 */
+
+    /*
+     * Error codes (the value of the field error-status in PDUs) 
+     */
+
+    /*
+     * in SNMPv1, SNMPsec, SNMPv2p, SNMPv2c, SNMPv2u, SNMPv2*, and SNMPv3 PDUs 
+     */
+#define SNMP_ERR_NOERROR                (0)     /* XXX  Used only for PDUs? */
+#define SNMP_ERR_TOOBIG	                (1)
+#define SNMP_ERR_NOSUCHNAME             (2)
+#define SNMP_ERR_BADVALUE               (3)
+#define SNMP_ERR_READONLY               (4)
+#define SNMP_ERR_GENERR	                (5)
+
+    /*
+     * in SNMPv2p, SNMPv2c, SNMPv2u, SNMPv2*, and SNMPv3 PDUs 
+     */
+#define SNMP_ERR_NOACCESS		(6)
+#define SNMP_ERR_WRONGTYPE		(7)
+#define SNMP_ERR_WRONGLENGTH		(8)
+#define SNMP_ERR_WRONGENCODING		(9)
+#define SNMP_ERR_WRONGVALUE		(10)
+#define SNMP_ERR_NOCREATION		(11)
+#define SNMP_ERR_INCONSISTENTVALUE	(12)
+#define SNMP_ERR_RESOURCEUNAVAILABLE	(13)
+#define SNMP_ERR_COMMITFAILED		(14)
+#define SNMP_ERR_UNDOFAILED		(15)
+#define SNMP_ERR_AUTHORIZATIONERROR	(16)
+#define SNMP_ERR_NOTWRITABLE		(17)
+
+    /*
+     * in SNMPv2c, SNMPv2u, SNMPv2*, and SNMPv3 PDUs 
+     */
+#define SNMP_ERR_INCONSISTENTNAME	(18)
+
+#define MAX_SNMP_ERR	18
+
+#define SNMP_VALIDATE_ERR(x)  ( (x > MAX_SNMP_ERR) ? \
+                                   SNMP_ERR_GENERR : \
+                                   (x < SNMP_ERR_NOERROR) ? \
+                                      SNMP_ERR_GENERR : \
+                                      x )
+
+    /*
+     * values of the generic-trap field in trap PDUs 
+     */
+#define SNMP_TRAP_COLDSTART		(0)
+#define SNMP_TRAP_WARMSTART		(1)
+#define SNMP_TRAP_LINKDOWN		(2)
+#define SNMP_TRAP_LINKUP		(3)
+#define SNMP_TRAP_AUTHFAIL		(4)
+#define SNMP_TRAP_EGPNEIGHBORLOSS	(5)
+#define SNMP_TRAP_ENTERPRISESPECIFIC	(6)
+
+    /*
+     * row status values 
+     */
+#define SNMP_ROW_NONEXISTENT		0
+#define SNMP_ROW_ACTIVE			1
+#define SNMP_ROW_NOTINSERVICE		2
+#define SNMP_ROW_NOTREADY		3
+#define SNMP_ROW_CREATEANDGO		4
+#define SNMP_ROW_CREATEANDWAIT		5
+#define SNMP_ROW_DESTROY		6
+
+    /*
+     * row storage values 
+     */
+#define SNMP_STORAGE_NONE  0
+#define SNMP_STORAGE_OTHER		1
+#define SNMP_STORAGE_VOLATILE		2
+#define SNMP_STORAGE_NONVOLATILE	3
+#define SNMP_STORAGE_PERMANENT		4
+#define SNMP_STORAGE_READONLY		5
+
+    /*
+     * message processing models 
+     */
+#define SNMP_MP_MODEL_SNMPv1		0
+#define SNMP_MP_MODEL_SNMPv2c		1
+#define SNMP_MP_MODEL_SNMPv2u		2
+#define SNMP_MP_MODEL_SNMPv3		3
+#define SNMP_MP_MODEL_SNMPv2p		256
+
+    /*
+     * security values 
+     */
+#define SNMP_SEC_MODEL_ANY		0
+#define SNMP_SEC_MODEL_SNMPv1		1
+#define SNMP_SEC_MODEL_SNMPv2c		2
+#define SNMP_SEC_MODEL_USM		3
+#define SNMP_SEC_MODEL_TSM              4
+#define SNMP_SEC_MODEL_SNMPv2p		256
+
+#define SNMP_SEC_LEVEL_NOAUTH		1
+#define SNMP_SEC_LEVEL_AUTHNOPRIV	2
+#define SNMP_SEC_LEVEL_AUTHPRIV		3
+
+#define SNMP_MSG_FLAG_AUTH_BIT          0x01
+#define SNMP_MSG_FLAG_PRIV_BIT          0x02
+#define SNMP_MSG_FLAG_RPRT_BIT          0x04
+
+    /*
+     * control PDU handling characteristics 
+     */
+#define UCD_MSG_FLAG_RESPONSE_PDU            0x100
+#define UCD_MSG_FLAG_EXPECT_RESPONSE         0x200
+#define UCD_MSG_FLAG_FORCE_PDU_COPY          0x400
+#define UCD_MSG_FLAG_ALWAYS_IN_VIEW          0x800
+#define UCD_MSG_FLAG_PDU_TIMEOUT            0x1000
+#define UCD_MSG_FLAG_ONE_PASS_ONLY          0x2000
+#define UCD_MSG_FLAG_TUNNELED               0x4000
+
+    /*
+     * view status 
+     */
+#define SNMP_VIEW_INCLUDED		1
+#define SNMP_VIEW_EXCLUDED		2
+
+    /*
+     * basic oid values 
+     */
+#define SNMP_OID_INTERNET		1, 3, 6, 1
+#define SNMP_OID_ENTERPRISES		SNMP_OID_INTERNET, 4, 1
+#define SNMP_OID_MIB2			SNMP_OID_INTERNET, 2, 1
+#define SNMP_OID_SNMPV2			SNMP_OID_INTERNET, 6
+#define SNMP_OID_SNMPMODULES		SNMP_OID_SNMPV2, 3
+
+    /*
+     * lengths as defined by TCs 
+     */
+#define SNMPADMINLENGTH 255
+
+
+    NETSNMP_IMPORT
+    char           *uptime_string(u_long, char *);
+    char           *uptime_string_n(u_long, char *, size_t);
+    NETSNMP_IMPORT
+    void            xdump(const void *, size_t, const char *);
+    NETSNMP_IMPORT
+    u_char         *snmp_parse_var_op(u_char *, oid *, size_t *, u_char *,
+                                      size_t *, u_char **, size_t *);
+    NETSNMP_IMPORT
+    u_char         *snmp_build_var_op(u_char *, oid *, size_t *, u_char,
+                                      size_t, u_char *, size_t *);
+
+
+#ifdef NETSNMP_USE_REVERSE_ASNENCODING
+    int             snmp_realloc_rbuild_var_op(u_char ** pkt,
+                                               size_t * pkt_len,
+                                               size_t * offset,
+                                               int allow_realloc,
+                                               const oid * name,
+                                               size_t * name_len,
+                                               u_char value_type,
+                                               u_char * value,
+                                               size_t value_length);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* SNMP_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/snmp_impl.h quaggasnmpTrap//include/net-snmp/library/snmp_impl.h
--- quagga-0.99.18//include/net-snmp/library/snmp_impl.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmp_impl.h	2008-10-21 14:10:43.000000000 -0700
@@ -0,0 +1,146 @@
+#ifndef SNMP_IMPL_H
+#define SNMP_IMPL_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+    /*
+     * * file: snmp_impl.h
+     */
+
+    /*
+     * Definitions for SNMP implementation.
+     *
+     *
+     */
+/***********************************************************
+	Copyright 1988, 1989 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its 
+documentation for any purpose and without fee is hereby granted, 
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in 
+supporting documentation, and that the name of CMU not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.  
+
+CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+******************************************************************/
+
+#include<stdio.h>
+#include<net-snmp/types.h>      /* for 'u_char', etc */
+
+#define COMMUNITY_MAX_LEN	256
+
+    /*
+     * Space for character representation of an object identifier 
+     */
+#define SPRINT_MAX_LEN		2560
+
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+#ifndef TRUE
+#define TRUE	1
+#endif
+#ifndef FALSE
+#define FALSE	0
+#endif
+
+#define READ	    1
+#define WRITE	    0
+
+#define RESERVE1    0
+#define RESERVE2    1
+#define ACTION	    2
+#define COMMIT      3
+#define FREE        4
+#define UNDO        5
+#define FINISHED_SUCCESS        9
+#define FINISHED_FAILURE	10
+
+    /*
+     * Access control statements for the agent 
+     */
+#define NETSNMP_OLDAPI_RONLY	0x1     /* read access only */
+#define NETSNMP_OLDAPI_RWRITE	0x2     /* read and write access (must have 0x2 bit set) */
+#define NETSNMP_OLDAPI_NOACCESS 0x0000  /* no access for anybody */
+
+#ifndef NETSNMP_NO_LEGACY_DEFINITIONS
+#define RONLY           NETSNMP_OLDAPI_RONLY
+#define RWRITE          NETSNMP_OLDAPI_RWRITE
+#define NOACCESS        NETSNMP_OLDAPI_NOACCESS
+#endif
+
+    /*
+     * defined types (from the SMI, RFC 1157) 
+     */
+#define ASN_IPADDRESS   (ASN_APPLICATION | 0)
+#define ASN_COUNTER	(ASN_APPLICATION | 1)
+#define ASN_GAUGE	(ASN_APPLICATION | 2)
+#define ASN_UNSIGNED    (ASN_APPLICATION | 2)   /* RFC 1902 - same as GAUGE */
+#define ASN_TIMETICKS   (ASN_APPLICATION | 3)
+#define ASN_OPAQUE	(ASN_APPLICATION | 4)   /* changed so no conflict with other includes */
+
+    /*
+     * defined types (from the SMI, RFC 1442) 
+     */
+#define ASN_NSAP	(ASN_APPLICATION | 5)   /* historic - don't use */
+#define ASN_COUNTER64   (ASN_APPLICATION | 6)
+#define ASN_UINTEGER    (ASN_APPLICATION | 7)   /* historic - don't use */
+
+#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES
+    /*
+     * defined types from draft-perkins-opaque-01.txt 
+     */
+#define ASN_FLOAT	    (ASN_APPLICATION | 8)
+#define ASN_DOUBLE	    (ASN_APPLICATION | 9)
+#define ASN_INTEGER64        (ASN_APPLICATION | 10)
+#define ASN_UNSIGNED64       (ASN_APPLICATION | 11)
+#endif                          /* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */
+
+    /*
+     * changed to ERROR_MSG to eliminate conflict with other includes 
+     */
+#ifndef ERROR_MSG
+#define ERROR_MSG(string)	snmp_set_detail(string)
+#endif
+
+    /*
+     * from snmp.c 
+     */
+    extern u_char   sid[];      /* size SID_MAX_LEN */
+    NETSNMP_IMPORT int      snmp_errno;
+
+
+    /*
+     * For calling secauth_build, FIRST_PASS is an indication that a new nonce
+     * and lastTimeStamp should be recorded.  LAST_PASS is an indication that
+     * the packet should be checksummed and encrypted if applicable, in
+     * preparation for transmission.
+     * 0 means do neither, FIRST_PASS | LAST_PASS means do both.
+     * For secauth_parse, FIRST_PASS means decrypt the packet, otherwise leave it
+     * alone.  LAST_PASS is ignored.
+     */
+#define FIRST_PASS	1
+#define	LAST_PASS	2
+    u_char         *snmp_comstr_parse(u_char *, size_t *, u_char *,
+                                      size_t *, long *);
+    u_char         *snmp_comstr_build(u_char *, size_t *, u_char *,
+                                      size_t *, long *, size_t);
+
+    int             has_access(u_char, int, int, int);
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* SNMP_IMPL_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpIPv4BaseDomain.h quaggasnmpTrap//include/net-snmp/library/snmpIPv4BaseDomain.h
--- quagga-0.99.18//include/net-snmp/library/snmpIPv4BaseDomain.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpIPv4BaseDomain.h	2010-05-30 05:00:00.000000000 -0700
@@ -0,0 +1,37 @@
+/* IPV4 base transport support functions
+ */
+#ifndef SNMPIPV4BASE_H
+#define SNMPIPV4BASE_H
+
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+
+#include <net-snmp/library/snmp_transport.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/*
+ * Prototypes
+ */
+
+    char *netsnmp_ipv4_fmtaddr(const char *prefix, netsnmp_transport *t,
+                               void *data, int len);
+
+/*
+ * Convert a "traditional" peername into a sockaddr_in structure which is
+ * written to *addr_  Returns 1 if the conversion was successful, or 0 if it
+ * failed
+ */
+
+    int netsnmp_sockaddr_in(struct sockaddr_in *addr, const char *peername,
+                            int remote_port);
+    int netsnmp_sockaddr_in2(struct sockaddr_in *addr, const char *inpeername,
+                             const char *default_target);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* SNMPIPV4BASE_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpIPv6BaseDomain.h quaggasnmpTrap//include/net-snmp/library/snmpIPv6BaseDomain.h
--- quagga-0.99.18//include/net-snmp/library/snmpIPv6BaseDomain.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpIPv6BaseDomain.h	2010-05-30 05:00:00.000000000 -0700
@@ -0,0 +1,32 @@
+/* IPV6 base transport support functions
+ */
+#ifndef SNMPIPV6BASE_H
+#define SNMPIPV6BASE_H
+
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+
+#include <net-snmp/library/snmp_transport.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/*
+ * Prototypes
+ */
+
+    char *netsnmp_ipv6_fmtaddr(const char *prefix, netsnmp_transport *t,
+                               void *data, int len);
+    int netsnmp_sockaddr_in6_2(struct sockaddr_in6 *addr,
+                               const char *inpeername,
+                               const char *default_target);
+    int netsnmp_sockaddr_in6(struct sockaddr_in6 *addr,
+                             const char *inpeername, int remote_port);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* SNMPIPV6BASE_H */
+
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpIPXDomain.h quaggasnmpTrap//include/net-snmp/library/snmpIPXDomain.h
--- quagga-0.99.18//include/net-snmp/library/snmpIPXDomain.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpIPXDomain.h	2010-02-09 15:48:01.000000000 -0800
@@ -0,0 +1,38 @@
+#ifndef _SNMPIPXDOMAIN_H
+#define _SNMPIPXDOMAIN_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#include <net-snmp/library/snmp_transport.h>
+#include <net-snmp/library/asn1.h>
+#if HAVE_NETIPX_IPX_H
+#include <netipx/ipx.h>
+#endif
+
+#ifndef linux
+    config_error(IPX support unavailable for this platform -Linux only-);
+#endif
+
+netsnmp_transport *netsnmp_ipx_transport(struct sockaddr_ipx *addr, int local);
+
+/*
+ * Convert an textually formatted IPX address into a sockaddr_ipx
+ * structure which is written to *addr.  Returns 1 if the conversion
+ * was successful, or 0 if it failed.  
+ */
+
+int             netsnmp_sockaddr_ipx(struct sockaddr_ipx *addr,
+                                     const char *peername);
+
+/*
+ * "Constructor" for transport domain object.  
+ */
+
+void            netsnmp_ipx_ctor(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif/*_SNMPIPXDOMAIN_H*/
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpksm.h quaggasnmpTrap//include/net-snmp/library/snmpksm.h
--- quagga-0.99.18//include/net-snmp/library/snmpksm.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpksm.h	2010-07-21 12:20:54.000000000 -0700
@@ -0,0 +1,31 @@
+/*
+ * Header file for Kerberos Security Model support
+ */
+
+#ifndef SNMPKSM_H
+#define SNMPKSM_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    int             ksm_rgenerate_out_msg(struct
+                                          snmp_secmod_outgoing_params *);
+    int             ksm_process_in_msg(struct snmp_secmod_incoming_params
+                                       *);
+    void            init_ksm(void);
+
+    /*
+     * This is the "key usage" that is used by the new crypto API.  It's used
+     * generally only if you are using derived keys.  The specifical says that
+     * 1024-2047 are to be used by applications, and that even usage numbers are
+     * to be used for encryption and odd numbers are to be used for checksums.
+     */
+
+#define KSM_KEY_USAGE_ENCRYPTION	1030
+#define KSM_KEY_USAGE_CHECKSUM		1031
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* SNMPKSM_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/snmp_logging.h quaggasnmpTrap//include/net-snmp/library/snmp_logging.h
--- quagga-0.99.18//include/net-snmp/library/snmp_logging.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmp_logging.h	2010-10-11 22:35:33.000000000 -0700
@@ -0,0 +1,126 @@
+#ifndef SNMP_LOGGING_H
+#define SNMP_LOGGING_H
+
+#include <net-snmp/types.h>
+#include <net-snmp/output_api.h>
+
+#if HAVE_SYSLOG_H
+#include <syslog.h>
+#endif
+#include <stdio.h>
+#include <stdarg.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#ifndef LOG_ERR
+#define LOG_EMERG       0       /* system is unusable */
+#define LOG_ALERT       1       /* action must be taken immediately */
+#define LOG_CRIT        2       /* critical conditions */
+#define LOG_ERR         3       /* error conditions */
+#define LOG_WARNING     4       /* warning conditions */
+#define LOG_NOTICE      5       /* normal but significant condition */
+#define LOG_INFO        6       /* informational */
+#define LOG_DEBUG       7       /* debug-level messages */
+#endif
+
+    struct snmp_log_message {
+        int             priority;
+        const char     *msg;
+    };
+
+#ifndef DEFAULT_LOG_ID
+#define DEFAULT_LOG_ID "net-snmp"
+#endif
+
+#define NETSNMP_LOGONCE(x) do { \
+        static char logged = 0; \
+        if (!logged) {          \
+            logged = 1;         \
+            snmp_log x ;        \
+        }                       \
+    } while(0)
+
+    void            init_snmp_logging(void);
+    NETSNMP_IMPORT
+    void            snmp_disable_syslog(void);
+    void            snmp_disable_filelog(void);
+    NETSNMP_IMPORT
+    void            snmp_disable_stderrlog(void);
+    void            snmp_disable_calllog(void);
+    NETSNMP_IMPORT
+    void            snmp_enable_syslog(void);
+    NETSNMP_IMPORT
+    void            snmp_enable_syslog_ident(const char *ident,
+                                             const int   facility);
+    NETSNMP_IMPORT
+    void            snmp_enable_filelog(const char *logfilename,
+                                        int dont_zero_log);
+    NETSNMP_IMPORT
+    void            snmp_enable_stderrlog(void);
+    void            snmp_enable_calllog(void);
+
+    NETSNMP_IMPORT
+    int             snmp_stderrlog_status(void);
+
+
+#define NETSNMP_LOGHANDLER_STDOUT	1
+#define NETSNMP_LOGHANDLER_STDERR	2
+#define NETSNMP_LOGHANDLER_FILE		3
+#define NETSNMP_LOGHANDLER_SYSLOG	4
+#define NETSNMP_LOGHANDLER_CALLBACK	5
+#define NETSNMP_LOGHANDLER_NONE		6
+
+    NETSNMP_IMPORT
+    void netsnmp_set_line_buffering(FILE *stream);
+    NETSNMP_IMPORT
+    int snmp_log_options(char *optarg, int argc, char *const *argv);
+    NETSNMP_IMPORT
+    void snmp_log_options_usage(const char *lead, FILE *outf);
+    NETSNMP_IMPORT
+    char *snmp_log_syslogname(const char *syslogname);
+    typedef struct netsnmp_log_handler_s netsnmp_log_handler; 
+    typedef int (NetsnmpLogHandler)(netsnmp_log_handler*, int, const char *);
+
+    NetsnmpLogHandler log_handler_stdouterr;
+    NetsnmpLogHandler log_handler_file;
+    NetsnmpLogHandler log_handler_syslog;
+    NetsnmpLogHandler log_handler_callback;
+    NetsnmpLogHandler log_handler_null;
+
+    struct netsnmp_log_handler_s {
+        int	enabled;
+        int	priority;
+        int	pri_max;
+        int	type;
+	const char *token;		/* Also used for filename */
+
+	NetsnmpLogHandler	*handler;
+
+	int     imagic;		/* E.g. file descriptor, syslog facility */
+	void   *magic;		/* E.g. Callback function */
+
+	netsnmp_log_handler	*next, *prev;
+    };
+
+NETSNMP_IMPORT
+netsnmp_log_handler *get_logh_head( void );
+NETSNMP_IMPORT
+netsnmp_log_handler *netsnmp_register_loghandler( int type, int pri );
+netsnmp_log_handler *netsnmp_find_loghandler( const char *token );
+int netsnmp_add_loghandler(    netsnmp_log_handler *logh );
+NETSNMP_IMPORT
+int netsnmp_remove_loghandler( netsnmp_log_handler *logh );
+int netsnmp_enable_loghandler( const char *token );
+int netsnmp_disable_loghandler( const char *token );
+NETSNMP_IMPORT
+void netsnmp_enable_this_loghandler( netsnmp_log_handler *logh );
+NETSNMP_IMPORT
+void netsnmp_disable_this_loghandler( netsnmp_log_handler *logh );
+NETSNMP_IMPORT
+void netsnmp_logging_restart(void);
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* SNMP_LOGGING_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/snmp_openssl.h quaggasnmpTrap//include/net-snmp/library/snmp_openssl.h
--- quagga-0.99.18//include/net-snmp/library/snmp_openssl.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmp_openssl.h	2010-10-13 20:26:08.000000000 -0700
@@ -0,0 +1,46 @@
+/*
+ * Header file for the OpenSSL Wrapper
+ */
+
+#ifndef SNMP_OPENSSL_H
+#define SNMP_OPENSSL_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    void netsnmp_init_openssl(void);
+
+    /*
+     * cert fields
+     */
+    void netsnmp_openssl_cert_dump_names(X509 *ocert);
+    void netsnmp_openssl_cert_dump_extensions(X509 *ocert);
+
+    char *netsnmp_openssl_cert_get_commonName(X509 *, char **buf, int *len);
+    char *netsnmp_openssl_cert_get_subjectName(X509 *, char **buf, int *len);
+    char *netsnmp_openssl_cert_get_fingerprint(X509 *ocert, int alg);
+    int netsnmp_openssl_cert_get_hash_type(X509 *ocert);
+
+    int netsnmp_openssl_cert_issued_by(X509 *issuer, X509 *cert);
+
+    char *netsnmp_openssl_extract_secname(netsnmp_cert_map *cert_map,
+                                          netsnmp_cert_map *peer_cert);
+
+    char *netsnmp_openssl_cert_get_subjectAltName(X509 *, char **buf, int *len);
+
+    /*
+     * ssl cert chains
+     */
+    netsnmp_container *netsnmp_openssl_get_cert_chain(SSL *ssl);
+
+    /*
+     * misc
+     */
+    void netsnmp_openssl_err_log(const char *prefix);
+    void netsnmp_openssl_null_checks(SSL *ssl, int *nullAuth, int *nullCipher);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* SNMP_OPENSSL_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/snmp_parse_args.h quaggasnmpTrap//include/net-snmp/library/snmp_parse_args.h
--- quagga-0.99.18//include/net-snmp/library/snmp_parse_args.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmp_parse_args.h	2010-03-25 06:39:59.000000000 -0700
@@ -0,0 +1,91 @@
+#ifndef SNMP_PARSE_ARGS_H
+#define SNMP_PARSE_ARGS_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @file snmp_parse_args.h
+ *
+ * Support for initializing variables of type netsnmp_session from command
+ * line arguments
+ */
+
+/** Don't enable any logging even if there is no -L argument */
+#define NETSNMP_PARSE_ARGS_NOLOGGING    0x0001
+/** Don't zero out sensitive arguments as they are not on the command line
+ *  anyway, typically used when the function is called from an internal
+ *  config-line handler
+ */
+#define NETSNMP_PARSE_ARGS_NOZERO       0x0002
+
+/**
+ * Parsing of command line arguments succeeded and application is expected
+ * to continue with normal operation.
+ */
+#define NETSNMP_PARSE_ARGS_SUCCESS       0
+/**
+  * Parsing of command line arguments succeeded, but the application is expected
+  * to exit with zero exit code. For example, '-V' parameter has been found.
+  */
+#define NETSNMP_PARSE_ARGS_SUCCESS_EXIT  -2
+/**
+ * Parsing of command line arguments failed and application is expected to show
+ * usage (i.e. list of parameters) and exit with nozero exit code. 
+ */
+#define NETSNMP_PARSE_ARGS_ERROR_USAGE   -1
+/**
+ * Parsing of command line arguments failed and application is expected to exit
+ * with nozero exit code.  netsnmp_parse_args() has already printed what went
+ * wrong.
+ */
+#define NETSNMP_PARSE_ARGS_ERROR         -3
+    
+/**
+ *  Parse an argument list and initialize \link netsnmp_session
+ *  session\endlink
+ *  from it.
+ *  @param argc Number of elements in argv
+ *  @param argv string array of at least argc elements
+ *  @param localOpts Additional option characters to accept
+ *  @param proc function pointer used to process any unhandled arguments
+ *  @param flags flags directing how to handle the string
+ *
+ *  @reval 0 (= #NETSNMP_PARSE_ARGS_SUCCESS) on success
+ *  @retval #NETSNMP_PARSE_ARGS_SUCCESS_EXIT when the application is expected
+ *  to exit with zero exit code (e.g. '-V' option was found)
+ *  @retval #NETSNMP_PARSE_ARGS_ERROR_USAGE when the function failed to parse
+ *  the command line and the application is expected to show it's usage
+ *  @retval #NETSNMP_PARSE_ARGS_ERROR when the function failed to parse
+ *  the command line and it has already printed enough information for the user
+ *  and no other output is needed
+ *
+ *  The proc function is called with argc, argv and the currently processed
+ *  option as arguments
+ */
+NETSNMP_IMPORT int
+netsnmp_parse_args(int argc, char **argv, netsnmp_session *session,
+                   const char *localOpts, void (*proc)(int, char *const *, int),
+                   int flags);
+
+/**
+ *  Calls \link netsnmp_parse_args()
+ *  netsnmp_parse_args(argc, argv, session, localOpts, proc, 0)\endlink
+ */
+NETSNMP_IMPORT
+int
+snmp_parse_args(int argc, char **argv, netsnmp_session *session,
+		const char *localOpts, void (*proc)(int, char *const *, int));
+
+NETSNMP_IMPORT
+void
+snmp_parse_args_descriptions(FILE *);
+
+NETSNMP_IMPORT
+void
+snmp_parse_args_usage(FILE *);
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/library/snmp_secmod.h quaggasnmpTrap//include/net-snmp/library/snmp_secmod.h
--- quagga-0.99.18//include/net-snmp/library/snmp_secmod.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmp_secmod.h	2010-06-10 12:46:42.000000000 -0700
@@ -0,0 +1,177 @@
+#ifndef SNMPSECMOD_H
+#define SNMPSECMOD_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#include <net-snmp/library/snmp_transport.h>
+
+/* Locally defined security models.
+ * (Net-SNMP enterprise number = 8072)*256 + local_num
+ */
+#define NETSNMP_SEC_MODEL_KSM     2066432
+#define NETSNMP_KSM_SECURITY_MODEL     NETSNMP_SEC_MODEL_KSM
+#define NETSNMP_TSM_SECURITY_MODEL     SNMP_SEC_MODEL_TSM
+
+struct snmp_secmod_def;
+
+/*
+ * parameter information passed to security model routines
+ */
+struct snmp_secmod_outgoing_params {
+    int             msgProcModel;
+    u_char         *globalData;
+    size_t          globalDataLen;
+    int             maxMsgSize;
+    int             secModel;
+    u_char         *secEngineID;
+    size_t          secEngineIDLen;
+    char           *secName;
+    size_t          secNameLen;
+    int             secLevel;
+    u_char         *scopedPdu;
+    size_t          scopedPduLen;
+    void           *secStateRef;
+    u_char         *secParams;
+    size_t         *secParamsLen;
+    u_char        **wholeMsg;
+    size_t         *wholeMsgLen;
+    size_t         *wholeMsgOffset;
+    netsnmp_pdu    *pdu;        /* IN - the pdu getting encoded            */
+    netsnmp_session *session;   /* IN - session sending the message        */
+};
+
+struct snmp_secmod_incoming_params {
+    int             msgProcModel;       /* IN */
+    size_t          maxMsgSize; /* IN     - Used to calc maxSizeResponse.  */
+
+    u_char         *secParams;  /* IN     - BER encoded securityParameters. */
+    int             secModel;   /* IN */
+    int             secLevel;   /* IN     - AuthNoPriv; authPriv etc.      */
+
+    u_char         *wholeMsg;   /* IN     - Original v3 message.           */
+    size_t          wholeMsgLen;        /* IN     - Msg length.                    */
+
+    u_char         *secEngineID;        /* OUT    - Pointer snmpEngineID.          */
+    size_t         *secEngineIDLen;     /* IN/OUT - Len available; len returned.   */
+    /*
+     * NOTE: Memory provided by caller.      
+     */
+
+    char           *secName;    /* OUT    - Pointer to securityName.       */
+    size_t         *secNameLen; /* IN/OUT - Len available; len returned.   */
+
+    u_char        **scopedPdu;  /* OUT    - Pointer to plaintext scopedPdu. */
+    size_t         *scopedPduLen;       /* IN/OUT - Len available; len returned.   */
+
+    size_t         *maxSizeResponse;    /* OUT    - Max size of Response PDU.      */
+    void          **secStateRef;        /* OUT    - Ref to security state.         */
+    netsnmp_session *sess;      /* IN     - session which got the message  */
+    netsnmp_pdu    *pdu;        /* IN     - the pdu getting parsed         */
+    u_char          msg_flags;  /* IN     - v3 Message flags.              */
+};
+
+
+/*
+ * function pointers:
+ */
+
+/*
+ * free's a given security module's data; called at unregistration time 
+ */
+typedef int     (SecmodSessionCallback) (netsnmp_session *);
+typedef int     (SecmodPduCallback) (netsnmp_pdu *);
+typedef int     (Secmod2PduCallback) (netsnmp_pdu *, netsnmp_pdu *);
+typedef int     (SecmodOutMsg) (struct snmp_secmod_outgoing_params *);
+typedef int     (SecmodInMsg) (struct snmp_secmod_incoming_params *);
+typedef void    (SecmodFreeState) (void *);
+typedef void    (SecmodHandleReport) (void *sessp,
+                                      netsnmp_transport *transport,
+                                      netsnmp_session *,
+                                      int result,
+                                      netsnmp_pdu *origpdu);
+typedef int     (SecmodDiscoveryMethod) (void *slp,
+                                         netsnmp_session *session);
+
+typedef int     (SecmodSessionSetup) (netsnmp_session *in_session,
+                                      netsnmp_session *out_session);
+/*
+ * definition of a security module
+ */
+
+/*
+ * all of these callback functions except the encoding and decoding
+ * routines are optional.  The rest of them are available if need.  
+ */
+struct snmp_secmod_def {
+    /*
+     * session maniplation functions 
+     */
+    SecmodSessionCallback *session_open;        /* called in snmp_sess_open()  */
+    SecmodSessionCallback *session_close;       /* called in snmp_sess_close() */
+    SecmodSessionSetup    *session_setup;
+
+    /*
+     * pdu manipulation routines 
+     */
+    SecmodPduCallback *pdu_free;        /* called in free_pdu() */
+    Secmod2PduCallback *pdu_clone;      /* called in snmp_clone_pdu() */
+    SecmodPduCallback *pdu_timeout;     /* called when request timesout */
+    SecmodFreeState *pdu_free_state_ref;        /* frees pdu->securityStateRef */
+
+    /*
+     * de/encoding routines: mandatory 
+     */
+    SecmodOutMsg   *encode_reverse;     /* encode packet back to front */
+    SecmodOutMsg   *encode_forward;     /* encode packet forward */
+    SecmodInMsg    *decode;     /* decode & validate incoming */
+
+   /*
+    * error and report handling
+    */
+   SecmodHandleReport *handle_report;
+
+   /*
+    * default engineID discovery mechanism
+    */
+   SecmodDiscoveryMethod *probe_engineid;
+};
+
+
+/*
+ * internal list
+ */
+struct snmp_secmod_list {
+    int             securityModel;
+    struct snmp_secmod_def *secDef;
+    struct snmp_secmod_list *next;
+};
+
+
+/*
+ * register a security service 
+ */
+int             register_sec_mod(int, const char *,
+                                 struct snmp_secmod_def *);
+/*
+ * find a security service definition 
+ */
+NETSNMP_IMPORT
+struct snmp_secmod_def *find_sec_mod(int);
+/*
+ * register a security service 
+ */
+int             unregister_sec_mod(int);        /* register a security service */
+void            init_secmod(void);
+
+/*
+ * clears the sec_mod list
+ */
+NETSNMP_IMPORT
+void            clear_sec_mod(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* SNMPSECMOD_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/snmp_service.h quaggasnmpTrap//include/net-snmp/library/snmp_service.h
--- quagga-0.99.18//include/net-snmp/library/snmp_service.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmp_service.h	2010-02-27 05:11:15.000000000 -0800
@@ -0,0 +1,39 @@
+#ifndef _SNMP_SERVICE_H
+#define _SNMP_SERVICE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Default port handling */
+
+NETSNMP_IMPORT int
+netsnmp_register_default_domain(const char* application, const char* domain);
+
+extern const char*
+netsnmp_lookup_default_domain(const char* application);
+
+extern const char* const *
+netsnmp_lookup_default_domains(const char* application);
+
+extern void
+netsnmp_clear_default_domain(void);
+
+NETSNMP_IMPORT int
+netsnmp_register_default_target(const char* application, const char* domain,
+				const char* target);
+
+extern const char*
+netsnmp_lookup_default_target(const char* application, const char* domain);
+
+extern void
+netsnmp_clear_default_target(void);
+
+NETSNMP_IMPORT void
+netsnmp_register_service_handlers(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _SNMP_SERVICE_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpSocketBaseDomain.h quaggasnmpTrap//include/net-snmp/library/snmpSocketBaseDomain.h
--- quagga-0.99.18//include/net-snmp/library/snmpSocketBaseDomain.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpSocketBaseDomain.h	2010-05-24 22:20:34.000000000 -0700
@@ -0,0 +1,25 @@
+#ifndef SNMPSOCKETBASEDOMAIN_H
+#define SNMPSOCKETBASEDOMAIN_H
+
+#if HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+
+#include <net-snmp/library/snmp_transport.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/*
+ * Prototypes
+ */
+    int netsnmp_socketbase_close(netsnmp_transport *t);
+    int netsnmp_sock_buffer_set(int s, int optname, int local, int size);
+    int netsnmp_set_non_blocking_mode(int sock, int non_blocking_mode);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* SNMPSOCKETBASEDOMAIN_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpSSHDomain.h quaggasnmpTrap//include/net-snmp/library/snmpSSHDomain.h
--- quagga-0.99.18//include/net-snmp/library/snmpSSHDomain.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpSSHDomain.h	2010-05-30 05:00:00.000000000 -0700
@@ -0,0 +1,41 @@
+#ifndef _SNMPSSHDOMAIN_H
+#define _SNMPSSHDOMAIN_H
+
+config_require(IPv4Base)
+config_require(SocketBase)
+
+#ifdef NETSNMP_TRANSPORT_SSH_DOMAIN
+
+#include <net-snmp/library/snmp_transport.h>
+
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/*
+ * The SNMP over SSH over IPv4 transport domain is identified by
+ * transportDomainSshIpv4 as defined in RFC 3419.
+ */
+
+#define TRANSPORT_DOMAIN_SSH_IP		1,3,6,1,2,1,100,1,100
+NETSNMP_IMPORT const oid netsnmp_snmpSSHDomain[];
+enum { netsnmp_snmpSSHDomain_len = 9 };
+
+netsnmp_transport *netsnmp_ssh_transport(struct sockaddr_in *addr, int local);
+
+/*
+ * "Constructor" for transport domain object.
+ */
+
+void            netsnmp_ssh_ctor(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /*NETSNMP_TRANSPORT_SSH_DOMAIN */
+
+#endif/*_SNMPSSHDOMAIN_H*/
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpSTDDomain.h quaggasnmpTrap//include/net-snmp/library/snmpSTDDomain.h
--- quagga-0.99.18//include/net-snmp/library/snmpSTDDomain.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpSTDDomain.h	2010-05-30 05:00:00.000000000 -0700
@@ -0,0 +1,41 @@
+#ifndef _SNMPSTDDOMAIN_H
+#define _SNMPSTDDOMAIN_H
+
+#ifdef NETSNMP_TRANSPORT_STD_DOMAIN
+
+#include <net-snmp/library/snmp_transport.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/*
+ * The SNMP over STD over IPv4 transport domain is identified by
+ * transportDomainStdIpv4 as defined in RFC 3419.
+ */
+
+#define TRANSPORT_DOMAIN_STD_IP		1,3,6,1,2,1,100,1,101
+extern oid netsnmp_snmpSTDDomain[];
+
+    typedef struct netsnmp_std_data_s {
+       int outfd;
+       int childpid;
+       char *prog;
+    } netsnmp_std_data;
+    
+    netsnmp_transport *netsnmp_std_transport(const char *instring,
+                                             size_t instring_len,
+                                             const char *default_target);
+
+    /*
+     * "Constructor" for transport domain object.  
+     */
+
+    void            netsnmp_std_ctor(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /*NETSNMP_TRANSPORT_STD_DOMAIN */
+
+#endif/*_SNMPSTDDOMAIN_H*/
diff -rupN quagga-0.99.18//include/net-snmp/library/snmp-tc.h quaggasnmpTrap//include/net-snmp/library/snmp-tc.h
--- quagga-0.99.18//include/net-snmp/library/snmp-tc.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmp-tc.h	2010-04-07 03:40:12.000000000 -0700
@@ -0,0 +1,66 @@
+#ifndef SNMP_TC_H
+#define SNMP_TC_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+    /*
+     * snmp-tc.h: Provide some standard #defines for Textual Convention
+     * related value information 
+     */
+
+    int
+    netsnmp_dateandtime_set_buf_from_vars(u_char *buf, size_t *bufsize,
+                                          u_short y, u_char mon, u_char d,
+                                          u_char h, u_char min, u_char s,
+                                          u_char deci_seconds,
+                                          int utc_offset_direction,
+                                          u_char utc_offset_hours,
+                                          u_char utc_offset_minutes);
+
+    NETSNMP_IMPORT
+    u_char         *date_n_time(const time_t *, size_t *);
+    time_t          ctime_to_timet(const char *);
+
+    /*
+     * TrueValue 
+     */
+#define TV_TRUE 1
+#define TV_FALSE 2
+
+    /*
+     * RowStatus 
+     */
+#define RS_NONEXISTENT    0
+#define RS_ACTIVE	        1
+#define RS_NOTINSERVICE	        2
+#define RS_NOTREADY	        3
+#define RS_CREATEANDGO	        4
+#define RS_CREATEANDWAIT	5
+#define RS_DESTROY		6
+
+#define RS_IS_GOING_ACTIVE( x ) ( x == RS_CREATEANDGO || x == RS_ACTIVE )
+#define RS_IS_ACTIVE( x ) ( x == RS_ACTIVE )
+#define RS_IS_NOT_ACTIVE( x ) ( ! RS_IS_GOING_ACTIVE(x) )
+
+    /*
+     * StorageType 
+     */
+#define ST_NONE 0
+#define ST_OTHER	1
+#define ST_VOLATILE	2
+#define ST_NONVOLATILE	3
+#define ST_PERMANENT	4
+#define ST_READONLY	5
+
+    NETSNMP_IMPORT
+    char            check_rowstatus_transition(int old_val, int new_val);
+    NETSNMP_IMPORT
+    char            check_rowstatus_with_storagetype_transition(int old_val, int new_val, int old_storage);
+    NETSNMP_IMPORT
+    char            check_storage_transition(int old_val, int new_val);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* SNMP_TC_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpTCPBaseDomain.h quaggasnmpTrap//include/net-snmp/library/snmpTCPBaseDomain.h
--- quagga-0.99.18//include/net-snmp/library/snmpTCPBaseDomain.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpTCPBaseDomain.h	2010-05-30 05:00:00.000000000 -0700
@@ -0,0 +1,22 @@
+#ifndef SNMPTCPBASEDOMAIN_H
+#define SNMPTCPBASEDOMAIN_H
+
+#include <net-snmp/library/snmp_transport.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/*
+ * Prototypes
+ */
+    int netsnmp_tcpbase_recv(netsnmp_transport *t, void *buf, int size,
+                             void **opaque, int *olength);
+    int netsnmp_tcpbase_send(netsnmp_transport *t, void *buf, int size,
+                             void **opaque, int *olength);
+        
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* SNMPTCPBASEDOMAIN_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpTCPDomain.h quaggasnmpTrap//include/net-snmp/library/snmpTCPDomain.h
--- quagga-0.99.18//include/net-snmp/library/snmpTCPDomain.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpTCPDomain.h	2010-05-30 05:00:00.000000000 -0700
@@ -0,0 +1,41 @@
+#ifndef _SNMPTCPDOMAIN_H
+#define _SNMPTCPDOMAIN_H
+
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+
+config_require(IPv4Base)
+config_require(SocketBase)
+config_require(TCPBase)
+
+#ifdef NETSNMP_TRANSPORT_TCP_DOMAIN
+
+#include <net-snmp/library/snmpIPv4BaseDomain.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/*
+ * The SNMP over TCP over IPv4 transport domain is identified by
+ * transportDomainTcpIpv4 as defined in RFC 3419.
+ */
+
+#define TRANSPORT_DOMAIN_TCP_IP		1,3,6,1,2,1,100,1,5
+NETSNMP_IMPORT oid netsnmp_snmpTCPDomain[];
+
+netsnmp_transport *netsnmp_tcp_transport(struct sockaddr_in *addr, int local);
+
+/*
+ * "Constructor" for transport domain object.  
+ */
+
+void            netsnmp_tcp_ctor(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /*NETSNMP_TRANSPORT_TCP_DOMAIN */
+
+#endif/*_SNMPTCPDOMAIN_H*/
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpTCPIPv6Domain.h quaggasnmpTrap//include/net-snmp/library/snmpTCPIPv6Domain.h
--- quagga-0.99.18//include/net-snmp/library/snmpTCPIPv6Domain.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpTCPIPv6Domain.h	2010-05-30 05:00:00.000000000 -0700
@@ -0,0 +1,38 @@
+#ifndef _SNMPTCPIPV6DOMAIN_H
+#define _SNMPTCPIPV6DOMAIN_H
+
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+
+config_require(IPv6Base)
+config_require(SocketBase)
+config_require(TCPBase)
+
+#include <net-snmp/library/snmpIPv6BaseDomain.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/*
+ * The SNMP over TCP over IPv6 transport domain is identified by
+ * transportDomainTcpIpv4 as defined in RFC 3419.
+ */
+
+#define TRANSPORT_DOMAIN_TCP_IPV6	1,3,6,1,2,1,100,1,6
+NETSNMP_IMPORT oid      netsnmp_TCPIPv6Domain[];
+
+netsnmp_transport *netsnmp_tcp6_transport(struct sockaddr_in6 *addr, 
+					  int local);
+
+/*
+ * "Constructor" for transport domain object.  
+ */
+
+NETSNMP_IMPORT void     netsnmp_tcpipv6_ctor(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif/*_SNMPTCPIPV6DOMAIN_H*/
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpTLSBaseDomain.h quaggasnmpTrap//include/net-snmp/library/snmpTLSBaseDomain.h
--- quagga-0.99.18//include/net-snmp/library/snmpTLSBaseDomain.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpTLSBaseDomain.h	2010-11-18 02:55:07.000000000 -0800
@@ -0,0 +1,84 @@
+#ifndef _SNMPTLSBASEDOMAIN_H
+#define _SNMPTLSBASEDOMAIN_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#include <net-snmp/library/snmp_transport.h>
+#include <net-snmp/library/asn1.h>
+#include <net-snmp/library/container.h>
+
+/* OpenSSL Includes */
+#include "openssl/bio.h"
+#include "openssl/ssl.h"
+#include "openssl/err.h"
+
+/*
+ * Prototypes
+ */
+
+    void netsnmp_tlsbase_ctor(void);
+    void netsnmp_init_tlsbase(void);
+    const char * _x509_get_error(int x509failvalue, const char *location);
+    void _openssl_log_error(int rc, SSL *con, const char *location);
+
+    /* will likely go away */
+    SSL_CTX *get_client_ctx(void);
+    SSL_CTX *get_server_ctx(void);
+
+#define NETSNMP_TLSBASE_IS_CLIENT     0x01
+#define NETSNMP_TLSBASE_CERT_FP_VERIFIED 0x02
+
+    /*
+     * _Internal_ structures
+     */
+    typedef struct _netsnmpTLSBaseData_s {
+       int                        flags;
+       SSL_CTX                   *ssl_context;
+       SSL                       *ssl;
+       BIO                       *sslbio;
+       BIO                       *accept_bio;
+       BIO                       *accepted_bio;
+       char                      *securityName;
+       char                      *addr_string;
+       struct sockaddr_in         addr;
+       char                      *our_identity;
+       char                      *their_identity;
+       char                      *their_fingerprint;
+       char                      *their_hostname;
+       char                      *trust_cert;
+       netsnmp_indexed_addr_pair *remote_addr;
+    } _netsnmpTLSBaseData;
+
+#define VRFY_PARENT_WAS_OK 1
+    typedef struct _netsnmp_verify_info_s {
+       int flags;
+    } _netsnmp_verify_info;
+
+    SSL_CTX *sslctx_client_setup(const SSL_METHOD *,
+                                 _netsnmpTLSBaseData *tlsbase);
+    SSL_CTX *sslctx_server_setup(const SSL_METHOD *);
+
+    int netsnmp_tlsbase_verify_server_cert(SSL *ssl,
+                                           _netsnmpTLSBaseData *tlsdata);
+    int netsnmp_tlsbase_verify_client_cert(SSL *ssl,
+                                           _netsnmpTLSBaseData *tlsdata);
+    int netsnmp_tlsbase_extract_security_name(SSL *ssl, _netsnmpTLSBaseData *tlsdata);
+    _netsnmpTLSBaseData *netsnmp_tlsbase_allocate_tlsdata(netsnmp_transport *t,
+                                                          int isserver);
+    int netsnmp_tlsbase_wrapup_recv(netsnmp_tmStateReference *tmStateRef,
+                                    _netsnmpTLSBaseData *tlsdata,
+                                    void **opaque, int *olength);
+    int netsnmp_tlsbase_config(struct netsnmp_transport_s *t,
+                               const char *token, const char *value);
+
+    int netsnmp_tlsbase_session_init(struct netsnmp_transport_s *,
+                                     struct snmp_session *sess);
+    int tls_get_verify_info_index(void);
+
+    void netsnmp_tlsbase_free_tlsdata(_netsnmpTLSBaseData *tlsbase);
+#ifdef __cplusplus
+}
+#endif
+#endif/*_SNMPTLSBASEDOMAIN_H*/
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpTLSTCPDomain.h quaggasnmpTrap//include/net-snmp/library/snmpTLSTCPDomain.h
--- quagga-0.99.18//include/net-snmp/library/snmpTLSTCPDomain.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpTLSTCPDomain.h	2010-06-25 06:08:40.000000000 -0700
@@ -0,0 +1,39 @@
+#ifndef _SNMPTLSTCPDOMAIN_H
+#define _SNMPTLSTCPDOMAIN_H
+
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+
+config_require(IPv4Base)
+config_require(SocketBase)
+config_require(TLSBase)
+
+#include <net-snmp/library/snmpIPv4BaseDomain.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#define TRANSPORT_DOMAIN_TLS_TCP_IP	1,3,6,1,6,1,8
+NETSNMP_IMPORT oid netsnmpTLSTCPDomain[7];
+NETSNMP_IMPORT size_t netsnmpTLSTCPDomain_len;
+
+netsnmp_transport *netsnmp_tlstcp_transport(const char *addr_string, int local);
+
+/*
+ * Register any configuration tokens specific to the agent.  
+ */
+
+void            netsnmp_tlstcp_agent_config_tokens_register(void);
+
+/*
+ * "Constructor" for transport domain object.  
+ */
+
+void            netsnmp_tlstcp_ctor(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif/*_SNMPTLSTCPDOMAIN_H*/
diff -rupN quagga-0.99.18//include/net-snmp/library/snmp_transport.h quaggasnmpTrap//include/net-snmp/library/snmp_transport.h
--- quagga-0.99.18//include/net-snmp/library/snmp_transport.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmp_transport.h	2010-09-20 12:25:47.000000000 -0700
@@ -0,0 +1,283 @@
+#ifndef _SNMP_TRANSPORT_H
+#define _SNMP_TRANSPORT_H
+
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+
+#include <sys/types.h>
+
+#include <net-snmp/library/asn1.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/*  Some transport-type constants.  */
+
+#ifndef NETSNMP_STREAM_QUEUE_LEN
+#define	NETSNMP_STREAM_QUEUE_LEN	5
+#endif
+
+/*  Some transport-type flags.  */
+
+#define		NETSNMP_TRANSPORT_FLAG_STREAM	 0x01
+#define		NETSNMP_TRANSPORT_FLAG_LISTEN	 0x02
+#define		NETSNMP_TRANSPORT_FLAG_TUNNELED	 0x04
+#define         NETSNMP_TRANSPORT_FLAG_TMSTATE   0x08  /* indicates opaque is a
+                                                          TSM tmStateReference */
+#define		NETSNMP_TRANSPORT_FLAG_EMPTY_PKT 0x10
+#define		NETSNMP_TRANSPORT_FLAG_OPENED	 0x20  /* f_open called */
+#define		NETSNMP_TRANSPORT_FLAG_HOSTNAME	 0x80  /* for fmtaddr hook */
+
+/*  The standard SNMP domains.  */
+
+NETSNMP_IMPORT oid      netsnmpUDPDomain[]; 	/*      = { 1, 3, 6, 1, 6, 1, 1 };  */
+NETSNMP_IMPORT oid      netsnmpCLNSDomain[];    /*      = { 1, 3, 6, 1, 6, 1, 2 };  */
+NETSNMP_IMPORT oid      netsnmpCONSDomain[];    /*      = { 1, 3, 6, 1, 6, 1, 3 };  */
+NETSNMP_IMPORT oid      netsnmpDDPDomain[]; 	/*      = { 1, 3, 6, 1, 6, 1, 4 };  */
+NETSNMP_IMPORT oid      netsnmpIPXDomain[]; 	/*      = { 1, 3, 6, 1, 6, 1, 5 };  */
+NETSNMP_IMPORT size_t   netsnmpUDPDomain_len;
+NETSNMP_IMPORT size_t   netsnmpCLNSDomain_len;
+NETSNMP_IMPORT size_t   netsnmpCONSDomain_len;
+NETSNMP_IMPORT size_t   netsnmpDDPDomain_len;
+NETSNMP_IMPORT size_t   netsnmpIPXDomain_len;
+
+/* Structure which stores transport security model specific parameters */
+/* isms-secshell-11 section 4.1 */
+
+/* contents documented in draft-ietf-isms-transport-security-model
+   Section 3.2 */
+/* note: VACM only allows <= 32 so this is overkill till another ACM comes */
+#define NETSNMP_TM_MAX_SECNAME 256
+
+typedef struct netsnmp_addr_pair_s {
+   struct sockaddr_in remote_addr;
+   struct sockaddr_in local_addr;
+} netsnmp_addr_pair;
+
+typedef struct netsnmp_indexed_addr_pair_s {
+   struct sockaddr_in remote_addr;
+   struct sockaddr_in local_addr;
+    int if_index;
+} netsnmp_indexed_addr_pair;
+
+typedef struct netsnmp_tmStateReference_s {
+   oid    transportDomain[MAX_OID_LEN];
+   size_t transportDomainLen;
+   char   securityName[NETSNMP_TM_MAX_SECNAME];
+   size_t securityNameLen;
+   int    requestedSecurityLevel;
+   int    transportSecurityLevel;
+   char   sameSecurity;
+   char   sessionID[8];
+   
+   char   have_addresses;
+   netsnmp_indexed_addr_pair addresses;
+
+   void *otherTransportOpaque; /* XXX: May have mem leak issues */
+} netsnmp_tmStateReference;
+
+/*  Structure which defines the transport-independent API.  */
+
+struct snmp_session;
+
+typedef struct netsnmp_transport_s {
+    /*  The transport domain object identifier.  */
+
+    const oid      *domain;
+    int             domain_length;  /*  In sub-IDs, not octets.  */
+
+    /*  Local transport address (in relevant SNMP-style encoding).  */
+    
+    unsigned char  *local;
+    int             local_length;   /*  In octets.  */
+
+    /*  Remote transport address (in relevant SNMP-style encoding).  */
+
+    unsigned char  *remote;
+    int             remote_length;  /*  In octets.  */
+
+    /*  The actual socket.  */
+    
+    int             sock;
+
+    /*  Flags (see #definitions above).  */
+
+    unsigned int    flags;
+
+    /*  Protocol-specific opaque data pointer.  */
+
+    void           *data;
+    int             data_length;
+
+    /*  Maximum size of PDU that can be sent/received by this transport.  */
+
+    size_t          msgMaxSize;
+
+    /* TM state reference per ISMS WG solution */
+    netsnmp_tmStateReference *tmStateRef;
+
+    /*  Callbacks.  Arguments are:
+     *		
+     *              "this" pointer, fd, buf, size, *opaque, *opaque_length  
+     */
+
+    int             (*f_recv)   (struct netsnmp_transport_s *, void *,
+				 int, void **, int *);
+    int             (*f_send)   (struct netsnmp_transport_s *, void *,
+				 int, void **, int *);
+    int             (*f_close)  (struct netsnmp_transport_s *);
+
+    /* Optional: opening can occur during creation if more appropriate */
+   struct netsnmp_transport_s * (*f_open)   (struct netsnmp_transport_s *);
+
+    /*  This callback is only necessary for stream-oriented transports.  */
+
+    int             (*f_accept) (struct netsnmp_transport_s *);
+
+    /*  Optional callback to format a transport address.  */
+
+    char           *(*f_fmtaddr)(struct netsnmp_transport_s *, void *, int);
+
+    /*  Optional callback to support extra configuration token/value pairs */
+    /*  return non-zero on error */
+    int            (*f_config)(struct netsnmp_transport_s *, const char *,
+                               const char *);
+
+    /*  Optional callback that is called after the first transport is
+        cloned to the second */
+    int            (*f_copy)(struct netsnmp_transport_s *,
+                             struct netsnmp_transport_s *);
+
+    /*  Setup initial session config if special things are needed */
+   int             (*f_setup_session)(struct netsnmp_transport_s *,
+                                      struct snmp_session *);
+  
+    /* allocated host name identifier; used by configuration system
+       to load localhost.conf for host-specific configuration */
+    u_char         *identifier; /* udp:localhost:161 -> "localhost" */
+} netsnmp_transport;
+
+typedef struct netsnmp_transport_list_s {
+    netsnmp_transport *transport;
+    struct netsnmp_transport_list_s *next;
+} netsnmp_transport_list;
+
+typedef struct netsnmp_tdomain_s {
+    const oid      *name;
+    size_t          name_length;
+    const char    **prefix;
+
+    /*
+     * The f_create_from_tstring field is deprecated, please do not use it
+     * for new code and try to migrate old code away from using it.
+     */
+    netsnmp_transport *(*f_create_from_tstring) (const char *, int);
+
+    netsnmp_transport *(*f_create_from_ostring) (const u_char *, size_t, int);
+
+    struct netsnmp_tdomain_s *next;
+
+    netsnmp_transport *(*f_create_from_tstring_new) (const char *, int,
+						     const char*);
+
+} netsnmp_tdomain;
+
+void init_snmp_transport(void);
+
+/*  Some utility functions.  */
+
+char *netsnmp_transport_peer_string(netsnmp_transport *t, void *data, int len);
+
+int netsnmp_transport_send(netsnmp_transport *t, void *data, int len,
+                           void **opaque, int *olength);
+int netsnmp_transport_recv(netsnmp_transport *t, void *data, int len,
+                           void **opaque, int *olength);
+
+int netsnmp_transport_add_to_list(netsnmp_transport_list **transport_list,
+				  netsnmp_transport *transport);
+int netsnmp_transport_remove_from_list(netsnmp_transport_list **transport_list,
+				       netsnmp_transport *transport);
+
+
+/*
+ * Return an exact (deep) copy of t, or NULL if there is a memory allocation
+ * problem (for instance).
+ */
+
+netsnmp_transport *netsnmp_transport_copy(netsnmp_transport *t);
+
+
+/*  Free an netsnmp_transport.  */
+
+NETSNMP_IMPORT
+void            netsnmp_transport_free(netsnmp_transport *t);
+
+
+/*
+ * If the passed oid (in_oid, in_len) corresponds to a supported transport
+ * domain, return 1; if not return 0.  If out_oid is not NULL and out_len is
+ * not NULL, then the "internal" oid which should be used to identify this
+ * domain (e.g. in pdu->tDomain etc.) is written to *out_oid and its length to
+ * *out_len.
+ */
+
+NETSNMP_IMPORT
+int             netsnmp_tdomain_support(const oid *in_oid, size_t in_len,
+					const oid **out_oid, size_t *out_len);
+
+int             netsnmp_tdomain_register(netsnmp_tdomain *domain);
+    
+int             netsnmp_tdomain_unregister(netsnmp_tdomain *domain);
+
+NETSNMP_IMPORT
+void            netsnmp_clear_tdomain_list(void);
+
+void            netsnmp_tdomain_init(void);
+
+NETSNMP_IMPORT
+netsnmp_transport *netsnmp_tdomain_transport(const char *str,
+					     int local,
+					     const char *default_domain);
+
+NETSNMP_IMPORT
+netsnmp_transport *netsnmp_tdomain_transport_full(const char *application,
+						  const char *str,
+						  int local,
+						  const char *default_domain,
+						  const char *default_target);
+
+NETSNMP_IMPORT
+netsnmp_transport *netsnmp_tdomain_transport_oid(const oid * dom,
+						 size_t dom_len,
+						 const u_char * o,
+						 size_t o_len,
+						 int local);
+
+NETSNMP_IMPORT
+netsnmp_transport*
+netsnmp_transport_open_client(const char* application, const char* str);
+
+NETSNMP_IMPORT
+netsnmp_transport*
+netsnmp_transport_open_server(const char* application, const char* str);
+
+netsnmp_transport*
+netsnmp_transport_open(const char* application, const char* str, int local);
+
+typedef struct netsnmp_transport_config_s {
+   char *key;
+   char *value;
+} netsnmp_transport_config;
+    
+NETSNMP_IMPORT    
+int netsnmp_transport_config_compare(netsnmp_transport_config *left,
+                                     netsnmp_transport_config *right);
+NETSNMP_IMPORT
+netsnmp_transport_config *netsnmp_transport_create_config(char *key,
+                                                          char *value);
+#ifdef __cplusplus
+}
+#endif
+#endif/*_SNMP_TRANSPORT_H*/
diff -rupN quagga-0.99.18//include/net-snmp/library/snmptsm.h quaggasnmpTrap//include/net-snmp/library/snmptsm.h
--- quagga-0.99.18//include/net-snmp/library/snmptsm.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmptsm.h	2010-07-21 12:20:54.000000000 -0700
@@ -0,0 +1,29 @@
+/*
+ * Header file for Transport Security Model support
+ */
+
+#ifndef SNMPTSM_H
+#define SNMPTSM_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    int             tsm_rgenerate_out_msg(struct
+                                          snmp_secmod_outgoing_params *);
+    int             tsm_process_in_msg(struct snmp_secmod_incoming_params
+                                       *);
+    void            init_tsm(void);
+
+    #define NETSNMP_TM_SAME_SECURITY_NOT_REQUIRED 0
+    #define NETSNMP_TM_USE_SAME_SECURITY          1
+
+    /* basically we store almost nothing else but a tm ref */
+    typedef struct netsnmp_tsmSecurityReference_s {
+       netsnmp_tmStateReference *tmStateRef;
+    } netsnmp_tsmSecurityReference;
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* SNMPTSM_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpUDPBaseDomain.h quaggasnmpTrap//include/net-snmp/library/snmpUDPBaseDomain.h
--- quagga-0.99.18//include/net-snmp/library/snmpUDPBaseDomain.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpUDPBaseDomain.h	2010-05-30 05:00:00.000000000 -0700
@@ -0,0 +1,34 @@
+#ifndef SNMPUDPBASEDOMAIN_H
+#define SNMPUDPBASEDOMAIN_H
+
+config_require(SocketBase)
+
+#include <net-snmp/library/snmp_transport.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/*
+ * Prototypes
+ */
+    void _netsnmp_udp_sockopt_set(int fd, int local);
+    int netsnmp_udpbase_recv(netsnmp_transport *t, void *buf, int size,
+                             void **opaque, int *olength);
+    int netsnmp_udpbase_send(netsnmp_transport *t, void *buf, int size,
+                             void **opaque, int *olength);
+
+#if defined(linux) && defined(IP_PKTINFO)
+    int netsnmp_udpbase_recvfrom(int s, void *buf, int len,
+                                 struct sockaddr *from, socklen_t *fromlen,
+                                 struct sockaddr *dstip, socklen_t *dstlen,
+                                 int *if_index);
+    int netsnmp_udpbase_sendto(int fd, struct in_addr *srcip, int if_index,
+                               struct sockaddr *remote, void *data, int len);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* SNMPUDPBASEDOMAIN_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpUDPDomain.h quaggasnmpTrap//include/net-snmp/library/snmpUDPDomain.h
--- quagga-0.99.18//include/net-snmp/library/snmpUDPDomain.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpUDPDomain.h	2010-05-30 05:00:00.000000000 -0700
@@ -0,0 +1,62 @@
+#ifndef _SNMPUDPDOMAIN_H
+#define _SNMPUDPDOMAIN_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#include <net-snmp/library/snmp_transport.h>
+#include <net-snmp/library/asn1.h>
+
+#if HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+
+config_require(UDPIPv4Base)
+#include <net-snmp/library/snmpUDPIPv4BaseDomain.h>
+
+netsnmp_transport *netsnmp_udp_transport(struct sockaddr_in *addr, int local);
+
+
+/*
+ * Register any configuration tokens specific to the agent.  
+ */
+
+NETSNMP_IMPORT
+void            netsnmp_udp_agent_config_tokens_register(void);
+
+NETSNMP_IMPORT
+void            netsnmp_udp_parse_security(const char *token, char *param);
+
+NETSNMP_IMPORT
+int             netsnmp_udp_getSecName(void *opaque, int olength,
+                                       const char *community,
+                                       size_t community_len,
+                                       const char **secname,
+                                       const char **contextName);
+
+/*
+ * "Constructor" for transport domain object.  
+ */
+
+void            netsnmp_udp_ctor(void);
+
+/*
+ * protected-ish functions used by other core-code
+ */
+char *netsnmp_udp_fmtaddr(netsnmp_transport *t, void *data, int len);
+#if defined(linux) && defined(IP_PKTINFO)
+int netsnmp_udp_recvfrom(int s, void *buf, int len, struct sockaddr *from,
+                         socklen_t *fromlen, struct sockaddr *dstip,
+                         socklen_t *dstlen, int *if_index);
+int netsnmp_udp_sendto(int fd, struct in_addr *srcip, int if_index,
+					   struct sockaddr *remote, void *data, int len);
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+#endif/*_SNMPUDPDOMAIN_H*/
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpUDPIPv4BaseDomain.h quaggasnmpTrap//include/net-snmp/library/snmpUDPIPv4BaseDomain.h
--- quagga-0.99.18//include/net-snmp/library/snmpUDPIPv4BaseDomain.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpUDPIPv4BaseDomain.h	2010-05-30 05:00:00.000000000 -0700
@@ -0,0 +1,52 @@
+/* UDPIPV4 base transport support functions
+ */
+#ifndef SNMPUDPIPV4BASE_H
+#define SNMPUDPIPV4BASE_H
+
+#if HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+
+config_require(UDPBase)
+config_require(IPv4Base)
+
+#include <net-snmp/library/snmpIPv4BaseDomain.h>
+#include <net-snmp/library/snmpUDPBaseDomain.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/*
+ * Definitions
+ */
+#ifdef  MSG_DONTWAIT
+#define NETSNMP_DONTWAIT MSG_DONTWAIT
+#else
+#define NETSNMP_DONTWAIT 0
+#endif
+
+/*
+ * Prototypes
+ */
+
+    netsnmp_transport *netsnmp_udpipv4base_transport(struct sockaddr_in *addr,
+                                                     int local);
+
+#if defined(linux) && defined(IP_PKTINFO)
+    int netsnmp_udpipv4_recvfrom(int s, void *buf, int len,
+                                 struct sockaddr *from, socklen_t *fromlen,
+                                 struct sockaddr *dstip, socklen_t *dstlen,
+                                 int *if_index);
+    int netsnmp_udpipv4_sendto(int fd, struct in_addr *srcip, int if_index,
+                               struct sockaddr *remote, void *data, int len);
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* SNMPUDPIPV4BASE_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpUDPIPv6Domain.h quaggasnmpTrap//include/net-snmp/library/snmpUDPIPv6Domain.h
--- quagga-0.99.18//include/net-snmp/library/snmpUDPIPv6Domain.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpUDPIPv6Domain.h	2010-05-30 05:00:00.000000000 -0700
@@ -0,0 +1,61 @@
+#ifndef _SNMPUDPIPV6DOMAIN_H
+#define _SNMPUDPIPV6DOMAIN_H
+
+#include <net-snmp/types.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#include <net-snmp/library/snmp_transport.h>
+
+config_require(IPv6Base)
+config_require(UDPBase)
+
+#include <net-snmp/library/snmpIPv6BaseDomain.h>
+
+/*
+ * The SNMP over UDP over IPv6 transport domain is identified by
+ * transportDomainUdpIpv6 as defined in RFC 3419.
+ */
+
+#define TRANSPORT_DOMAIN_UDP_IPV6	1,3,6,1,2,1,100,1,2
+NETSNMP_IMPORT oid      netsnmp_UDPIPv6Domain[];
+
+netsnmp_transport *snmp_udp6_transport(struct sockaddr_in6 *addr,
+                                       int local);
+
+
+/*
+ * Convert a "traditional" peername into a sockaddr_in6 structure which is
+ * written to *addr.  Returns 1 if the conversion was successful, or 0 if it
+ * failed.
+ */
+
+int             netsnmp_sockaddr_in6(struct sockaddr_in6 *addr,
+                                     const char *peername,
+                                     int remote_port);
+
+NETSNMP_IMPORT
+void            netsnmp_udp6_agent_config_tokens_register(void);
+NETSNMP_IMPORT
+void            netsnmp_udp6_parse_security(const char *token,
+                                            char *param);
+
+NETSNMP_IMPORT
+int             netsnmp_udp6_getSecName(void *opaque, int olength,
+                                        const char *community,
+                                        int community_len,
+                                        const char **secname,
+                                        const char **contextName);
+
+/*
+ * "Constructor" for transport domain object.
+ */
+
+NETSNMP_IMPORT void netsnmp_udpipv6_ctor(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif/*_SNMPUDPIPV6DOMAIN_H*/
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpUnixDomain.h quaggasnmpTrap//include/net-snmp/library/snmpUnixDomain.h
--- quagga-0.99.18//include/net-snmp/library/snmpUnixDomain.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpUnixDomain.h	2010-05-30 05:00:00.000000000 -0700
@@ -0,0 +1,65 @@
+#ifndef _SNMPUNIXDOMAIN_H
+#define _SNMPUNIXDOMAIN_H
+
+#ifdef NETSNMP_TRANSPORT_UNIX_DOMAIN
+
+#if defined(cygwin) || defined(mingw32) || defined(mingw32msvc)
+    config_error(Unix domain protocol support unavailable for this platform)
+#endif
+
+#if HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+#if HAVE_SYS_UN_H
+#include <sys/un.h>
+#endif
+
+#include <net-snmp/library/snmp_transport.h>
+
+config_require(SocketBase)
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/*
+ * The SNMP over local socket transport domain is identified by
+ * transportDomainLocal as defined in RFC 3419.
+ */
+
+#define TRANSPORT_DOMAIN_LOCAL	1,3,6,1,2,1,100,1,13
+NETSNMP_IMPORT oid netsnmp_UnixDomain[];
+
+netsnmp_transport *netsnmp_unix_transport(struct sockaddr_un *addr,
+                                          int local);
+void netsnmp_unix_agent_config_tokens_register(void);
+void netsnmp_unix_parse_security(const char *token, char *param);
+int netsnmp_unix_getSecName(void *opaque, int olength,
+                            const char *community,
+                            size_t community_len, const char **secName,
+                            const char **contextName);
+
+
+/*
+ * "Constructor" for transport domain object.  
+ */
+
+void            netsnmp_unix_ctor(void);
+
+/*
+ * Support functions
+ */
+void            netsnmp_unix_create_path_with_mode(int mode);
+void            netsnmp_unix_dont_create_path(void);
+
+#ifdef __cplusplus
+}
+#endif
+#else
+
+#define netsnmp_unix_create_path_with_mode(x)
+#define netsnmp_unix_dont_create_path()
+
+#endif                          /*NETSNMP_TRANSPORT_UNIX_DOMAIN */
+
+#endif/*_SNMPUNIXDOMAIN_H*/
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpusm.h quaggasnmpTrap//include/net-snmp/library/snmpusm.h
--- quagga-0.99.18//include/net-snmp/library/snmpusm.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpusm.h	2010-06-10 12:46:42.000000000 -0700
@@ -0,0 +1,261 @@
+/*
+ * snmpusm.h
+ *
+ * Header file for USM support.
+ */
+
+#ifndef SNMPUSM_H
+#define SNMPUSM_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#define WILDCARDSTRING "*"
+
+    /*
+     * General.
+     */
+#define USM_MAX_ID_LENGTH		1024    /* In bytes. */
+#define USM_MAX_SALT_LENGTH		128     /* In BITS. */
+#define USM_DES_SALT_LENGTH		64      /* In BITS. */
+#define USM_AES_SALT_LENGTH		128     /* In BITS. */
+#define USM_MAX_KEYEDHASH_LENGTH	128     /* In BITS. */
+
+#define USM_TIME_WINDOW			150
+#define USM_MD5_AND_SHA_AUTH_LEN        12      /* bytes */
+#define USM_MAX_AUTHSIZE                USM_MD5_AND_SHA_AUTH_LEN
+
+#define USM_SEC_MODEL_NUMBER            SNMP_SEC_MODEL_USM
+
+    /*
+     * Structures.
+     */
+    struct usmStateReference {
+        char           *usr_name;
+        size_t          usr_name_length;
+        u_char         *usr_engine_id;
+        size_t          usr_engine_id_length;
+        oid            *usr_auth_protocol;
+        size_t          usr_auth_protocol_length;
+        u_char         *usr_auth_key;
+        size_t          usr_auth_key_length;
+        oid            *usr_priv_protocol;
+        size_t          usr_priv_protocol_length;
+        u_char         *usr_priv_key;
+        size_t          usr_priv_key_length;
+        u_int           usr_sec_level;
+    };
+
+
+    /*
+     * struct usmUser: a structure to represent a given user in a list 
+     */
+    /*
+     * Note: Any changes made to this structure need to be reflected in
+     * the following functions: 
+     */
+
+    struct usmUser;
+    struct usmUser {
+        u_char         *engineID;
+        size_t          engineIDLen;
+        char           *name;
+        char           *secName;
+        oid            *cloneFrom;
+        size_t          cloneFromLen;
+        oid            *authProtocol;
+        size_t          authProtocolLen;
+        u_char         *authKey;
+        size_t          authKeyLen;
+        oid            *privProtocol;
+        size_t          privProtocolLen;
+        u_char         *privKey;
+        size_t          privKeyLen;
+        u_char         *userPublicString;
+        size_t          userPublicStringLen;
+        int             userStatus;
+        int             userStorageType;
+       /* these are actually DH * pointers but only if openssl is avail. */
+        void           *usmDHUserAuthKeyChange;
+        void           *usmDHUserPrivKeyChange;
+        struct usmUser *next;
+        struct usmUser *prev;
+    };
+
+
+
+    /*
+     * Prototypes.
+     */
+    struct usmStateReference *usm_malloc_usmStateReference(void);
+
+    void            usm_free_usmStateReference(void *old);
+
+    int             usm_set_usmStateReference_name(struct usmStateReference
+                                                   *ref, char *name,
+                                                   size_t name_len);
+
+    int             usm_set_usmStateReference_engine_id(struct
+                                                        usmStateReference
+                                                        *ref,
+                                                        u_char * engine_id,
+                                                        size_t
+                                                        engine_id_len);
+
+    int             usm_set_usmStateReference_auth_protocol(struct
+                                                            usmStateReference
+                                                            *ref,
+                                                            oid *
+                                                            auth_protocol,
+                                                            size_t
+                                                            auth_protocol_len);
+
+    int             usm_set_usmStateReference_auth_key(struct
+                                                       usmStateReference
+                                                       *ref,
+                                                       u_char * auth_key,
+                                                       size_t
+                                                       auth_key_len);
+
+    int             usm_set_usmStateReference_priv_protocol(struct
+                                                            usmStateReference
+                                                            *ref,
+                                                            oid *
+                                                            priv_protocol,
+                                                            size_t
+                                                            priv_protocol_len);
+
+    int             usm_set_usmStateReference_priv_key(struct
+                                                       usmStateReference
+                                                       *ref,
+                                                       u_char * priv_key,
+                                                       size_t
+                                                       priv_key_len);
+
+    int             usm_set_usmStateReference_sec_level(struct
+                                                        usmStateReference
+                                                        *ref,
+                                                        int sec_level);
+
+#ifdef NETSNMP_ENABLE_TESTING_CODE
+    void            emergency_print(u_char * field, u_int length);
+#endif
+
+    int             asn_predict_int_length(int type, long number,
+                                           size_t len);
+
+    int             asn_predict_length(int type, u_char * ptr,
+                                       size_t u_char_len);
+
+    int             usm_set_salt(u_char * iv,
+                                 size_t * iv_length,
+                                 u_char * priv_salt,
+                                 size_t priv_salt_length,
+                                 u_char * msgSalt);
+
+    int             usm_parse_security_parameters(u_char * secParams,
+                                                  size_t remaining,
+                                                  u_char * secEngineID,
+                                                  size_t * secEngineIDLen,
+                                                  u_int * boots_uint,
+                                                  u_int * time_uint,
+                                                  char *secName,
+                                                  size_t * secNameLen,
+                                                  u_char * signature,
+                                                  size_t *
+                                                  signature_length,
+                                                  u_char * salt,
+                                                  size_t * salt_length,
+                                                  u_char ** data_ptr);
+
+    int             usm_check_and_update_timeliness(u_char * secEngineID,
+                                                    size_t secEngineIDLen,
+                                                    u_int boots_uint,
+                                                    u_int time_uint,
+                                                    int *error);
+
+    SecmodSessionCallback usm_open_session;
+    SecmodOutMsg    usm_secmod_generate_out_msg;
+    SecmodOutMsg    usm_secmod_generate_out_msg;
+    SecmodInMsg     usm_secmod_process_in_msg;
+    int             usm_generate_out_msg(int, u_char *, size_t, int, int,
+                                         u_char *, size_t, char *, size_t,
+                                         int, u_char *, size_t, void *,
+                                         u_char *, size_t *, u_char **,
+                                         size_t *);
+    int             usm_rgenerate_out_msg(int, u_char *, size_t, int, int,
+                                          u_char *, size_t, char *, size_t,
+                                          int, u_char *, size_t, void *,
+                                          u_char **, size_t *, size_t *);
+
+    int             usm_process_in_msg(int, size_t, u_char *, int, int,
+                                       u_char *, size_t, u_char *,
+                                       size_t *, char *, size_t *,
+                                       u_char **, size_t *, size_t *,
+                                       void **, netsnmp_session *, u_char);
+
+    int             usm_check_secLevel(int level, struct usmUser *user);
+    NETSNMP_IMPORT
+    struct usmUser *usm_get_userList(void);
+    NETSNMP_IMPORT
+    struct usmUser *usm_get_user(u_char * engineID, size_t engineIDLen,
+                                 char *name);
+    struct usmUser *usm_get_user_from_list(u_char * engineID,
+                                           size_t engineIDLen, char *name,
+                                           struct usmUser *userList,
+                                           int use_default);
+    NETSNMP_IMPORT
+    struct usmUser *usm_add_user(struct usmUser *user);
+    struct usmUser *usm_add_user_to_list(struct usmUser *user,
+                                         struct usmUser *userList);
+    NETSNMP_IMPORT
+    struct usmUser *usm_free_user(struct usmUser *user);
+    NETSNMP_IMPORT
+    struct usmUser *usm_create_user(void);
+    NETSNMP_IMPORT
+    struct usmUser *usm_create_initial_user(const char *name,
+                                            const oid * authProtocol,
+                                            size_t authProtocolLen,
+                                            const oid * privProtocol,
+                                            size_t privProtocolLen);
+    NETSNMP_IMPORT
+    struct usmUser *usm_cloneFrom_user(struct usmUser *from,
+                                       struct usmUser *to);
+    NETSNMP_IMPORT
+    struct usmUser *usm_remove_user(struct usmUser *user);
+    struct usmUser *usm_remove_user_from_list(struct usmUser *user,
+                                              struct usmUser **userList);
+    char           *get_objid(char *line, oid ** optr, size_t * len);
+    NETSNMP_IMPORT
+    void            usm_save_users(const char *token, const char *type);
+    void            usm_save_users_from_list(struct usmUser *user,
+                                             const char *token,
+                                             const char *type);
+    void            usm_save_user(struct usmUser *user, const char *token,
+                                  const char *type);
+    NETSNMP_IMPORT
+    SNMPCallback    usm_store_users;
+    struct usmUser *usm_read_user(const char *line);
+    NETSNMP_IMPORT
+    void            usm_parse_config_usmUser(const char *token,
+                                             char *line);
+
+    void            usm_set_password(const char *token, char *line);
+    NETSNMP_IMPORT
+    void            usm_set_user_password(struct usmUser *user,
+                                          const char *token, char *line);
+    void            init_usm(void);
+    NETSNMP_IMPORT
+    void            init_usm_conf(const char *app);
+    int             init_usm_post_config(int majorid, int minorid,
+                                         void *serverarg, void *clientarg);
+    int             deinit_usm_post_config(int majorid, int minorid, void *serverarg,
+					   void *clientarg);
+    NETSNMP_IMPORT
+    void            clear_user_list(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* SNMPUSM_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/snmpv3.h quaggasnmpTrap//include/net-snmp/library/snmpv3.h
--- quagga-0.99.18//include/net-snmp/library/snmpv3.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/snmpv3.h	2010-02-27 05:11:15.000000000 -0800
@@ -0,0 +1,70 @@
+/*
+ * snmpv3.h
+ */
+
+#ifndef SNMPV3_H
+#define SNMPV3_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#define MAX_ENGINEID_LENGTH 32 /* per SNMP-FRAMEWORK-MIB SnmpEngineID TC */
+
+#define ENGINEID_TYPE_IPV4    1
+#define ENGINEID_TYPE_IPV6    2
+#define ENGINEID_TYPE_MACADDR 3
+#define ENGINEID_TYPE_TEXT    4
+#define ENGINEID_TYPE_EXACT   5
+#define ENGINEID_TYPE_NETSNMP_RND 128
+
+#define	DEFAULT_NIC "eth0"
+
+    NETSNMP_IMPORT
+    int             setup_engineID(u_char ** eidp, const char *text);
+    void            engineID_conf(const char *word, char *cptr);
+    void            engineBoots_conf(const char *, char *);
+    void            engineIDType_conf(const char *, char *);
+    void            engineIDNic_conf(const char *, char *);
+    void            snmpv3_authtype_conf(const char *word, char *cptr);
+    void            snmpv3_privtype_conf(const char *word, char *cptr);
+    NETSNMP_IMPORT
+    void            usm_parse_create_usmUser(const char *token,
+                                             char *line);
+    NETSNMP_IMPORT
+    void            init_snmpv3(const char *);
+    int             init_snmpv3_post_config(int majorid, int minorid,
+                                            void *serverarg,
+                                            void *clientarg);
+    int             init_snmpv3_post_premib_config(int majorid,
+                                                   int minorid,
+                                                   void *serverarg,
+                                                   void *clientarg);
+    void            shutdown_snmpv3(const char *type);
+    int             snmpv3_store(int majorID, int minorID, void *serverarg,
+                                 void *clientarg);
+    NETSNMP_IMPORT
+    u_long          snmpv3_local_snmpEngineBoots(void);
+    int             snmpv3_clone_engineID(u_char **, size_t *, u_char *,
+                                          size_t);
+    NETSNMP_IMPORT
+    size_t          snmpv3_get_engineID(u_char * buf, size_t buflen);
+    NETSNMP_IMPORT
+    u_char         *snmpv3_generate_engineID(size_t *);
+    NETSNMP_IMPORT
+    u_long          snmpv3_local_snmpEngineTime(void);
+    int             get_default_secLevel(void);
+    NETSNMP_IMPORT
+    const oid      *get_default_authtype(size_t *);
+    NETSNMP_IMPORT
+    const oid      *get_default_privtype(size_t *);
+    void            snmpv3_set_engineBootsAndTime(int boots, int ttime);
+    int             free_engineID(int majorid, int minorid, void *serverarg,
+				  void *clientarg);
+    NETSNMP_IMPORT
+    int             parse_secLevel_conf(const char* word, char *cptr);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* SNMPV3_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/system.h quaggasnmpTrap//include/net-snmp/library/system.h
--- quagga-0.99.18//include/net-snmp/library/system.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/system.h	2010-10-17 23:15:00.000000000 -0700
@@ -0,0 +1,196 @@
+#ifndef SNMP_SYSTEM_H
+#define SNMP_SYSTEM_H
+
+#ifndef NET_SNMP_CONFIG_H
+#error "Please include <net-snmp/net-snmp-config.h> before this file"
+#endif
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+/* Portions of this file are subject to the following copyrights.  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ */
+/***********************************************************
+        Copyright 1993 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of CMU not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+******************************************************************/
+/*
+ * portions Copyright Â© 2003 Sun Microsystems, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
+
+    /*
+     * function to create a daemon. Will fork and call setsid().
+     *
+     * Returns: -1 : fork failed
+     *           0 : No errors
+     */
+    NETSNMP_IMPORT
+    int netsnmp_daemonize(int quit_immediately, int stderr_log);
+
+    /*
+     * Definitions for the system dependent library file
+     *
+     * Do not define 'struct direct' when MSVC_PERL is defined because a
+     * structure with that name is also defined in the Perl header
+     * lib\CORE\dirent.h. Do not declare gettimeofday() either.
+     */
+#ifndef MSVC_PERL
+
+#ifndef HAVE_READDIR
+    /*
+     * structure of a directory entry 
+     */
+    typedef struct direct {
+        long            d_ino;  /* inode number (not used by MS-DOS) */
+        int             d_namlen;       /* Name length */
+        char            d_name[257];    /* file name */
+    } _DIRECT;
+
+    /*
+     * structure for dir operations 
+     */
+    typedef struct _dir_struc {
+        char           *start;  /* Starting position */
+        char           *curr;   /* Current position */
+        long            size;   /* Size of string table */
+        long            nfiles; /* number if filenames in table */
+        struct direct   dirstr; /* Directory structure to return */
+    } DIR;
+
+    NETSNMP_IMPORT
+    DIR            *opendir(const char *filename);
+    NETSNMP_IMPORT
+    struct direct  *readdir(DIR * dirp);
+    NETSNMP_IMPORT
+    int             closedir(DIR * dirp);
+#endif /* HAVE_READDIR */
+
+#ifndef HAVE_GETTIMEOFDAY
+    NETSNMP_IMPORT
+    int             gettimeofday(struct timeval *, struct timezone *tz);
+#endif
+
+#endif                         /* MSVC_PERL */
+
+/*
+ * Note: when compiling Net-SNMP with dmalloc enabled on a system without
+ * strcasecmp() or strncasecmp(), the macro HAVE_STRNCASECMP is
+ * not defined but strcasecmp() and strncasecmp() are defined as macros in
+ * <dmalloc.h>. In order to prevent a compilation error, do not declare
+ * strcasecmp() or strncasecmp() when the <dmalloc.h> header has been included.
+ */
+#if !defined(HAVE_STRNCASECMP) && !defined(strcasecmp)
+    NETSNMP_IMPORT
+    int             strcasecmp(const char *s1, const char *s2);
+#endif
+#if !defined(HAVE_STRNCASECMP) && !defined(strncasecmp)
+    NETSNMP_IMPORT
+    int             strncasecmp(const char *s1, const char *s2, size_t n);
+#endif
+
+#ifdef WIN32
+    NETSNMP_IMPORT
+    char           *winsock_startup(void);
+    NETSNMP_IMPORT
+    void            winsock_cleanup(void);
+#define SOCK_STARTUP winsock_startup()
+#define SOCK_CLEANUP winsock_cleanup()
+#else                           /* !WIN32 */
+#define SOCK_STARTUP
+#define SOCK_CLEANUP
+#endif                          /* WIN32 */
+
+#include <net-snmp/types.h>     /* For definition of in_addr_t */
+
+    /* Simply resolve a hostname and return first IPv4 address.
+     * Returns -1 on error */
+    NETSNMP_IMPORT
+    int             netsnmp_gethostbyname_v4(const char* name,
+                                             in_addr_t *addr_out);
+
+    NETSNMP_IMPORT
+    in_addr_t       get_myaddr(void);
+    NETSNMP_IMPORT
+    long            get_uptime(void);
+
+#ifndef HAVE_STRDUP
+    char           *strdup(const char *);
+#endif
+#ifndef HAVE_SETENV
+    NETSNMP_IMPORT
+    int             setenv(const char *, const char *, int);
+#endif
+
+    NETSNMP_IMPORT
+    int             calculate_time_diff(const struct timeval *,
+                                        const struct timeval *);
+    NETSNMP_IMPORT
+    u_int           calculate_sectime_diff(const struct timeval *now,
+                                           const struct timeval *then);
+
+#ifndef HAVE_STRCASESTR
+    char           *strcasestr(const char *, const char *);
+#endif
+#ifndef HAVE_STRTOL
+    long            strtol(const char *, char **, int);
+#endif
+#ifndef HAVE_STRTOUL
+    unsigned long   strtoul(const char *, char **, int);
+#endif
+#ifndef HAVE_STRTOULL
+    NETSNMP_IMPORT uint64_t strtoull(const char *, char **, int);
+#endif
+#ifndef HAVE_STRTOK_R
+    NETSNMP_IMPORT
+    char           *strtok_r(char *, const char *, char **);
+#endif
+#ifndef HAVE_SNPRINTF
+    int             snprintf(char *, size_t, const char *, ...);
+#endif
+
+    NETSNMP_IMPORT
+    int             mkdirhier(const char *pathname, mode_t mode,
+                              int skiplast);
+    NETSNMP_IMPORT
+    const char     *netsnmp_mktemp(void);
+#ifndef HAVE_STRLCPY
+    NETSNMP_IMPORT
+    size_t            strlcpy(char *, const char *, size_t);
+#endif
+
+    int             netsnmp_os_prematch(const char *ospmname,
+                                        const char *ospmrelprefix);
+    int             netsnmp_os_kernel_width(void);
+
+    NETSNMP_IMPORT
+    int             netsnmp_str_to_uid(const char *useroruid);
+    NETSNMP_IMPORT
+    int             netsnmp_str_to_gid(const char *grouporgid);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* SNMP_SYSTEM_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/testing.h quaggasnmpTrap//include/net-snmp/library/testing.h
--- quagga-0.99.18//include/net-snmp/library/testing.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/testing.h	2010-05-17 11:43:03.000000000 -0700
@@ -0,0 +1,16 @@
+#ifndef NETSNMP_LIBRARY_TESTING_H
+#define NETSNMP_LIBRARY_TESTING_H
+
+/* These are macros used for the net-snmp testing infrastructure; see
+   the "testing" subdirectory of the source code for details. */
+
+static int __test_counter = 0;
+static int __did_plan = 0;
+
+#define OK(isok, description) { printf("%s %d - %s\n", ((isok) ? "ok" : "not ok"), ++__test_counter, description); }
+
+#define OKF(isok, description) { printf("%s %d - \n", ((isok) ? "ok" : "not ok"), ++__test_counter); printf description; printf("\n"); }
+
+#define PLAN(number) { printf("1..%d\n", number); __did_plan = 1;}
+
+#endif /* NETSNMP_LIBRARY_TESTING_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/text_utils.h quaggasnmpTrap//include/net-snmp/library/text_utils.h
--- quagga-0.99.18//include/net-snmp/library/text_utils.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/text_utils.h	2009-10-05 12:19:18.000000000 -0700
@@ -0,0 +1,113 @@
+#ifndef NETSNMP_TEXT_UTILS_H
+#define NETSNMP_TEXT_UTILS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    
+    /*------------------------------------------------------------------
+     *
+     * text file processing
+     *
+     */
+    netsnmp_container *
+    netsnmp_file_text_parse(netsnmp_file *f, netsnmp_container *cin,
+                            int parse_mode, u_int flags, void *context);
+
+#define PM_SAVE_EVERYTHING                                             1
+#define PM_INDEX_STRING_STRING                                         2
+#define PM_USER_FUNCTION                                               3
+
+#define PM_FLAG_NO_CONTAINER                                  0x00000001
+#define PM_FLAG_SKIP_WHITESPACE                               0x00000002
+
+
+    /*
+     * line processing user function
+     */
+    struct netsnmp_line_process_info_s; /* fwd decl */
+
+    typedef struct netsnmp_line_info_s {
+
+        size_t                     index;
+
+        char                      *line;
+        size_t                     line_len;
+        size_t                     line_max;
+
+        char                      *start;
+        size_t                     start_len;
+
+    } netsnmp_line_info;
+
+    typedef int (Netsnmp_Process_Text_Line)
+        (netsnmp_line_info *line_info, void *mem,
+         struct netsnmp_line_process_info_s* lpi);
+
+    typedef struct netsnmp_line_process_info_s {
+
+        size_t                     line_max; /* defaults to STRINGMAX if 0 */
+        size_t                     mem_size;
+
+        u_int                      flags;
+
+        Netsnmp_Process_Text_Line *process;
+
+        void                      *user_context;
+        
+    } netsnmp_line_process_info;
+    
+/*
+ * user function return codes
+ */
+#define PMLP_RC_STOP_PROCESSING                           -1
+#define PMLP_RC_MEMORY_USED                                0
+#define PMLP_RC_MEMORY_UNUSED                              1
+
+    
+/** ALLOC_LINE: wasteful, but fast */
+#define PMLP_FLAG_ALLOC_LINE                               0x00000001
+/** STRDUP_LINE: slower if you don't keep memory in most cases */
+#define PMLP_FLAG_STRDUP_LINE                              0x00000002
+/** don't strip trailing newlines */
+#define PMLP_FLAG_LEAVE_NEWLINE                            0x00000004
+/** don't skip blank or comment lines */
+#define PMLP_FLAG_PROCESS_WHITESPACE                       0x00000008
+/** just process line, don't save it */
+#define PMLP_FLAG_NO_CONTAINER                             0x00000010
+    
+
+    /*
+     * a few useful pre-defined helpers
+     */
+
+    typedef struct netsnmp_token_value_index_s {
+
+        char               *token;
+        netsnmp_cvalue      value;
+        size_t              index;
+
+    } netsnmp_token_value_index;
+
+    netsnmp_container *netsnmp_text_token_container_from_file(const char *file,
+                                                              u_int flags,
+                                                              netsnmp_container *c,
+                                                              void *context);
+/*
+ * flags
+ */
+#define NSTTC_FLAG_TYPE_CONTEXT_DIRECT                      0x00000001
+
+
+#define PMLP_TYPE_UNSIGNED                                  1
+#define PMLP_TYPE_INTEGER                                   2
+#define PMLP_TYPE_STRING                                    3
+#define PMLP_TYPE_BOOLEAN                                   4
+
+        
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* NETSNMP_TEXT_UTILS_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/tools.h quaggasnmpTrap//include/net-snmp/library/tools.h
--- quagga-0.99.18//include/net-snmp/library/tools.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/tools.h	2010-10-28 04:32:39.000000000 -0700
@@ -0,0 +1,299 @@
+/**
+ * @file library/tools.h
+ * @defgroup util Memory Utility Routines
+ * @ingroup library
+ * @{
+ */
+
+#ifndef _TOOLS_H
+#define _TOOLS_H
+
+#ifdef HAVE_INTTYPES_H
+#include <inttypes.h> /* uintptr_t */
+#endif
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+
+
+    /*
+     * General acros and constants.
+     */
+#ifdef WIN32
+#  define SNMP_MAXPATH MAX_PATH
+#else
+#  ifdef PATH_MAX
+#    define SNMP_MAXPATH PATH_MAX
+#  else
+#    ifdef MAXPATHLEN
+#      define SNMP_MAXPATH MAXPATHLEN
+#    else
+#      define SNMP_MAXPATH 1024		/* Should be safe enough */
+#    endif
+#  endif
+#endif
+
+#define SNMP_MAXBUF		(1024 * 4)
+#define SNMP_MAXBUF_MEDIUM	1024
+#define SNMP_MAXBUF_SMALL	512
+
+#define SNMP_MAXBUF_MESSAGE	1500
+
+#define SNMP_MAXOID		64
+#define SNMP_MAX_CMDLINE_OIDS	128
+
+#define SNMP_FILEMODE_CLOSED	0600
+#define SNMP_FILEMODE_OPEN	0644
+
+#define BYTESIZE(bitsize)       ((bitsize + 7) >> 3)
+#define ROUNDUP8(x)		( ( (x+7) >> 3 ) * 8 )
+
+#define SNMP_STRORNULL(x)       ( x ? x : "(null)")
+
+/** @def SNMP_FREE(s)
+    Frees a pointer only if it is !NULL and sets its value to NULL */
+#define SNMP_FREE(s)    do { if (s) { free((void *)s); s=NULL; } } while(0)
+
+/** @def SNMP_SWIPE_MEM(n, s)
+    Frees pointer n only if it is !NULL, sets n to s and sets s to NULL */
+#define SNMP_SWIPE_MEM(n,s) do { if (n) free((void *)n); n = s; s=NULL; } while(0)
+
+    /*
+     * XXX Not optimal everywhere. 
+     */
+/** @def SNMP_MALLOC_STRUCT(s)
+    Mallocs memory of sizeof(struct s), zeros it and returns a pointer to it. */
+#define SNMP_MALLOC_STRUCT(s)   (struct s *) calloc(1, sizeof(struct s))
+
+/** @def SNMP_MALLOC_TYPEDEF(t)
+    Mallocs memory of sizeof(t), zeros it and returns a pointer to it. */
+#define SNMP_MALLOC_TYPEDEF(td)  (td *) calloc(1, sizeof(td))
+
+/** @def SNMP_ZERO(s,l)
+    Zeros l bytes of memory starting at s. */
+#define SNMP_ZERO(s,l)	do { if (s) memset(s, 0, l); } while(0)
+
+
+/**
+ * @def NETSNMP_REMOVE_CONST(t, e)
+ *
+ * Cast away constness without that gcc -Wcast-qual prints a compiler warning,
+ * similar to const_cast<> in C++.
+ *
+ * @param[in] t A pointer type.
+ * @param[in] e An expression of a type that can be assigned to the type (const t).
+ */
+#if defined(__GNUC__)
+#define NETSNMP_REMOVE_CONST(t, e)                                      \
+    (__extension__ ({ const t tmp = (e); (t)(uintptr_t)tmp; }))
+#else
+#define NETSNMP_REMOVE_CONST(t, e) ((t)(uintptr_t)(e))
+#endif
+
+
+#define TOUPPER(c)	(c >= 'a' && c <= 'z' ? c - ('a' - 'A') : c)
+#define TOLOWER(c)	(c >= 'A' && c <= 'Z' ? c + ('a' - 'A') : c)
+
+#define HEX2VAL(s) \
+	((isalpha(s) ? (TOLOWER(s)-'a'+10) : (TOLOWER(s)-'0')) & 0xf)
+#define VAL2HEX(s)	( (s) + (((s) >= 10) ? ('a'-10) : '0') )
+
+
+/** @def SNMP_MAX(a, b)
+    Computers the maximum of a and b. */
+#define SNMP_MAX(a,b) ((a) > (b) ? (a) : (b))
+
+/** @def SNMP_MIN(a, b)
+    Computers the minimum of a and b. */
+#define SNMP_MIN(a,b) ((a) > (b) ? (b) : (a))
+
+/** @def SNMP_MACRO_VAL_TO_STR(s)
+ *  Expands to string with value of the s. 
+ *  If s is macro, the resulting string is value of the macro.
+ *  Example: 
+ *   #define TEST 1234
+ *   SNMP_MACRO_VAL_TO_STR(TEST) expands to "1234"
+ *   SNMP_MACRO_VAL_TO_STR(TEST+1) expands to "1234+1"
+ */
+#define SNMP_MACRO_VAL_TO_STR(s) SNMP_MACRO_VAL_TO_STR_PRIV(s)  
+#define SNMP_MACRO_VAL_TO_STR_PRIV(s) #s
+	
+#ifndef FALSE
+#define FALSE 0
+#endif
+#ifndef TRUE
+#define TRUE  1
+#endif
+
+    /*
+     * QUIT the FUNction:
+     *      e       Error code variable
+     *      l       Label to goto to cleanup and get out of the function.
+     *
+     * XXX  It would be nice if the label could be constructed by the
+     *      preprocessor in context.  Limited to a single error return value.
+     *      Temporary hack at best.
+     */
+#define QUITFUN(e, l)			\
+	if ( (e) != SNMPERR_SUCCESS) {	\
+		rval = SNMPERR_GENERR;	\
+		goto l ;		\
+	}
+
+    /*
+     * DIFFTIMEVAL
+     *      Set <diff> to the difference between <now> (current) and <then> (past).
+     *
+     * ASSUMES that all inputs are (struct timeval)'s.
+     * Cf. system.c:calculate_time_diff().
+     */
+#define DIFFTIMEVAL(now, then, diff) 			\
+{							\
+	now.tv_sec--;					\
+	now.tv_usec += 1000000L;			\
+	diff.tv_sec  = now.tv_sec  - then.tv_sec;	\
+	diff.tv_usec = now.tv_usec - then.tv_usec;	\
+	if (diff.tv_usec > 1000000L){			\
+		diff.tv_usec -= 1000000L;		\
+		diff.tv_sec++;				\
+	}						\
+}
+
+/**
+ * Compute res = a + b.
+ *
+ * @pre a and b must be normalized 'struct timeval' values.
+ *
+ * @note res may be the same variable as one of the operands. In other
+ *   words, &a == &res || &b == &res may hold.
+ */
+#define NETSNMP_TIMERADD(a, b, res)                  \
+{                                                    \
+    (res)->tv_sec  = (a)->tv_sec  + (b)->tv_sec;     \
+    (res)->tv_usec = (a)->tv_usec + (b)->tv_usec;    \
+    if ((res)->tv_usec >= 1000000L) {                \
+        (res)->tv_usec -= 1000000L;                  \
+        (res)->tv_sec++;                             \
+    }                                                \
+}
+
+/**
+ * Compute res = a - b.
+ *
+ * @pre a and b must be normalized 'struct timeval' values.
+ *
+ * @note res may be the same variable as one of the operands. In other
+ *   words, &a == &res || &b == &res may hold.
+ */
+#define NETSNMP_TIMERSUB(a, b, res)                             \
+{                                                               \
+    (res)->tv_sec  = (a)->tv_sec  - (b)->tv_sec - 1;            \
+    (res)->tv_usec = (a)->tv_usec - (b)->tv_usec + 1000000L;    \
+    if ((res)->tv_usec >= 1000000L) {                           \
+        (res)->tv_usec -= 1000000L;                             \
+        (res)->tv_sec++;                                        \
+    }                                                           \
+}
+
+
+    /*
+     * ISTRANSFORM
+     * ASSUMES the minimum length for ttype and toid.
+     */
+#define USM_LENGTH_OID_TRANSFORM	10
+
+#define ISTRANSFORM(ttype, toid)					\
+	!snmp_oid_compare(ttype, USM_LENGTH_OID_TRANSFORM,		\
+		usm ## toid ## Protocol, USM_LENGTH_OID_TRANSFORM)
+
+#define ENGINETIME_MAX	2147483647      /* ((2^31)-1) */
+#define ENGINEBOOT_MAX	2147483647      /* ((2^31)-1) */
+
+
+
+
+    /*
+     * Prototypes.
+     */
+
+    NETSNMP_IMPORT
+    int             snmp_realloc(u_char ** buf, size_t * buf_len);
+
+    void            free_zero(void *buf, size_t size);
+
+    u_char         *malloc_random(size_t * size);
+    u_char         *malloc_zero(size_t size);
+    NETSNMP_IMPORT
+    int             memdup(u_char ** to, const void * from, size_t size);
+
+    NETSNMP_IMPORT
+    u_int           netsnmp_binary_to_hex(u_char ** dest, size_t *dest_len,
+                                          int allow_realloc,
+                                          const u_char * input, size_t len);
+
+    NETSNMP_IMPORT
+    u_int           binary_to_hex(const u_char * input, size_t len,
+                                  char **output);
+                    /* preferred */
+    int             netsnmp_hex_to_binary(u_char ** buf, size_t * buf_len,
+                                         size_t * offset, int allow_realloc,
+                                         const char *hex, const char *delim);
+                    /* calls netsnmp_hex_to_binary w/delim of " " */
+    NETSNMP_IMPORT
+    int             snmp_hex_to_binary(u_char ** buf, size_t * buf_len,
+                                       size_t * offset, int allow_realloc,
+                                       const char *hex);
+                    /* handles odd lengths */
+    NETSNMP_IMPORT
+    int             hex_to_binary2(const u_char * input, size_t len,
+                                   char **output);
+
+    NETSNMP_IMPORT
+    int             snmp_decimal_to_binary(u_char ** buf, size_t * buf_len,
+                                           size_t * out_len,
+                                           int allow_realloc,
+                                           const char *decimal);
+#define snmp_cstrcat(b,l,o,a,s) snmp_strcat(b,l,o,a,(const u_char *)s)
+    NETSNMP_IMPORT
+    int             snmp_strcat(u_char ** buf, size_t * buf_len,
+                                size_t * out_len, int allow_realloc,
+                                const u_char * s);
+    NETSNMP_IMPORT
+    char           *netsnmp_strdup_and_null(const u_char * from,
+                                            size_t from_len);
+
+    NETSNMP_IMPORT
+    void            dump_chunk(const char *debugtoken, const char *title,
+                               const u_char * buf, int size);
+    char           *dump_snmpEngineID(const u_char * buf, size_t * buflen);
+
+    /** A pointer to an opaque time marker value. */
+    typedef void   *marker_t;
+    typedef const void* const_marker_t;
+
+    NETSNMP_IMPORT
+    marker_t        atime_newMarker(void);
+    NETSNMP_IMPORT
+    void            atime_setMarker(marker_t pm);
+    NETSNMP_IMPORT
+    long            atime_diff(const_marker_t first, const_marker_t second);
+    u_long          uatime_diff(const_marker_t first, const_marker_t second);       /* 1/1000th sec */
+    NETSNMP_IMPORT
+    u_long          uatime_hdiff(const_marker_t first, const_marker_t second);      /* 1/100th sec */
+    NETSNMP_IMPORT
+    int             atime_ready(const_marker_t pm, int deltaT);
+    int             uatime_ready(const_marker_t pm, unsigned int deltaT);
+
+    int             marker_tticks(const_marker_t pm);
+    int             timeval_tticks(const struct timeval *tv);
+    char            *netsnmp_getenv(const char *name);
+
+    int             netsnmp_addrstr_hton(char *ptr, size_t len);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* _TOOLS_H */
+/* @} */
diff -rupN quagga-0.99.18//include/net-snmp/library/transform_oids.h quaggasnmpTrap//include/net-snmp/library/transform_oids.h
--- quagga-0.99.18//include/net-snmp/library/transform_oids.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/transform_oids.h	2006-10-27 13:19:44.000000000 -0700
@@ -0,0 +1,39 @@
+#ifndef _net_snmp_transform_oids_h
+#define _net_snmp_transform_oids_h
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+/*
+ * transform_oids.h
+ *
+ * Numeric MIB names for auth and priv transforms.
+ */
+
+NETSNMP_IMPORT oid      usmNoAuthProtocol[10];  /* == { 1,3,6,1,6,3,10,1,1,1 }; */
+#ifndef NETSNMP_DISABLE_MD5
+NETSNMP_IMPORT oid      usmHMACMD5AuthProtocol[10];     /* == { 1,3,6,1,6,3,10,1,1,2 }; */
+#endif
+NETSNMP_IMPORT oid      usmHMACSHA1AuthProtocol[10];    /* == { 1,3,6,1,6,3,10,1,1,3 }; */
+NETSNMP_IMPORT oid      usmNoPrivProtocol[10];  /* == { 1,3,6,1,6,3,10,1,2,1 }; */
+#ifndef NETSNMP_DISABLE_DES
+NETSNMP_IMPORT oid      usmDESPrivProtocol[10]; /* == { 1,3,6,1,6,3,10,1,2,2 }; */
+#endif
+
+/* XXX: OIDs not defined yet */
+NETSNMP_IMPORT oid      usmAESPrivProtocol[10]; /* == { 1,3,6,1,6,3,10,1,2,4 }; */
+NETSNMP_IMPORT oid      *usmAES128PrivProtocol; /* backwards compat */
+
+#define USM_AUTH_PROTO_NOAUTH_LEN 10
+#define USM_AUTH_PROTO_MD5_LEN 10
+#define USM_AUTH_PROTO_SHA_LEN 10
+#define USM_PRIV_PROTO_NOPRIV_LEN 10
+#define USM_PRIV_PROTO_DES_LEN 10
+
+#define USM_PRIV_PROTO_AES_LEN 10
+#define USM_PRIV_PROTO_AES128_LEN 10 /* backwards compat */
+
+#ifdef __cplusplus
+}
+#endif
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/library/types.h quaggasnmpTrap//include/net-snmp/library/types.h
--- quagga-0.99.18//include/net-snmp/library/types.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/types.h	2010-02-18 01:45:35.000000000 -0800
@@ -0,0 +1,70 @@
+#ifndef NET_SNMP_LIBRARY_TYPES_H
+#define NET_SNMP_LIBRARY_TYPES_H
+
+#ifndef NET_SNMP_CONFIG_H
+#error "Please include <net-snmp/net-snmp-config.h> before this file"
+#endif
+
+
+#include <net-snmp/types.h>
+
+
+typedef struct netsnmp_index_s {
+    size_t          len;
+    oid            *oids;
+} netsnmp_index;
+
+typedef struct netsnmp_void_array_s {
+    size_t          size;
+    void          **array;
+} netsnmp_void_array;
+
+/*
+ * references to various types
+ */
+typedef struct netsnmp_ref_void {
+    void           *val;
+} netsnmp_ref_void;
+
+typedef union {
+    u_long          ul;
+    u_int           ui;
+    u_short         us;
+    u_char          uc;
+    long            sl;
+    int             si;
+    short           ss;
+    char            sc;
+    char           *cp;
+    void           *vp;
+} netsnmp_cvalue;
+
+typedef struct netsnmp_ref_size_t_s {
+    size_t          val;
+}              *netsnmp_ref_size_t;
+
+/*
+ * Structure for holding a set of file descriptors, similar to fd_set.
+ *
+ * This structure however can hold so-called large file descriptors
+ * (>= FD_SETSIZE or 1024) on Unix systems or more than FD_SETSIZE (64)
+ * sockets on Windows systems.
+ *
+ * It is safe to allocate this structure on the stack.
+ *
+ * This structure must be initialized by calling netsnmp_large_fd_set_init()
+ * and must be cleaned up via netsnmp_large_fd_set_cleanup(). If this last
+ * function is not called this may result in a memory leak.
+ *
+ * The members of this structure are:
+ * lfs_setsize: maximum set size.
+ * lsf_setptr:  points to lfs_set if lfs_setsize <= FD_SETSIZE, and otherwise
+ *              to dynamically allocated memory.
+ * lfs_set:     file descriptor / socket set data if lfs_setsize <= FD_SETSIZE.
+ */
+typedef struct netsnmp_large_fd_set_s {
+    unsigned        lfs_setsize;
+    fd_set         *lfs_setptr;
+    fd_set          lfs_set;
+} netsnmp_large_fd_set;
+#endif                          /* NET_SNMP_LIBRARY_TYPES_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/ucd_compat.h quaggasnmpTrap//include/net-snmp/library/ucd_compat.h
--- quagga-0.99.18//include/net-snmp/library/ucd_compat.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/ucd_compat.h	2010-09-20 12:25:47.000000000 -0700
@@ -0,0 +1,51 @@
+/*
+ *  UCD compatability definitions & declarations
+ *
+ */
+
+#ifndef NET_SNMP_UCD_COMPAT_H
+#define NET_SNMP_UCD_COMPAT_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+        /*
+         * from snmp_api.h 
+         */
+NETSNMP_IMPORT
+void            snmp_set_dump_packet(int);
+NETSNMP_IMPORT
+int             snmp_get_dump_packet(void);
+NETSNMP_IMPORT
+void            snmp_set_quick_print(int);
+NETSNMP_IMPORT
+int             snmp_get_quick_print(void);
+NETSNMP_IMPORT
+void            snmp_set_suffix_only(int);
+NETSNMP_IMPORT
+int             snmp_get_suffix_only(void);
+NETSNMP_IMPORT
+void            snmp_set_full_objid(int);
+int             snmp_get_full_objid(void);
+NETSNMP_IMPORT
+void            snmp_set_random_access(int);
+NETSNMP_IMPORT
+int             snmp_get_random_access(void);
+
+        /*
+         * from parse.h 
+         */
+NETSNMP_IMPORT
+void            snmp_set_mib_warnings(int);
+NETSNMP_IMPORT
+void            snmp_set_mib_errors(int);
+NETSNMP_IMPORT
+void            snmp_set_save_descriptions(int);
+void            snmp_set_mib_comment_term(int);
+void            snmp_set_mib_parse_label(int);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* NET_SNMP_UCD_COMPAT_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/vacm.h quaggasnmpTrap//include/net-snmp/library/vacm.h
--- quagga-0.99.18//include/net-snmp/library/vacm.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/vacm.h	2010-02-27 05:11:15.000000000 -0800
@@ -0,0 +1,266 @@
+/*
+ * vacm.h
+ *
+ * SNMPv3 View-based Access Control Model
+ */
+
+#ifndef VACM_H
+#define VACM_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#define VACM_SUCCESS       0
+#define VACM_NOSECNAME     1
+#define VACM_NOGROUP       2
+#define VACM_NOACCESS      3
+#define VACM_NOVIEW        4
+#define VACM_NOTINVIEW     5
+#define VACM_NOSUCHCONTEXT 6
+#define VACM_SUBTREE_UNKNOWN 7
+
+#define SECURITYMODEL	1
+#define SECURITYNAME	2
+#define SECURITYGROUP	3
+#define SECURITYSTORAGE	4
+#define SECURITYSTATUS	5
+
+#define ACCESSPREFIX	1
+#define ACCESSMODEL	2
+#define ACCESSLEVEL	3
+#define ACCESSMATCH	4
+#define ACCESSREAD	5
+#define ACCESSWRITE	6
+#define ACCESSNOTIFY	7
+#define ACCESSSTORAGE	8
+#define ACCESSSTATUS	9
+
+#define VACMVIEWSPINLOCK 1
+#define VIEWNAME	2
+#define VIEWSUBTREE	3
+#define VIEWMASK	4
+#define VIEWTYPE	5
+#define VIEWSTORAGE	6
+#define VIEWSTATUS	7
+
+#define VACM_MAX_STRING 32
+#define VACMSTRINGLEN   34      /* VACM_MAX_STRING + 2 */
+
+    struct vacm_groupEntry {
+        int             securityModel;
+        char            securityName[VACMSTRINGLEN];
+        char            groupName[VACMSTRINGLEN];
+        int             storageType;
+        int             status;
+
+        u_long          bitMask;
+        struct vacm_groupEntry *reserved;
+        struct vacm_groupEntry *next;
+    };
+
+#define CONTEXT_MATCH_EXACT  1
+#define CONTEXT_MATCH_PREFIX 2
+
+/* VIEW ENUMS ---------------------------------------- */
+
+/* SNMPD usage: get/set/send-notification views */
+#define VACM_VIEW_READ     0
+#define VACM_VIEW_WRITE    1
+#define VACM_VIEW_NOTIFY   2
+
+/* SNMPTRAPD usage: log execute and net-access (forward) usage */
+#define VACM_VIEW_LOG      3
+#define VACM_VIEW_EXECUTE  4
+#define VACM_VIEW_NET      5
+
+/* VIEW BIT MASK VALUES-------------------------------- */
+
+/* SNMPD usage: get/set/send-notification views */
+#define VACM_VIEW_READ_BIT      (1 << VACM_VIEW_READ)
+#define VACM_VIEW_WRITE_BIT     (1 << VACM_VIEW_WRITE)
+#define VACM_VIEW_NOTIFY_BIT    (1 << VACM_VIEW_NOTIFY)
+
+/* SNMPTRAPD usage: log execute and net-access (forward) usage */
+#define VACM_VIEW_LOG_BIT      (1 << VACM_VIEW_LOG)
+#define VACM_VIEW_EXECUTE_BIT  (1 << VACM_VIEW_EXECUTE)
+#define VACM_VIEW_NET_BIT      (1 << VACM_VIEW_NET)
+    
+#define VACM_VIEW_NO_BITS      0
+
+/* Maximum number of views in the view array */
+#define VACM_MAX_VIEWS     8
+
+#define VACM_VIEW_ENUM_NAME "vacmviews"
+    
+    void init_vacm(void);
+    
+    struct vacm_accessEntry {
+        char            groupName[VACMSTRINGLEN];
+        char            contextPrefix[VACMSTRINGLEN];
+        int             securityModel;
+        int             securityLevel;
+        int             contextMatch;
+        char            views[VACM_MAX_VIEWS][VACMSTRINGLEN];
+        int             storageType;
+        int             status;
+
+        u_long          bitMask;
+        struct vacm_accessEntry *reserved;
+        struct vacm_accessEntry *next;
+    };
+
+    struct vacm_viewEntry {
+        char            viewName[VACMSTRINGLEN];
+        oid             viewSubtree[MAX_OID_LEN];
+        size_t          viewSubtreeLen;
+        u_char          viewMask[VACMSTRINGLEN];
+        size_t          viewMaskLen;
+        int             viewType;
+        int             viewStorageType;
+        int             viewStatus;
+
+        u_long          bitMask;
+
+        struct vacm_viewEntry *reserved;
+        struct vacm_viewEntry *next;
+    };
+
+    NETSNMP_IMPORT
+    void            vacm_destroyViewEntry(const char *, oid *, size_t);
+    NETSNMP_IMPORT
+    void            vacm_destroyAllViewEntries(void);
+
+#define VACM_MODE_FIND                0
+#define VACM_MODE_IGNORE_MASK         1
+#define VACM_MODE_CHECK_SUBTREE       2
+    NETSNMP_IMPORT
+    struct vacm_viewEntry *vacm_getViewEntry(const char *, oid *, size_t,
+                                             int);
+    /*
+     * Returns a pointer to the viewEntry with the
+     * same viewName and viewSubtree
+     * Returns NULL if that entry does not exist.
+     */
+
+    NETSNMP_IMPORT
+    int vacm_checkSubtree(const char *, oid *, size_t);
+
+    /*
+     * Check to see if everything within a subtree is in view, not in view,
+     * or possibly both.
+     *
+     * Returns:
+     *   VACM_SUCCESS          The OID is included in the view.
+     *   VACM_NOTINVIEW        If no entry in the view list includes the
+     *                         provided OID, or the OID is explicitly excluded
+     *                         from the view. 
+     *   VACM_SUBTREE_UNKNOWN  The entire subtree has both allowed and
+     *                         disallowed portions.
+     */
+
+    NETSNMP_IMPORT
+    void
+                    vacm_scanViewInit(void);
+    /*
+     * Initialized the scan routines so that they will begin at the
+     * beginning of the list of viewEntries.
+     *
+     */
+
+
+    NETSNMP_IMPORT
+    struct vacm_viewEntry *vacm_scanViewNext(void);
+    /*
+     * Returns a pointer to the next viewEntry.
+     * These entries are returned in no particular order,
+     * but if N entries exist, N calls to view_scanNext() will
+     * return all N entries once.
+     * Returns NULL if all entries have been returned.
+     * view_scanInit() starts the scan over.
+     */
+
+    NETSNMP_IMPORT
+    struct vacm_viewEntry *vacm_createViewEntry(const char *, oid *,
+                                                size_t);
+    /*
+     * Creates a viewEntry with the given index
+     * and returns a pointer to it.
+     * The status of this entry is created as invalid.
+     */
+
+    NETSNMP_IMPORT
+    void            vacm_destroyGroupEntry(int, const char *);
+    NETSNMP_IMPORT
+    void            vacm_destroyAllGroupEntries(void);
+    NETSNMP_IMPORT
+    struct vacm_groupEntry *vacm_createGroupEntry(int, const char *);
+    NETSNMP_IMPORT
+    struct vacm_groupEntry *vacm_getGroupEntry(int, const char *);
+    NETSNMP_IMPORT
+    void            vacm_scanGroupInit(void);
+    NETSNMP_IMPORT
+    struct vacm_groupEntry *vacm_scanGroupNext(void);
+
+    NETSNMP_IMPORT
+    void            vacm_destroyAccessEntry(const char *, const char *,
+                                            int, int);
+    NETSNMP_IMPORT
+    void            vacm_destroyAllAccessEntries(void);
+    NETSNMP_IMPORT
+    struct vacm_accessEntry *vacm_createAccessEntry(const char *,
+                                                    const char *, int,
+                                                    int);
+    NETSNMP_IMPORT
+    struct vacm_accessEntry *vacm_getAccessEntry(const char *,
+                                                 const char *, int, int);
+    NETSNMP_IMPORT
+    void            vacm_scanAccessInit(void);
+    NETSNMP_IMPORT
+    struct vacm_accessEntry *vacm_scanAccessNext(void);
+
+    void            vacm_destroySecurityEntry(const char *);
+    struct vacm_securityEntry *vacm_createSecurityEntry(const char *);
+    struct vacm_securityEntry *vacm_getSecurityEntry(const char *);
+    void            vacm_scanSecurityInit(void);
+    struct vacm_securityEntry *vacm_scanSecurityEntry(void);
+    NETSNMP_IMPORT
+    int             vacm_is_configured(void);
+
+    void            vacm_save(const char *token, const char *type);
+    void            vacm_save_view(struct vacm_viewEntry *view,
+                                   const char *token, const char *type);
+    void            vacm_save_access(struct vacm_accessEntry *access_entry,
+                                     const char *token, const char *type);
+    void            vacm_save_auth_access(struct vacm_accessEntry *access_entry,
+                                     const char *token, const char *type, int authtype);
+    void            vacm_save_group(struct vacm_groupEntry *group_entry,
+                                    const char *token, const char *type);
+
+    NETSNMP_IMPORT
+    void            vacm_parse_config_view(const char *token, const char *line);
+    NETSNMP_IMPORT
+    void            vacm_parse_config_group(const char *token,
+                                            const char *line);
+    NETSNMP_IMPORT
+    void            vacm_parse_config_access(const char *token,
+                                             const char *line);
+    NETSNMP_IMPORT
+    void            vacm_parse_config_auth_access(const char *token,
+                                                  const char *line);
+
+    NETSNMP_IMPORT
+    int             store_vacm(int majorID, int minorID, void *serverarg,
+                               void *clientarg);
+
+    NETSNMP_IMPORT
+    struct vacm_viewEntry *netsnmp_view_get(struct vacm_viewEntry *head,
+                                            const char *viewName,
+                                            oid * viewSubtree,
+                                            size_t viewSubtreeLen, int mode);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* VACM_H */
diff -rupN quagga-0.99.18//include/net-snmp/library/winpipe.h quaggasnmpTrap//include/net-snmp/library/winpipe.h
--- quagga-0.99.18//include/net-snmp/library/winpipe.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/winpipe.h	2010-02-27 05:11:15.000000000 -0800
@@ -0,0 +1,44 @@
+/*
+  Copyright (c) Fabasoft R&D Software GmbH & Co KG, 2003
+  oss@fabasoft.com
+  Author: Bernhard Penz <bernhard.penz@fabasoft.com>
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions are met:
+
+  *  Redistributions of source code must retain the above copyright notice,
+     this list of conditions and the following disclaimer.
+
+  *  Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+
+  *  The name of Fabasoft R&D Software GmbH & Co KG or any of its subsidiaries, 
+     brand or product names may not be used to endorse or promote products 
+     derived from this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER ``AS IS'' AND ANY
+  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+  PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER BE
+  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+  OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+  IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#ifdef WIN32
+
+#ifndef WINPIPE_H
+#define WINPIPE_H
+
+NETSNMP_IMPORT
+int create_winpipe_transport(int *pipefds);
+
+#endif
+
+#endif
+
diff -rupN quagga-0.99.18//include/net-snmp/library/winservice.h quaggasnmpTrap//include/net-snmp/library/winservice.h
--- quagga-0.99.18//include/net-snmp/library/winservice.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/library/winservice.h	2010-01-24 02:31:04.000000000 -0800
@@ -0,0 +1,159 @@
+#ifndef WINSERVICE_H
+#define WINSERVICE_H
+
+    /*
+     * 
+     * Windows Service related functions declaration
+     * By Raju Krishanppa(raju_krishnappa@yahoo.com)
+     *
+     */
+
+#ifdef __cplusplus
+extern "C"
+{
+
+#endif				/*  */
+
+  /*
+   * Define Constants for Register, De-register , Run As service or Console mode
+   */
+#define REGISTER_SERVICE 0
+#define UN_REGISTER_SERVICE 1
+#define RUN_AS_SERVICE 2
+#define RUN_AS_CONSOLE 3
+
+
+  /*
+   * Error levels returned when registering or unregistering the service
+  */
+#define SERVICE_ERROR_NONE 0            
+#define SERVICE_ERROR_SCM_OPEN 1                /* Can not open SCM */
+#define SERVICE_ERROR_CREATE_SERVICE 2          /* Can not create service */
+#define SERVICE_ERROR_CREATE_REGISTRY_ENTRIES 3 /* Can not create registry entries */
+#define SERVICE_ERROR_OPEN_SERVICE 4            /* Can not open service (service does not exist) */
+ 
+  /*
+   * Define Message catalog ID
+   * MessageId: DISPLAY_MSG
+   * MessageText:  %1.
+   */
+#define DISPLAY_MSG                      0x00000064L
+
+  /*
+   * Hint Value to SCM to wait before sending successive commands to service
+   */
+#define SCM_WAIT_INTERVAL 7000
+
+  /*
+   * Define Generic String Size, to hold Error or Information
+   */
+#define MAX_STR_SIZE  1024
+
+  /*
+   * Delcare Global variables, which are visible to other modules 
+   */
+  extern BOOL g_fRunningAsService;
+
+  /*
+   * Input parameter structure to thread 
+   */
+  typedef struct _InputParams
+  {
+    DWORD Argc;
+    LPTSTR *Argv;
+  } InputParams;
+
+  /*
+   * Define Service Related functions
+   */
+
+  /*
+   * To register application as windows service with SCM 
+   */
+  int RegisterService (LPCTSTR lpszServiceName,
+			LPCTSTR lpszServiceDisplayName,
+			LPCTSTR lpszServiceDescription, InputParams * StartUpArg, int quiet);
+
+  /*
+   * To unregister service 
+   */
+  int UnregisterService (LPCTSTR lpszServiceName, int quiet);
+
+  /*
+   * To parse command line for startup option 
+   */
+  INT ParseCmdLineForServiceOption (INT argc, TCHAR * argv[], int *quiet);
+
+  /*
+   * To write to windows event log 
+   */
+  VOID WriteToEventLog (WORD wType, LPCTSTR pszFormat, ...);
+
+  /*
+   * To display generic windows error 
+   */
+  VOID DisplayError (LPCTSTR pszTitle, int quite);
+
+  /*
+   * Service Main function,  Which will spawn a thread, and calls the
+   * Service run part
+   */
+  VOID WINAPI ServiceMain (DWORD argc, LPTSTR argv[]);
+
+  /*
+   * To start Service 
+   */
+
+  BOOL RunAsService (INT (*ServiceFunction) (INT, LPTSTR *));
+
+  /*
+   * Call back function to process SCM Requests 
+   */
+  VOID WINAPI ControlHandler (DWORD dwControl);
+
+  /*
+   * To Stop the service 
+   */
+  VOID ProcessServiceStop (VOID);
+
+  /*
+   * To Pause service 
+   */
+  VOID ProcessServicePause (VOID);
+
+  /*
+   * To Continue paused service 
+   */
+  VOID ProcessServiceContinue (VOID);
+
+  /*
+   * To send Current Service status to SCM when INTERROGATE command is sent 
+   */
+  VOID ProcessServiceInterrogate (VOID);
+
+  /*
+   * To allocate and Set security descriptor 
+   */
+  BOOL SetSimpleSecurityAttributes (SECURITY_ATTRIBUTES * pSecurityAttr);
+
+  /*
+   * To free Security Descriptor 
+   */
+  VOID FreeSecurityAttributes (SECURITY_ATTRIBUTES * pSecurityAttr);
+
+  /*
+   * TheadFunction - To spawan as thread - Invokes registered service function 
+   */
+  unsigned WINAPI ThreadFunction (LPVOID lpParam);
+
+  /*
+   * Service STOP function registration with this framewrok
+   * * this function must be invoked before calling RunAsService
+   */
+  VOID RegisterStopFunction (VOID (*StopFunc) (VOID));
+
+#ifdef __cplusplus
+}
+#endif				/*  */
+#endif				/* WINSERVICE_H */
+
diff -rupN quagga-0.99.18//include/net-snmp/machine/generic.h quaggasnmpTrap//include/net-snmp/machine/generic.h
--- quagga-0.99.18//include/net-snmp/machine/generic.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/machine/generic.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,3 @@
+/*
+ * chip specific definitions go here 
+ */
diff -rupN quagga-0.99.18//include/net-snmp/mib_api.h quaggasnmpTrap//include/net-snmp/mib_api.h
--- quagga-0.99.18//include/net-snmp/mib_api.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/mib_api.h	2010-07-28 07:44:56.000000000 -0700
@@ -0,0 +1,113 @@
+#ifndef NET_SNMP_MIB_API_H
+#define NET_SNMP_MIB_API_H
+
+    /**
+     *  Library API routines concerned with MIB files and objects, and OIDs
+     */
+
+#include <net-snmp/types.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    /* Initialisation and Shutdown */
+    NETSNMP_IMPORT
+    int             add_mibdir(const char *);
+
+    NETSNMP_IMPORT
+    void            netsnmp_init_mib(void);
+#ifndef NETSNMP_NO_LEGACY_DEFINITIONS
+    NETSNMP_IMPORT
+    void            init_mib(void);
+    NETSNMP_IMPORT
+    void            init_mib_internals(void);
+#endif
+    NETSNMP_IMPORT
+    void            shutdown_mib(void);
+
+     /* Reading and Parsing MIBs */
+    NETSNMP_IMPORT
+    struct tree    *netsnmp_read_module(const char *);
+#ifndef NETSNMP_NO_LEGACY_DEFINITIONS
+    NETSNMP_IMPORT
+    struct tree    *read_module(const char *);
+#endif
+
+    NETSNMP_IMPORT
+    struct tree    *read_mib(const char *);
+    NETSNMP_IMPORT
+    struct tree    *read_all_mibs(void);
+
+    NETSNMP_IMPORT
+    void            add_module_replacement(const char *, const char *,
+                                           const char *, int);
+
+         /* from ucd-compat.h */
+    NETSNMP_IMPORT
+    void            snmp_set_mib_warnings(int);
+    NETSNMP_IMPORT
+    void            snmp_set_mib_errors(int);
+    NETSNMP_IMPORT
+    void            snmp_set_save_descriptions(int);
+
+
+     /* Searching the MIB Tree */
+    NETSNMP_IMPORT
+    int             read_objid(const char *, oid *, size_t *);
+    NETSNMP_IMPORT
+    oid            *snmp_parse_oid(const char *, oid *, size_t *);
+    NETSNMP_IMPORT
+    int             get_module_node(const char *, const char *, oid *, size_t *);
+
+     /* Output */
+    NETSNMP_IMPORT
+    void            print_mib(FILE * fp);
+
+    NETSNMP_IMPORT
+    void            print_objid(const oid * objid, size_t objidlen);
+    NETSNMP_IMPORT
+    void           fprint_objid(FILE * fp,
+                                const oid * objid, size_t objidlen);
+    NETSNMP_IMPORT
+    int           snprint_objid(char *buf, size_t buf_len,
+                                const oid * objid, size_t objidlen);
+
+    NETSNMP_IMPORT
+    void            print_description(oid * objid, size_t objidlen, int width);
+    NETSNMP_IMPORT
+    void           fprint_description(FILE * fp,
+                                oid * objid, size_t objidlen, int width);
+    NETSNMP_IMPORT
+    int           snprint_description(char *buf, size_t buf_len,
+                                oid * objid, size_t objidlen, int width);
+
+#ifdef __cplusplus
+}
+#endif
+
+    /*
+     *    Having extracted the main ("public API") calls relevant
+     *  to this area of the Net-SNMP project, the next step is to
+     *  identify the related "public internal API" routines.
+     *
+     *    In due course, these should probably be gathered
+     *  together into a companion 'library/mib_api.h' header file.
+     *  [Or some suitable name]
+     *
+     *    But for the time being, the expectation is that the
+     *  traditional headers that provided the above definitions
+     *  will probably also cover the relevant internal API calls.
+     *  Hence they are listed here:
+     */
+
+#include <net-snmp/library/snmp_api.h>
+#include <net-snmp/library/mib.h>
+#ifndef NETSNMP_DISABLE_MIB_LOADING
+#include <net-snmp/library/parse.h>
+#endif
+#include <net-snmp/library/callback.h>
+#include <net-snmp/library/oid_stash.h>
+#include <net-snmp/library/ucd_compat.h>
+
+#endif                          /* NET_SNMP_MIB_API_H */
diff -rupN quagga-0.99.18//include/net-snmp/net-snmp-config.h.in quaggasnmpTrap//include/net-snmp/net-snmp-config.h.in
--- quagga-0.99.18//include/net-snmp/net-snmp-config.h.in	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/net-snmp-config.h.in	2010-11-29 21:56:25.000000000 -0800
@@ -0,0 +1,2340 @@
+/* include/net-snmp/net-snmp-config.h.in.  Generated from configure.ac by autoheader.  */
+/* 
+ * net-snmp configuration header file
+ *
+ * NOTE: DO NOT EDIT include/net-snmp/net-snmp-config.h.in as your changes
+ *       will be overwritten. This content is in acconfig.h and merged
+ *       into include/net-snmp/net-snmp-config.h.in by autoheader.
+ */
+/* Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ */
+/*
+ * Portions of this file are copyrighted by:
+ * Copyright Â© 2003 Sun Microsystems, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
+#ifndef NET_SNMP_CONFIG_H
+#define NET_SNMP_CONFIG_H
+
+
+/* ********* NETSNMP_MARK_BEGIN_AUTOCONF_DEFINITIONS ********* */
+/*
+ * put all autoconf-specific definitions below here
+ *
+ */
+#ifndef NETSNMP_NO_AUTOCONF_DEFINITIONS
+
+
+#if defined (WIN32) || defined (mingw32) || defined (cygwin)
+#define ENV_SEPARATOR ";"
+#define ENV_SEPARATOR_CHAR ';'
+#else
+#define ENV_SEPARATOR ":"
+#define ENV_SEPARATOR_CHAR ':'
+#endif
+
+/* definitions added by configure on-the-fly */
+
+#define config_belongs_in(x)
+
+#define config_exclude(x)
+
+#define config_arch_require(x,y)
+
+#define config_version_require(x)
+
+#define config_require(x)
+
+#define config_add_mib(x)
+
+#define config_parse_dot_conf(w,x,y,z)
+
+#define config_error(x)
+
+#define config_warning(x)
+
+/* Define if building universal (internal helper macro) */
+#undef AC_APPLE_UNIVERSAL_BUILD
+
+/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
+   systems. This function is required for `alloca.c' support on those systems.
+   */
+#undef CRAY_STACKSEG_END
+
+/* Define to 1 if using `alloca.c'. */
+#undef C_ALLOCA
+
+/* location of swap device */
+#undef DMEM_LOC
+
+/* location of mount table list */
+#undef ETC_MNTTAB
+
+/* Define to 1 if you have the `AES_cfb128_encrypt' function. */
+#undef HAVE_AES_CFB128_ENCRYPT
+
+/* Define to 1 if you have `alloca', as a function or macro. */
+#undef HAVE_ALLOCA
+
+/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
+   */
+#undef HAVE_ALLOCA_H
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+#undef HAVE_ARPA_INET_H
+
+/* Define to 1 if you have the <asm/page.h> header file. */
+#undef HAVE_ASM_PAGE_H
+
+/* Define to 1 if you have the <asm/types.h> header file. */
+#undef HAVE_ASM_TYPES_H
+
+/* Define to 1 if you have the `cgetnext' function. */
+#undef HAVE_CGETNEXT
+
+/* Define to 1 if you have the `chown' function. */
+#undef HAVE_CHOWN
+
+/* Define to 1 if you have the `closedir' function. */
+#undef HAVE_CLOSEDIR
+
+/* Define to 1 if the system has the type `Counter64'. */
+#undef HAVE_COUNTER64
+
+/* Define to 1 if you have the declaration of `sensors_get_all_subfeatures',
+   and to 0 if you don't. */
+#undef HAVE_DECL_SENSORS_GET_ALL_SUBFEATURES
+
+/* define to 1 if you have IRE_CACHE defined in <inet/ip.h> header file. */
+#undef HAVE_DEFINED_IRE_CACHE
+
+/* define if you have devstat_getdevs() */
+#undef HAVE_DEVSTAT_GETDEVS
+
+/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
+   */
+#undef HAVE_DIRENT_H
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#undef HAVE_DLFCN_H
+
+/* Define to 1 if you have the `dlopen' function. */
+#undef HAVE_DLOPEN
+
+/* Define to 1 if you have the <dmalloc.h> header file. */
+#undef HAVE_DMALLOC_H
+
+/* Set if the dpkg-query command is available */
+#undef HAVE_DPKG_QUERY
+
+/* Define to 1 if you have the <err.h> header file. */
+#undef HAVE_ERR_H
+
+/* Define to 1 if you have the `eval_pv' function. */
+#undef HAVE_EVAL_PV
+
+/* Define to 1 if you have the `execv' function. */
+#undef HAVE_EXECV
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#undef HAVE_FCNTL_H
+
+/* Define to 1 if you have the `fork' function. */
+#undef HAVE_FORK
+
+/* Define to 1 if you have the <fstab.h> header file. */
+#undef HAVE_FSTAB_H
+
+/* Define to 1 if you have the `gai_strerror' function. */
+#undef HAVE_GAI_STRERROR
+
+/* Define to 1 if you have the `getaddrinfo' function. */
+#undef HAVE_GETADDRINFO
+
+/* define if you have getdevs() */
+#undef HAVE_GETDEVS
+
+/* Define to 1 if you have the `getdtablesize' function. */
+#undef HAVE_GETDTABLESIZE
+
+/* Define to 1 if you have the `getfsstat' function. */
+#undef HAVE_GETFSSTAT
+
+/* Define to 1 if you have the `getgrnam' function. */
+#undef HAVE_GETGRNAM
+
+/* Define to 1 if you have the `gethostbyname' function. */
+#undef HAVE_GETHOSTBYNAME
+
+/* Define to 1 if you have the `gethostname' function. */
+#undef HAVE_GETHOSTNAME
+
+/* Define to 1 if you have the `getipnodebyname' function. */
+#undef HAVE_GETIPNODEBYNAME
+
+/* Define to 1 if you have the `getloadavg' function. */
+#undef HAVE_GETLOADAVG
+
+/* Define to 1 if you have the `getmntent' function. */
+#undef HAVE_GETMNTENT
+
+/* Define to 1 if you have the `getopt' function. */
+#undef HAVE_GETOPT
+
+/* Define to 1 if you have the <getopt.h> header file. */
+#undef HAVE_GETOPT_H
+
+/* Define to 1 if you have the `getpagesize' function. */
+#undef HAVE_GETPAGESIZE
+
+/* Define to 1 if you have the `getpid' function. */
+#undef HAVE_GETPID
+
+/* Define to 1 if you have the `getpwnam' function. */
+#undef HAVE_GETPWNAM
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#undef HAVE_GETTIMEOFDAY
+
+/* Define to 1 if you have the `getvfsstat' function. */
+#undef HAVE_GETVFSSTAT
+
+/* Define to 1 if you have the <grp.h> header file. */
+#undef HAVE_GRP_H
+
+/* Define to 1 if you have the `hasmntopt' function. */
+#undef HAVE_HASMNTOPT
+
+/* Define to 1 if you have the `if_freenameindex' function. */
+#undef HAVE_IF_FREENAMEINDEX
+
+/* Define to 1 if you have the `if_nameindex' function. */
+#undef HAVE_IF_NAMEINDEX
+
+/* Define to 1 if you have the `if_nametoindex' function. */
+#undef HAVE_IF_NAMETOINDEX
+
+/* Define to 1 if you have the <inet/common.h> header file. */
+#undef HAVE_INET_COMMON_H
+
+/* Define to 1 if you have the <inet/ip.h> header file. */
+#undef HAVE_INET_IP_H
+
+/* Define to 1 if you have the <inet/mib2.h> header file. */
+#undef HAVE_INET_MIB2_H
+
+/* Define to 1 if you have the `inet_ntop' function. */
+#undef HAVE_INET_NTOP
+
+/* Define to 1 if you have the `inet_pton' function. */
+#undef HAVE_INET_PTON
+
+/* Define to 1 if you have the `initgroups' function. */
+#undef HAVE_INITGROUPS
+
+/* Define to 1 if the system has the type `intmax_t'. */
+#undef HAVE_INTMAX_T
+
+/* Define to 1 if the system has the type `intptr_t'. */
+#undef HAVE_INTPTR_T
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if the system has the type `in_addr_t'. */
+#undef HAVE_IN_ADDR_T
+
+/* Define to 1 if you have the <ioctls.h> header file. */
+#undef HAVE_IOCTLS_H
+
+/* Define to 1 if you have the <io.h> header file. */
+#undef HAVE_IO_H
+
+/* Define to 1 if you have the <iphlpapi.h> header file. */
+#undef HAVE_IPHLPAPI_H
+
+/* Define to 1 if you have the `knlist' function. */
+#undef HAVE_KNLIST
+
+/* Define to 1 if you have the <kstat.h> header file. */
+#undef HAVE_KSTAT_H
+
+/* Define to 1 if you have the `kvm_getprocs' function. */
+#undef HAVE_KVM_GETPROCS
+
+/* Define to 1 if you have the `kvm_getswapinfo' function. */
+#undef HAVE_KVM_GETSWAPINFO
+
+/* Define to 1 if you have the <kvm.h> header file. */
+#undef HAVE_KVM_H
+
+/* Define to 1 if you have the `kvm_openfiles' function. */
+#undef HAVE_KVM_OPENFILES
+
+/* Define to 1 if you have the OpenSSL library (-lcrypto or -leay32). */
+#undef HAVE_LIBCRYPTO
+
+/* Define to 1 if you have the `elf' library (-lelf). */
+#undef HAVE_LIBELF
+
+/* Define to 1 if you have the `kstat' library (-lkstat). */
+#undef HAVE_LIBKSTAT
+
+/* Define to 1 if you have the `mld' library (-lmld). */
+#undef HAVE_LIBMLD
+
+/* define if you have libnm */
+#undef HAVE_LIBNM
+
+/* Define to 1 if you have the `nsl' library (-lnsl). */
+#undef HAVE_LIBNSL
+
+/* Define to 1 if you have the <libperfstat.h> header file. */
+#undef HAVE_LIBPERFSTAT_H
+
+/* Define to 1 if you have the `pkcs11' library (-lpkcs11). */
+#undef HAVE_LIBPKCS11
+
+/* Define to 1 if you have the `rpm' library (-lrpm). */
+#undef HAVE_LIBRPM
+
+/* Define to 1 if you have the `RSAglue' library (-lRSAglue). */
+#undef HAVE_LIBRSAGLUE
+
+/* Define to 1 if you have the `rsaref' library (-lrsaref). */
+#undef HAVE_LIBRSAREF
+
+/* Define to 1 if you have the `ssh2' library (-lssh2). */
+#undef HAVE_LIBSSH2
+
+/* Define to 1 if you have the `ssl' library (-lssl). */
+#undef HAVE_LIBSSL
+
+/* Define to 1 if your `ssl' library supports DTLS (-lssl). */
+#undef HAVE_LIBSSL_DTLS
+
+/* Define to 1 if you have the <limits.h> header file. */
+#undef HAVE_LIMITS_H
+
+/* Define to 1 if you have the <linux/ethtool.h> header file. */
+#undef HAVE_LINUX_ETHTOOL_H
+
+/* Define to 1 if `speed_hi' is member of `struct ethtool_cmd'. */
+#undef HAVE_STRUCT_ETHTOOL_CMD_SPEED_HI
+
+/* Define to 1 if you have the <linux/hdreg.h> header file. */
+#undef HAVE_LINUX_HDREG_H
+
+/* Define to 1 if you have the <linux/netlink.h> header file. */
+#undef HAVE_LINUX_NETLINK_H
+
+/* Define to 1 if you have the <linux/rtnetlink.h> header file. */
+#undef HAVE_LINUX_RTNETLINK_H
+
+/* Define to 1 if you have the <linux/tasks.h> header file. */
+#undef HAVE_LINUX_TASKS_H
+
+/* Define to 1 if you have the <locale.h> header file. */
+#undef HAVE_LOCALE_H
+
+/* Define to 1 if you have the `localtime_r' function. */
+#undef HAVE_LOCALTIME_R
+
+/* Define to 1 if the system has the type `long long int'. */
+#undef HAVE_LONG_LONG_INT
+
+/* Set if the lpstat command is available */
+#undef HAVE_LPSTAT
+
+/* Define to 1 if you have the `lrand48' function. */
+#undef HAVE_LRAND48
+
+/* Define to 1 if you have the `lseek64' function. */
+#undef HAVE_LSEEK64
+
+/* Define to 1 if you have the <machine/param.h> header file. */
+#undef HAVE_MACHINE_PARAM_H
+
+/* Define to 1 if you have the <machine/pte.h> header file. */
+#undef HAVE_MACHINE_PTE_H
+
+/* Define to 1 if you have the <machine/types.h> header file. */
+#undef HAVE_MACHINE_TYPES_H
+
+/* Define to 1 if you have the <malloc.h> header file. */
+#undef HAVE_MALLOC_H
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if the system has the type `mib2_ipIfStatsEntry_t'. */
+#undef HAVE_MIB2_IPIFSTATSENTRY_T
+
+/* Define to 1 if you have the `mkstemp' function. */
+#undef HAVE_MKSTEMP
+
+/* Define to 1 if you have the `mktime' function. */
+#undef HAVE_MKTIME
+
+/* Define to 1 if you have the <mntent.h> header file. */
+#undef HAVE_MNTENT_H
+
+/* Define to 1 if you have the <mtab.h> header file. */
+#undef HAVE_MTAB_H
+
+/* Define to 1 if you have the <mysql/mysql.h> header file. */
+#undef HAVE_MYSQL_MYSQL_H
+
+/* Define to 1 if you have the <nbutil.h> header file. */
+#undef HAVE_NBUTIL_H
+
+/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
+#undef HAVE_NDIR_H
+
+/* Define to 1 if you have the <netdb.h> header file. */
+#undef HAVE_NETDB_H
+
+/* Define to 1 if you have the <netinet6/in6_pcb.h> header file. */
+#undef HAVE_NETINET6_IN6_PCB_H
+
+/* Define to 1 if you have the <netinet6/in6_var.h> header file. */
+#undef HAVE_NETINET6_IN6_VAR_H
+
+/* Define to 1 if you have the <netinet6/ip6_var.h> header file. */
+#undef HAVE_NETINET6_IP6_VAR_H
+
+/* Define to 1 if you have the <netinet6/nd6.h> header file. */
+#undef HAVE_NETINET6_ND6_H
+
+/* Define to 1 if you have the <netinet6/tcp6_fsm.h> header file. */
+#undef HAVE_NETINET6_TCP6_FSM_H
+
+/* Define to 1 if you have the <netinet6/tcp6.h> header file. */
+#undef HAVE_NETINET6_TCP6_H
+
+/* Define to 1 if you have the <netinet6/tcp6_timer.h> header file. */
+#undef HAVE_NETINET6_TCP6_TIMER_H
+
+/* Define to 1 if you have the <netinet6/tcp6_var.h> header file. */
+#undef HAVE_NETINET6_TCP6_VAR_H
+
+/* Define to 1 if you have the <netinet/icmp6.h> header file. */
+#undef HAVE_NETINET_ICMP6_H
+
+/* Define to 1 if you have the <netinet/icmp_var.h> header file. */
+#undef HAVE_NETINET_ICMP_VAR_H
+
+/* Define to 1 if you have the <netinet/if_ether.h> header file. */
+#undef HAVE_NETINET_IF_ETHER_H
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#undef HAVE_NETINET_IN_H
+
+/* Define to 1 if you have the <netinet/in_pcb.h> header file. */
+#undef HAVE_NETINET_IN_PCB_H
+
+/* Define to 1 if you have the <netinet/in_systm.h> header file. */
+#undef HAVE_NETINET_IN_SYSTM_H
+
+/* Define to 1 if you have the <netinet/in_var.h> header file. */
+#undef HAVE_NETINET_IN_VAR_H
+
+/* Define to 1 if you have the <netinet/ip6.h> header file. */
+#undef HAVE_NETINET_IP6_H
+
+/* Define to 1 if you have the <netinet/ip.h> header file. */
+#undef HAVE_NETINET_IP_H
+
+/* Define to 1 if you have the <netinet/ip_icmp.h> header file. */
+#undef HAVE_NETINET_IP_ICMP_H
+
+/* Define to 1 if you have the <netinet/ip_var.h> header file. */
+#undef HAVE_NETINET_IP_VAR_H
+
+/* Define to 1 if you have the <netinet/tcpip.h> header file. */
+#undef HAVE_NETINET_TCPIP_H
+
+/* Define to 1 if you have the <netinet/tcp_fsm.h> header file. */
+#undef HAVE_NETINET_TCP_FSM_H
+
+/* Define to 1 if you have the <netinet/tcp.h> header file. */
+#undef HAVE_NETINET_TCP_H
+
+/* Define to 1 if you have the <netinet/tcp_timer.h> header file. */
+#undef HAVE_NETINET_TCP_TIMER_H
+
+/* Define to 1 if you have the <netinet/tcp_var.h> header file. */
+#undef HAVE_NETINET_TCP_VAR_H
+
+/* Define to 1 if you have the <netinet/udp.h> header file. */
+#undef HAVE_NETINET_UDP_H
+
+/* Define to 1 if you have the <netinet/udp_var.h> header file. */
+#undef HAVE_NETINET_UDP_VAR_H
+
+/* Define to 1 if you have the <netipx/ipx.h> header file. */
+#undef HAVE_NETIPX_IPX_H
+
+/* Define to 1 if you have the <netlink/netlink.h> header file. */
+#undef HAVE_NETLINK_NETLINK_H
+
+/* Define to 1 if you have the <net/if_arp.h> header file. */
+#undef HAVE_NET_IF_ARP_H
+
+/* Define to 1 if you have the <net/if_dl.h> header file. */
+#undef HAVE_NET_IF_DL_H
+
+/* Define to 1 if you have the <net/if.h> header file. */
+#undef HAVE_NET_IF_H
+
+/* Define to 1 if you have the <net/if_mib.h> header file. */
+#undef HAVE_NET_IF_MIB_H
+
+/* Define to 1 if you have the <net/if_types.h> header file. */
+#undef HAVE_NET_IF_TYPES_H
+
+/* Define to 1 if you have the <net/if_var.h> header file. */
+#undef HAVE_NET_IF_VAR_H
+
+/* Define to 1 if you have the <net/route.h> header file. */
+#undef HAVE_NET_ROUTE_H
+
+/* Define to 1 if the system has the type `nfds_t'. */
+#undef HAVE_NFDS_T
+
+/* Define to 1 if you have the `nlist' function. */
+#undef HAVE_NLIST
+
+/* Define to 1 if you have the `nlist64' function. */
+#undef HAVE_NLIST64
+
+/* Define to 1 if you have the <nlist.h> header file. */
+#undef HAVE_NLIST_H
+
+/* Define to 1 if the system has the type `off64_t'. */
+#undef HAVE_OFF64_T
+
+/* Define to 1 if you have the `opendir' function. */
+#undef HAVE_OPENDIR
+
+/* Define to 1 if you have the <openssl/aes.h> header file. */
+#undef HAVE_OPENSSL_AES_H
+
+/* Define to 1 if you have the <openssl/des.h> header file. */
+#undef HAVE_OPENSSL_DES_H
+
+/* Define to 1 if you have the <openssl/dh.h> header file. */
+#undef HAVE_OPENSSL_DH_H
+
+/* Define to 1 if you have the <openssl/evp.h> header file. */
+#undef HAVE_OPENSSL_EVP_H
+
+/* Define to 1 if you have the <openssl/hmac.h> header file. */
+#undef HAVE_OPENSSL_HMAC_H
+
+/* Define to 1 if you have the <osreldate.h> header file. */
+#undef HAVE_OSRELDATE_H
+
+/* Define to 1 if you have the <pci/pci.h> header file. */
+#undef HAVE_PCI_PCI_H
+
+/* on aix, if you have perfstat */
+#undef HAVE_PERFSTAT
+
+/* Define to 1 if you have `the perl_eval_pv' function. */
+#undef HAVE_PERL_EVAL_PV_LC
+
+/* Define to 1 if you have the `Perl_eval_pv' function. */
+#undef HAVE_PERL_EVAL_PV_UC
+
+/* Define to 1 if you have the <picl.h> header file. */
+#undef HAVE_PICL_H
+
+/* define if you have pkginfo */
+#undef HAVE_PKGINFO
+
+/* Define to 1 if you have the <pkginfo.h> header file. */
+#undef HAVE_PKGINFO_H
+
+/* Define to 1 if you have the <pkglocs.h> header file. */
+#undef HAVE_PKGLOCS_H
+
+/* Define to 1 if you have the `poll' function. */
+#undef HAVE_POLL
+
+/* Define to 1 if you have the `pread64' function. */
+#undef HAVE_PREAD64
+
+/* Set if /etc/printcap exists */
+#undef HAVE_PRINTCAP
+
+/* Define to 1 if you have the <pthread.h> header file. */
+#undef HAVE_PTHREAD_H
+
+/* Define to 1 if you have the <pwd.h> header file. */
+#undef HAVE_PWD_H
+
+/* Define to 1 if you have the `rand' function. */
+#undef HAVE_RAND
+
+/* Define to 1 if you have the `random' function. */
+#undef HAVE_RANDOM
+
+/* Define to 1 if you have the `readdir' function. */
+#undef HAVE_READDIR
+
+/* Define to 1 if you have the `regcomp' function. */
+#undef HAVE_REGCOMP
+
+/* Define to 1 if you have the <regex.h> header file. */
+#undef HAVE_REGEX_H
+
+/* Define to 1 if you have the `rpmGetPath' function. */
+#undef HAVE_RPMGETPATH
+
+/* Define to 1 if you have the <rpm/header.h> header file. */
+#undef HAVE_RPM_HEADER_H
+
+/* Define to 1 if you have the <rpm/rpmdb.h> header file. */
+#undef HAVE_RPM_RPMDB_H
+
+/* Define to 1 if you have the <rpm/rpmfileutil.h> header file. */
+#undef HAVE_RPM_RPMFILEUTIL_H
+
+/* Define to 1 if you have the <rpm/rpmlib.h> header file. */
+#undef HAVE_RPM_RPMLIB_H
+
+/* Define to 1 if you have the <search.h> header file. */
+#undef HAVE_SEARCH_H
+
+/* Define to 1 if you have the <security/cryptoki.h> header file. */
+#undef HAVE_SECURITY_CRYPTOKI_H
+
+/* Define to 1 if you have the `select' function. */
+#undef HAVE_SELECT
+
+/* Define to 1 if you have the <sensors/sensors.h> header file. */
+#undef HAVE_SENSORS_SENSORS_H
+
+/* Define to 1 if you have the `setenv' function. */
+#undef HAVE_SETENV
+
+/* Define to 1 if you have the `setgid' function. */
+#undef HAVE_SETGID
+
+/* Define to 1 if you have the `setgroups' function. */
+#undef HAVE_SETGROUPS
+
+/* Define to 1 if you have the `setitimer' function. */
+#undef HAVE_SETITIMER
+
+/* Define to 1 if you have the `setlocale' function. */
+#undef HAVE_SETLOCALE
+
+/* Define to 1 if you have the `setmntent' function. */
+#undef HAVE_SETMNTENT
+
+/* Define to 1 if you have the `setsid' function. */
+#undef HAVE_SETSID
+
+/* Define to 1 if you have the `setuid' function. */
+#undef HAVE_SETUID
+
+/* Define to 1 if you have the <sgtty.h> header file. */
+#undef HAVE_SGTTY_H
+
+/* Define to 1 if you have the `sigaction' function. */
+#undef HAVE_SIGACTION
+
+/* Define to 1 if you have the `sigalrm' function. */
+#undef HAVE_SIGALRM
+
+/* Define to 1 if you have the `sigblock' function. */
+#undef HAVE_SIGBLOCK
+
+/* Define to 1 if you have the `sighold' function. */
+#undef HAVE_SIGHOLD
+
+/* Define if SIGHUP is defined in <signal.h>. */
+#undef HAVE_SIGHUP
+
+/* Define to 1 if you have the `signal' function. */
+#undef HAVE_SIGNAL
+
+/* Define to 1 if you have the `sigprocmask' function. */
+#undef HAVE_SIGPROCMASK
+
+/* Define to 1 if you have the `sigset' function. */
+#undef HAVE_SIGSET
+
+/* Define to 1 if you have the `snprintf' function. */
+#undef HAVE_SNPRINTF
+
+/* Define to 1 if you have the `socket' function. */
+#undef HAVE_SOCKET
+
+/* Define to 1 if the system has the type `socklen_t'. */
+#undef HAVE_SOCKLEN_T
+
+/* Define to 1 if the system has the type `ssize_t'. */
+#undef HAVE_SSIZE_T
+
+/* Define to 1 if you have the `statfs' function. */
+#undef HAVE_STATFS
+
+/* Define to 1 if you have the `statvfs' function. */
+#undef HAVE_STATVFS
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the `stime' function. */
+#undef HAVE_STIME
+
+/* Define to 1 if you have the `strcasestr' function. */
+#undef HAVE_STRCASESTR
+
+/* Define to 1 if you have the `strdup' function. */
+#undef HAVE_STRDUP
+
+/* Define to 1 if you have the `strerror' function. */
+#undef HAVE_STRERROR
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the `strlcpy' function. */
+#undef HAVE_STRLCPY
+
+/* Define to 1 if you have the `strncasecmp' function. */
+#undef HAVE_STRNCASECMP
+
+/* Define to 1 if you have the `strtok_r' function. */
+#undef HAVE_STRTOK_R
+
+/* Define to 1 if you have the `strtol' function. */
+#undef HAVE_STRTOL
+
+/* Define to 1 if you have the `strtoul' function. */
+#undef HAVE_STRTOUL
+
+/* Define to 1 if you have the `strtoull' function. */
+#undef HAVE_STRTOULL
+
+/* Define to 1 if `at_next' is member of `struct arphd'. */
+#undef HAVE_STRUCT_ARPHD_AT_NEXT
+
+/* Define to 1 if `weak_key' is member of `struct des_ks_struct'. */
+#undef HAVE_STRUCT_DES_KS_STRUCT_WEAK_KEY
+
+/* Define to 1 if `d_type' is member of `struct dirent'. */
+#undef HAVE_STRUCT_DIRENT_D_TYPE
+
+/* Define to 1 if `ifa_next' is member of `struct ifaddr'. */
+#undef HAVE_STRUCT_IFADDR_IFA_NEXT
+
+/* Define to 1 if `if_addrhead.tqh_first' is member of `struct ifnet'. */
+#undef HAVE_STRUCT_IFNET_IF_ADDRHEAD_TQH_FIRST
+
+/* Define to 1 if `if_addrlist' is member of `struct ifnet'. */
+#undef HAVE_STRUCT_IFNET_IF_ADDRLIST
+
+/* Define to 1 if `if_baudrate' is member of `struct ifnet'. */
+#undef HAVE_STRUCT_IFNET_IF_BAUDRATE
+
+/* Define to 1 if `if_baudrate.ifs_value' is member of `struct ifnet'. */
+#undef HAVE_STRUCT_IFNET_IF_BAUDRATE_IFS_VALUE
+
+/* Define to 1 if `if_ibytes' is member of `struct ifnet'. */
+#undef HAVE_STRUCT_IFNET_IF_IBYTES
+
+/* Define to 1 if `if_imcasts' is member of `struct ifnet'. */
+#undef HAVE_STRUCT_IFNET_IF_IMCASTS
+
+/* Define to 1 if `if_iqdrops' is member of `struct ifnet'. */
+#undef HAVE_STRUCT_IFNET_IF_IQDROPS
+
+/* Define to 1 if `if_lastchange.tv_sec' is member of `struct ifnet'. */
+#undef HAVE_STRUCT_IFNET_IF_LASTCHANGE_TV_SEC
+
+/* Define to 1 if `if_mtu' is member of `struct ifnet'. */
+#undef HAVE_STRUCT_IFNET_IF_MTU
+
+/* Define to 1 if `if_noproto' is member of `struct ifnet'. */
+#undef HAVE_STRUCT_IFNET_IF_NOPROTO
+
+/* Define to 1 if `if_obytes' is member of `struct ifnet'. */
+#undef HAVE_STRUCT_IFNET_IF_OBYTES
+
+/* Define to 1 if `if_omcasts' is member of `struct ifnet'. */
+#undef HAVE_STRUCT_IFNET_IF_OMCASTS
+
+/* Define to 1 if `if_speed' is member of `struct ifnet'. */
+#undef HAVE_STRUCT_IFNET_IF_SPEED
+
+/* Define to 1 if `if_type' is member of `struct ifnet'. */
+#undef HAVE_STRUCT_IFNET_IF_TYPE
+
+/* Define to 1 if `if_xname' is member of `struct ifnet'. */
+#undef HAVE_STRUCT_IFNET_IF_XNAME
+
+/* Define to 1 if `ips_cantforward' is member of `struct ipstat'. */
+#undef HAVE_STRUCT_IPSTAT_IPS_CANTFORWARD
+
+/* Define to 1 if `ips_cantfrag' is member of `struct ipstat'. */
+#undef HAVE_STRUCT_IPSTAT_IPS_CANTFRAG
+
+/* Define to 1 if `ips_delivered' is member of `struct ipstat'. */
+#undef HAVE_STRUCT_IPSTAT_IPS_DELIVERED
+
+/* Define to 1 if `ips_fragdropped' is member of `struct ipstat'. */
+#undef HAVE_STRUCT_IPSTAT_IPS_FRAGDROPPED
+
+/* Define to 1 if `ips_fragmented' is member of `struct ipstat'. */
+#undef HAVE_STRUCT_IPSTAT_IPS_FRAGMENTED
+
+/* Define to 1 if `ips_fragtimeout' is member of `struct ipstat'. */
+#undef HAVE_STRUCT_IPSTAT_IPS_FRAGTIMEOUT
+
+/* Define to 1 if `ips_localout' is member of `struct ipstat'. */
+#undef HAVE_STRUCT_IPSTAT_IPS_LOCALOUT
+
+/* Define to 1 if `ips_noproto' is member of `struct ipstat'. */
+#undef HAVE_STRUCT_IPSTAT_IPS_NOPROTO
+
+/* Define to 1 if `ips_noroute' is member of `struct ipstat'. */
+#undef HAVE_STRUCT_IPSTAT_IPS_NOROUTE
+
+/* Define to 1 if `ips_odropped' is member of `struct ipstat'. */
+#undef HAVE_STRUCT_IPSTAT_IPS_ODROPPED
+
+/* Define to 1 if `ips_ofragments' is member of `struct ipstat'. */
+#undef HAVE_STRUCT_IPSTAT_IPS_OFRAGMENTS
+
+/* Define to 1 if `ips_reassembled' is member of `struct ipstat'. */
+#undef HAVE_STRUCT_IPSTAT_IPS_REASSEMBLED
+
+/* Define to 1 if `m_clfree' is member of `struct mbstat'. */
+#undef HAVE_STRUCT_MBSTAT_M_CLFREE
+
+/* Define to 1 if `m_clusters' is member of `struct mbstat'. */
+#undef HAVE_STRUCT_MBSTAT_M_CLUSTERS
+
+/* Define to 1 if `m_mbufs' is member of `struct mbstat'. */
+#undef HAVE_STRUCT_MBSTAT_M_MBUFS
+
+/* Define to 1 if `n_value' is member of `struct nlist64'. */
+#undef HAVE_STRUCT_NLIST64_N_VALUE
+
+/* Define to 1 if `n_value' is member of `struct nlist'. */
+#undef HAVE_STRUCT_NLIST_N_VALUE
+
+/* Define to 1 if `rt_dst' is member of `struct rtentry'. */
+#undef HAVE_STRUCT_RTENTRY_RT_DST
+
+/* Define to 1 if `rt_hash' is member of `struct rtentry'. */
+#undef HAVE_STRUCT_RTENTRY_RT_HASH
+
+/* Define to 1 if `rt_next' is member of `struct rtentry'. */
+#undef HAVE_STRUCT_RTENTRY_RT_NEXT
+
+/* Define to 1 if `rt_refcnt' is member of `struct rtentry'. */
+#undef HAVE_STRUCT_RTENTRY_RT_REFCNT
+
+/* Define to 1 if `rt_unit' is member of `struct rtentry'. */
+#undef HAVE_STRUCT_RTENTRY_RT_UNIT
+
+/* Define to 1 if `rt_use' is member of `struct rtentry'. */
+#undef HAVE_STRUCT_RTENTRY_RT_USE
+
+/* Define to 1 if `sa_sigaction' is member of `struct sigaction'. */
+#undef HAVE_STRUCT_SIGACTION_SA_SIGACTION
+
+/* Define to 1 if `sin6_scope_id' is member of `struct sockaddr_in6'. */
+#undef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID
+
+/* Define to 1 if `sa_len' is member of `struct sockaddr'. */
+#undef HAVE_STRUCT_SOCKADDR_SA_LEN
+
+/* Define to 1 if `sa_union.sa_generic.sa_family2' is member of `struct
+   sockaddr'. */
+#undef HAVE_STRUCT_SOCKADDR_SA_UNION_SA_GENERIC_SA_FAMILY2
+
+/* Define to 1 if `ss_family' is member of `struct sockaddr_storage'. */
+#undef HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY
+
+/* Define to 1 if `__ss_family' is member of `struct sockaddr_storage'. */
+#undef HAVE_STRUCT_SOCKADDR_STORAGE___SS_FAMILY
+
+/* Define to 1 if `f_favail' is member of `struct statfs'. */
+#undef HAVE_STRUCT_STATFS_F_FAVAIL
+
+/* Define to 1 if `f_ffree' is member of `struct statfs'. */
+#undef HAVE_STRUCT_STATFS_F_FFREE
+
+/* Define to 1 if `f_files' is member of `struct statfs'. */
+#undef HAVE_STRUCT_STATFS_F_FILES
+
+/* Define to 1 if `f_flags' is member of `struct statfs'. */
+#undef HAVE_STRUCT_STATFS_F_FLAGS
+
+/* Define to 1 if `f_frsize' is member of `struct statfs'. */
+#undef HAVE_STRUCT_STATFS_F_FRSIZE
+
+/* Define to 1 if `f_files' is member of `struct statvfs'. */
+#undef HAVE_STRUCT_STATVFS_F_FILES
+
+/* Define to 1 if `f_frsize' is member of `struct statvfs'. */
+#undef HAVE_STRUCT_STATVFS_F_FRSIZE
+
+/* Define to 1 if `mnt_dir' is member of `struct statvfs'. */
+#undef HAVE_STRUCT_STATVFS_MNT_DIR
+
+/* Define to 1 if `sw_nblksenabled' is member of `struct swdevt'. */
+#undef HAVE_STRUCT_SWDEVT_SW_NBLKSENABLED
+
+/* Define to 1 if `tcp_rcvmemdrop' is member of `struct tcpstat'. */
+#undef HAVE_STRUCT_TCPSTAT_TCP_RCVMEMDROP
+
+/* Define to 1 if `tz_dsttime' is member of `struct timezone'. */
+#undef HAVE_STRUCT_TIMEZONE_TZ_DSTTIME
+
+/* Define to 1 if `tm_gmtoff' is member of `struct tm'. */
+#undef HAVE_STRUCT_TM_TM_GMTOFF
+
+/* Define to 1 if `udps_discard' is member of `struct udpstat'. */
+#undef HAVE_STRUCT_UDPSTAT_UDPS_DISCARD
+
+/* Define to 1 if `udps_fullsock' is member of `struct udpstat'. */
+#undef HAVE_STRUCT_UDPSTAT_UDPS_FULLSOCK
+
+/* Define to 1 if `udps_noport' is member of `struct udpstat'. */
+#undef HAVE_STRUCT_UDPSTAT_UDPS_NOPORT
+
+/* Define to 1 if `udps_noportbcast' is member of `struct udpstat'. */
+#undef HAVE_STRUCT_UDPSTAT_UDPS_NOPORTBCAST
+
+/* Define to 1 if `udps_opackets' is member of `struct udpstat'. */
+#undef HAVE_STRUCT_UDPSTAT_UDPS_OPACKETS
+
+/* Define to 1 if you have the `sysconf' function. */
+#undef HAVE_SYSCONF
+
+/* Define to 1 if you have the <syslog.h> header file. */
+#undef HAVE_SYSLOG_H
+
+/* Define to 1 if you have the `system' function. */
+#undef HAVE_SYSTEM
+
+/* Define to 1 if you have the <sys/cdefs.h> header file. */
+#undef HAVE_SYS_CDEFS_H
+
+/* Define to 1 if you have the <sys/conf.h> header file. */
+#undef HAVE_SYS_CONF_H
+
+/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
+   */
+#undef HAVE_SYS_DIR_H
+
+/* Define to 1 if you have the <sys/diskio.h> header file. */
+#undef HAVE_SYS_DISKIO_H
+
+/* Define to 1 if you have the <sys/disklabel.h> header file. */
+#undef HAVE_SYS_DISKLABEL_H
+
+/* Define to 1 if you have the <sys/dkio.h> header file. */
+#undef HAVE_SYS_DKIO_H
+
+/* Define to 1 if you have the <sys/dkstat.h> header file. */
+#undef HAVE_SYS_DKSTAT_H
+
+/* Define to 1 if you have the <sys/dmap.h> header file. */
+#undef HAVE_SYS_DMAP_H
+
+/* Define to 1 if you have the <sys/file.h> header file. */
+#undef HAVE_SYS_FILE_H
+
+/* Define to 1 if you have the <sys/filio.h> header file. */
+#undef HAVE_SYS_FILIO_H
+
+/* Define to 1 if you have the <sys/fixpoint.h> header file. */
+#undef HAVE_SYS_FIXPOINT_H
+
+/* Define to 1 if you have the <sys/fs.h> header file. */
+#undef HAVE_SYS_FS_H
+
+/* Define to 1 if you have the <sys/hashing.h> header file. */
+#undef HAVE_SYS_HASHING_H
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#undef HAVE_SYS_IOCTL_H
+
+/* Define to 1 if you have the <sys/loadavg.h> header file. */
+#undef HAVE_SYS_LOADAVG_H
+
+/* Define to 1 if you have the <sys/mbuf.h> header file. */
+#undef HAVE_SYS_MBUF_H
+
+/* Define to 1 if you have the <sys/mntent.h> header file. */
+#undef HAVE_SYS_MNTENT_H
+
+/* Define to 1 if you have the <sys/mnttab.h> header file. */
+#undef HAVE_SYS_MNTTAB_H
+
+/* Define to 1 if you have the <sys/mount.h> header file. */
+#undef HAVE_SYS_MOUNT_H
+
+/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
+   */
+#undef HAVE_SYS_NDIR_H
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#undef HAVE_SYS_PARAM_H
+
+/* Define to 1 if you have the <sys/poll.h> header file. */
+#undef HAVE_SYS_POLL_H
+
+/* Define to 1 if you have the <sys/pool.h> header file. */
+#undef HAVE_SYS_POOL_H
+
+/* Define to 1 if you have the <sys/proc.h> header file. */
+#undef HAVE_SYS_PROC_H
+
+/* Define to 1 if you have the <sys/protosw.h> header file. */
+#undef HAVE_SYS_PROTOSW_H
+
+/* Define to 1 if you have the <sys/pstat.h> header file. */
+#undef HAVE_SYS_PSTAT_H
+
+/* Define to 1 if you have the <sys/queue.h> header file. */
+#undef HAVE_SYS_QUEUE_H
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#undef HAVE_SYS_SELECT_H
+
+/* Define to 1 if you have the <sys/sema.h> header file. */
+#undef HAVE_SYS_SEMA_H
+
+/* Define to 1 if you have the <sys/socketvar.h> header file. */
+#undef HAVE_SYS_SOCKETVAR_H
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#undef HAVE_SYS_SOCKET_H
+
+/* Define to 1 if you have the <sys/sockio.h> header file. */
+#undef HAVE_SYS_SOCKIO_H
+
+/* Define to 1 if you have the <sys/statfs.h> header file. */
+#undef HAVE_SYS_STATFS_H
+
+/* Define to 1 if you have the <sys/statvfs.h> header file. */
+#undef HAVE_SYS_STATVFS_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/stream.h> header file. */
+#undef HAVE_SYS_STREAM_H
+
+/* Define to 1 if you have the <sys/swap.h> header file. */
+#undef HAVE_SYS_SWAP_H
+
+/* Define to 1 if you have the <sys/sysctl.h> header file. */
+#undef HAVE_SYS_SYSCTL_H
+
+/* Define to 1 if you have the <sys/sysget.h> header file. */
+#undef HAVE_SYS_SYSGET_H
+
+/* Define to 1 if you have the <sys/sysmp.h> header file. */
+#undef HAVE_SYS_SYSMP_H
+
+/* Define to 1 if you have the <sys/systemcfg.h> header file. */
+#undef HAVE_SYS_SYSTEMCFG_H
+
+/* Define to 1 if you have the <sys/systeminfo.h> header file. */
+#undef HAVE_SYS_SYSTEMINFO_H
+
+/* Define to 1 if you have the <sys/tcpipstats.h> header file. */
+#undef HAVE_SYS_TCPIPSTATS_H
+
+/* Define to 1 if you have the <sys/timeb.h> header file. */
+#undef HAVE_SYS_TIMEB_H
+
+/* Define to 1 if you have the <sys/timeout.h> header file. */
+#undef HAVE_SYS_TIMEOUT_H
+
+/* Define to 1 if you have the <sys/times.h> header file. */
+#undef HAVE_SYS_TIMES_H
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#undef HAVE_SYS_TIME_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <sys/uio.h> header file. */
+#undef HAVE_SYS_UIO_H
+
+/* Define to 1 if you have the <sys/un.h> header file. */
+#undef HAVE_SYS_UN_H
+
+/* Define to 1 if you have the <sys/user.h> header file. */
+#undef HAVE_SYS_USER_H
+
+/* Define to 1 if you have the <sys/utsname.h> header file. */
+#undef HAVE_SYS_UTSNAME_H
+
+/* Define to 1 if you have the <sys/vfs.h> header file. */
+#undef HAVE_SYS_VFS_H
+
+/* Define to 1 if you have the <sys/vmmac.h> header file. */
+#undef HAVE_SYS_VMMAC_H
+
+/* Define to 1 if you have the <sys/vmmeter.h> header file. */
+#undef HAVE_SYS_VMMETER_H
+
+/* Define to 1 if you have the <sys/vmparam.h> header file. */
+#undef HAVE_SYS_VMPARAM_H
+
+/* Define to 1 if you have the <sys/vmsystm.h> header file. */
+#undef HAVE_SYS_VMSYSTM_H
+
+/* Define to 1 if you have the <sys/vm.h> header file. */
+#undef HAVE_SYS_VM_H
+
+/* Define to 1 if you have the <sys/vnode.h> header file. */
+#undef HAVE_SYS_VNODE_H
+
+/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
+#undef HAVE_SYS_WAIT_H
+
+/* Define to 1 if you have the `tcgetattr' function. */
+#undef HAVE_TCGETATTR
+
+/* Define to 1 if you have the `times' function. */
+#undef HAVE_TIMES
+
+/* Define to 1 if you have the <ufs/ffs/fs.h> header file. */
+#undef HAVE_UFS_FFS_FS_H
+
+/* Define to 1 if you have the <ufs/fs.h> header file. */
+#undef HAVE_UFS_FS_H
+
+/* Define to 1 if you have the <ufs/ufs/dinode.h> header file. */
+#undef HAVE_UFS_UFS_DINODE_H
+
+/* Define to 1 if you have the <ufs/ufs/inode.h> header file. */
+#undef HAVE_UFS_UFS_INODE_H
+
+/* Define to 1 if you have the <ufs/ufs/quota.h> header file. */
+#undef HAVE_UFS_UFS_QUOTA_H
+
+/* Define to 1 if the system has the type `uintmax_t'. */
+#undef HAVE_UINTMAX_T
+
+/* Define to 1 if the system has the type `uintptr_t'. */
+#undef HAVE_UINTPTR_T
+
+/* Define to 1 if you have the `uname' function. */
+#undef HAVE_UNAME
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to 1 if the system has the type `unsigned long long int'. */
+#undef HAVE_UNSIGNED_LONG_LONG_INT
+
+/* Define to 1 if you have the `usleep' function. */
+#undef HAVE_USLEEP
+
+/* Define to 1 if you have the <utmpx.h> header file. */
+#undef HAVE_UTMPX_H
+
+/* Define to 1 if you have the <utsname.h> header file. */
+#undef HAVE_UTSNAME_H
+
+/* Define to 1 if you have the <uvm/uvm_extern.h> header file. */
+#undef HAVE_UVM_UVM_EXTERN_H
+
+/* Define to 1 if you have the <uvm/uvm_param.h> header file. */
+#undef HAVE_UVM_UVM_PARAM_H
+
+/* Define to 1 if you have the <vm/swap_pager.h> header file. */
+#undef HAVE_VM_SWAP_PAGER_H
+
+/* Define to 1 if you have the <vm/vm_extern.h> header file. */
+#undef HAVE_VM_VM_EXTERN_H
+
+/* Define to 1 if you have the <vm/vm.h> header file. */
+#undef HAVE_VM_VM_H
+
+/* Define to 1 if you have the <vm/vm_param.h> header file. */
+#undef HAVE_VM_VM_PARAM_H
+
+/* Define to 1 if you have the `vsnprintf' function. */
+#undef HAVE_VSNPRINTF
+
+/* Define to 1 if you have the <windows.h> header file. */
+#undef HAVE_WINDOWS_H
+
+/* Define to 1 if you have the <winsock2.h> header file. */
+#undef HAVE_WINSOCK2_H
+
+/* Define to 1 if you have the <winsock.h> header file. */
+#undef HAVE_WINSOCK_H
+
+/* Define to 1 if you have the <ws2tcpip.h> header file. */
+#undef HAVE_WS2TCPIP_H
+
+/* Define to 1 if you have the <xti.h> header file. */
+#undef HAVE_XTI_H
+
+/* location of UNIX kernel */
+#undef KERNEL_LOC
+
+/* Path to the lpstat command */
+#undef LPSTAT_PATH
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#undef LT_OBJDIR
+
+/* define if agentx transport is to use domain sockets only */
+#undef NETSNMP_AGENTX_DOM_SOCK_ONLY
+
+/* Unix domain socket for AgentX master-subagent communication */
+#undef NETSNMP_AGENTX_SOCKET
+
+/* Define if static inline functions are unsupported */
+#undef NETSNMP_BROKEN_INLINE
+
+/* "Define if crytography support is possible" */
+#undef NETSNMP_CAN_DO_CRYPTO
+
+/* sysctl works to get boottime, etc... */
+#undef NETSNMP_CAN_USE_SYSCTL
+
+/* configure options specified */
+#undef NETSNMP_CONFIGURE_OPTIONS
+
+/* default location to look for mibs to load using the above tokens and/or
+   those in the MIBS envrionment variable */
+#undef NETSNMP_DEFAULT_MIBDIRS
+
+/* default mib files to load, specified by path. */
+#undef NETSNMP_DEFAULT_MIBFILES
+
+/* Define if DES encryption should not be supported */
+#undef NETSNMP_DISABLE_DES
+
+/* Define if MD5 authentication should not be supported */
+#undef NETSNMP_DISABLE_MD5
+
+/* Define if mib loading and parsing code should not be included */
+#undef NETSNMP_DISABLE_MIB_LOADING
+
+/* Define if SNMP SET support should be disabled */
+#undef NETSNMP_DISABLE_SET_SUPPORT
+
+/* Define if SNMPv1 code should not be included */
+#undef NETSNMP_DISABLE_SNMPV1
+
+/* Define if SNMPv2c code should not be included */
+#undef NETSNMP_DISABLE_SNMPV2C
+
+/* Define if you are embedding perl in the main agent. */
+#undef NETSNMP_EMBEDDED_PERL
+
+/* define if you want to enable IPv6 support */
+#undef NETSNMP_ENABLE_IPV6
+
+/* define if you want to restrict SMUX connections to localhost by default */
+#undef NETSNMP_ENABLE_LOCAL_SMUX
+
+/* Define if you want to build MFD module rewrites */
+#undef NETSNMP_ENABLE_MFD_REWRITES
+
+/* define if you want to compile support for both authentication and privacy
+   support. */
+#undef NETSNMP_ENABLE_SCAPI_AUTHPRIV
+
+/* testing code sections. */
+#undef NETSNMP_ENABLE_TESTING_CODE
+
+/* Should evaluate to the name of the current function if defined */
+#undef NETSNMP_FUNCTION
+
+/* ifnet needs to have _KERNEL defined */
+#undef NETSNMP_IFNET_NEEDS_KERNEL
+
+/* Define to suppress inclusion of deprecated functions */
+#undef NETSNMP_NO_DEPRECATED_FUNCTIONS
+
+/* If you don't want the agent to report on variables it doesn't have data for
+   */
+#undef NETSNMP_NO_DUMMY_VALUES
+
+/* If we don't want to use kmem. */
+#undef NETSNMP_NO_KMEM_USAGE
+
+/* If you don't have root access don't exit upon kmem errors */
+#undef NETSNMP_NO_ROOT_ACCESS
+
+/* umask permissions to set up persistent files with */
+#undef NETSNMP_PERSISTENT_MASK
+
+/* Size prefix to use to printf a uint32_t */
+#undef NETSNMP_PRI32
+
+/* Size prefix to use to printf a size_t or ssize_t */
+#undef NETSNMP_PRIz
+
+/* Define to 1 if you want to build with reentrant/threaded code (incomplete).
+   */
+#undef NETSNMP_REENTRANT
+
+/* define if you do not want snmptrapd to register as an AgentX subagent */
+#undef NETSNMP_SNMPTRAPD_DISABLE_AGENTX
+
+/* Pattern of temporary files */
+#undef NETSNMP_TEMP_FILE_PATTERN
+
+/* "Define if internal cryptography code should be used" */
+#undef NETSNMP_USE_INTERNAL_CRYPTO
+
+/* define if you are using the MD5 code ... */
+#undef NETSNMP_USE_INTERNAL_MD5
+
+/* Define this if you're using Heimdal Kerberos */
+#undef NETSNMP_USE_KERBEROS_HEIMDAL
+
+/* Define this if we're using the new MIT crypto API */
+#undef NETSNMP_USE_KERBEROS_MIT
+
+/* define if you are using the mysql code for snmptrapd ... */
+#undef NETSNMP_USE_MYSQL
+
+/* Define if you are using the codeS11 library ... */
+#undef NETSNMP_USE_PKCS11
+
+/* Define this if you have lm_sensors v3 or later */
+#undef NETSNMP_USE_SENSORS_V3
+
+/* Should we compile to use special opaque types: float, double, counter64,
+   i64, ui64, union? */
+#undef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES
+
+/* Define to the address where bug reports for this package should be sent. */
+#ifndef PACKAGE_BUGREPORT
+#undef PACKAGE_BUGREPORT
+#endif
+
+/* Define to the full name of this package. */
+#ifndef PACKAGE_NAME
+#undef PACKAGE_NAME
+#endif
+
+/* Define to the full name and version of this package. */
+#ifndef PACKAGE_STRING
+#undef PACKAGE_STRING
+#endif
+
+/* Define to the one symbol short name of this package. */
+#ifndef PACKAGE_TARNAME
+#undef PACKAGE_TARNAME
+#endif
+
+/* Define to the version of this package. */
+#ifndef PACKAGE_VERSION
+#undef PACKAGE_VERSION
+#endif
+
+/* Command to generate ps output, the final column must be the process name
+   withOUT arguments */
+#undef PSCMD
+
+/* Define as the return type of signal handlers (`int' or `void'). */
+#undef RETSIGTYPE
+
+/* define rtentry to ortentry on SYSV machines (alphas) */
+#undef RTENTRY
+
+/* Use BSD 4.4 routing table entries? */
+#undef RTENTRY_4_4
+
+/* The size of `int', as computed by sizeof. */
+#undef SIZEOF_INT
+
+/* The size of `intmax_t', as computed by sizeof. */
+#undef SIZEOF_INTMAX_T
+
+/* The size of `long', as computed by sizeof. */
+#undef SIZEOF_LONG
+
+/* The size of `long long', as computed by sizeof. */
+#undef SIZEOF_LONG_LONG
+
+/* The size of `short', as computed by sizeof. */
+#undef SIZEOF_SHORT
+
+/* The size of `sockaddr_un.sun_path', as computed by sizeof. */
+#undef SIZEOF_SOCKADDR_UN_SUN_PATH
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at runtime.
+	STACK_DIRECTION > 0 => grows toward higher addresses
+	STACK_DIRECTION < 0 => grows toward lower addresses
+	STACK_DIRECTION = 0 => direction of growth unknown */
+#undef STACK_DIRECTION
+
+/* Define if statfs takes 2 args and the second argument has type struct
+   fs_data. [Ultrix] */
+#undef STAT_STATFS_FS_DATA
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* define if SIOCGIFADDR exists in sys/ioctl.h */
+#undef SYS_IOCTL_H_HAS_SIOCGIFADDR
+
+/* Define if the TCP timer constants in <netinet/tcp_timer.h> depend on the
+   integer variable 'hz'. [FreeBSD 4.x] */
+#undef TCPTV_NEEDS_HZ
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#undef TIME_WITH_SYS_TIME
+
+/* Where is the uname command */
+#undef UNAMEPROG
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+# undef _ALL_SOURCE
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# undef _GNU_SOURCE
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# undef _POSIX_PTHREAD_SEMANTICS
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+# undef _TANDEM_SOURCE
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+# undef __EXTENSIONS__
+#endif
+
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+#  undef WORDS_BIGENDIAN
+# endif
+#endif
+
+/* Define to 1 if on MINIX. */
+#undef _MINIX
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+#undef _POSIX_1_SOURCE
+
+/* Define to 1 if you need to in order for `stat' and other things to work. */
+#undef _POSIX_SOURCE
+
+/* Define if you have RPM 4.6 or newer to turn on legacy API */
+#undef _RPM_4_4_COMPAT
+
+/* Define for Solaris 2.5.1 so the uint32_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+#undef _UINT32_T
+
+/* Define for Solaris 2.5.1 so the uint64_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+#undef _UINT64_T
+
+/* Define for Solaris 2.5.1 so the uint8_t typedef from <sys/synch.h>,
+   <pthread.h>, or <semaphore.h> is not used. If the typedef were allowed, the
+   #define below would cause a syntax error. */
+#undef _UINT8_T
+
+/* Define to empty if `const' does not conform to ANSI C. */
+#undef const
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+#undef inline
+#endif
+
+/* Define to the type of a signed integer type of width exactly 16 bits if
+   such a type exists and the standard includes do not define it. */
+#undef int16_t
+
+/* Define to the type of a signed integer type of width exactly 32 bits if
+   such a type exists and the standard includes do not define it. */
+#undef int32_t
+
+/* Define to the type of a signed integer type of width exactly 64 bits if
+   such a type exists and the standard includes do not define it. */
+#undef int64_t
+
+/* Define to the type of a signed integer type of width exactly 8 bits if such
+   a type exists and the standard includes do not define it. */
+#undef int8_t
+
+/* Define to the widest signed integer type if <stdint.h> and <inttypes.h> do
+   not define. */
+#undef intmax_t
+
+/* Define to the type of a signed integer type wide enough to hold a pointer,
+   if such a type exists, and if the system does not define it. */
+#undef intptr_t
+
+/* Define to `long int' if <sys/types.h> does not define. */
+#undef off_t
+
+/* Define to `int' if <sys/types.h> does not define. */
+#undef pid_t
+
+/* Define to the type of an unsigned integer type of width exactly 16 bits if
+   such a type exists and the standard includes do not define it. */
+#undef uint16_t
+
+/* Define to the type of an unsigned integer type of width exactly 32 bits if
+   such a type exists and the standard includes do not define it. */
+#undef uint32_t
+
+/* Define to the type of an unsigned integer type of width exactly 64 bits if
+   such a type exists and the standard includes do not define it. */
+#undef uint64_t
+
+/* Define to the type of an unsigned integer type of width exactly 8 bits if
+   such a type exists and the standard includes do not define it. */
+#undef uint8_t
+
+/* Define to the widest unsigned integer type if <stdint.h> and <inttypes.h>
+   do not define. */
+#undef uintmax_t
+
+/* Define to the type of an unsigned integer type wide enough to hold a
+   pointer, if such a type exists, and if the system does not define it. */
+#undef uintptr_t
+
+/* end of definitions added by configure on-the-fly */
+
+/* If you have openssl 0.9.7 or above, you likely have AES support. */
+#undef NETSNMP_USE_OPENSSL
+#if (defined(NETSNMP_USE_OPENSSL) && defined(HAVE_OPENSSL_AES_H) && defined(HAVE_AES_CFB128_ENCRYPT)) || defined(NETSNMP_USE_INTERNAL_CRYPTO)
+#define HAVE_AES 1
+#endif
+
+/* define random functions */
+
+#ifndef HAVE_RANDOM
+#ifdef HAVE_LRAND48
+#define random lrand48
+#define srandom(s) srand48(s)
+#else
+#ifdef HAVE_RAND
+#define random rand
+#define srandom(s) srand(s)
+#endif
+#endif
+#endif
+
+/* define signal if DNE */
+
+#ifndef HAVE_SIGNAL
+#ifdef HAVE_SIGSET
+#define signal(a,b) sigset(a,b)
+#endif
+#endif
+
+#if HAVE_DMALLOC_H
+#define DMALLOC_FUNC_CHECK
+#endif
+
+#endif /* NETSNMP_NO_AUTOCONF_DEFINITIONS */
+
+
+
+
+/* ********* NETSNMP_MARK_BEGIN_CLEAN_NAMESPACE ********* */
+/* 
+ * put all new net-snmp-specific definitions here
+ *
+ * all definitions MUST have a NETSNMP_ prefix
+ *
+ */
+
+/* Default (SNMP) version number for the tools to use */
+#define NETSNMP_DEFAULT_SNMP_VERSION 3
+
+/* don't change these values! */
+#define NETSNMP_SNMPV1      0xAAAA       /* readable by anyone */
+#define NETSNMP_SNMPV2ANY   0xA000       /* V2 Any type (includes NoAuth) */
+#define NETSNMP_SNMPV2AUTH  0x8000       /* V2 Authenticated requests only */
+
+/* default list of mibs to load */
+#define NETSNMP_DEFAULT_MIBS "IP-MIB:IF-MIB:TCP-MIB:UDP-MIB:SNMPv2-MIB:RFC1213-MIB"
+
+/* debugging stuff */
+/* if defined, we optimize the code to exclude all debugging calls. */
+#undef NETSNMP_NO_DEBUGGING
+/* ignore the -D flag and always print debugging information */
+#define NETSNMP_ALWAYS_DEBUG 0
+
+/* reverse encoding BER packets is both faster and more efficient in space. */
+#define NETSNMP_USE_REVERSE_ASNENCODING       1
+#define NETSNMP_DEFAULT_ASNENCODING_DIRECTION 1 /* 1 = reverse, 0 = forwards */
+
+/* PERSISTENT_DIRECTORY: If defined, the library is capabile of saving
+   persisant information to this directory in the form of configuration
+   lines: PERSISTENT_DIRECTORY/NAME.persistent.conf */
+#define NETSNMP_PERSISTENT_DIRECTORY "/var/snmp"
+
+/* AGENT_DIRECTORY_MODE: the mode the agents should use to create
+   directories with. Since the data stored here is probably sensitive, it
+   probably should be read-only by root/administrator. */
+#define NETSNMP_AGENT_DIRECTORY_MODE 0700
+
+/* MAX_PERSISTENT_BACKUPS:
+ *   The maximum number of persistent backups the library will try to
+ *   read from the persistent cache directory.  If an application fails to
+ *   close down successfully more than this number of times, data will be lost.
+ */
+#define NETSNMP_MAX_PERSISTENT_BACKUPS 10
+
+/* define the system type include file here */
+#define NETSNMP_SYSTEM_INCLUDE_FILE <net-snmp/system/generic.h>
+
+/* define the machine (cpu) type include file here */
+#define NETSNMP_MACHINE_INCLUDE_FILE <net-snmp/machine/generic.h>
+
+/* define the UDP buffer defaults undefined means use the OS buffers
+ * by default */
+#undef NETSNMP_DEFAULT_SERVER_SEND_BUF
+#undef NETSNMP_DEFAULT_SERVER_RECV_BUF
+#undef NETSNMP_DEFAULT_CLIENT_SEND_BUF
+#undef NETSNMP_DEFAULT_CLIENT_RECV_BUF
+
+/* net-snmp's major path names */
+#undef SNMPLIBPATH
+#undef SNMPSHAREPATH
+#undef SNMPCONFPATH
+#undef SNMPDLMODPATH
+
+/* NETSNMP_LOGFILE:  If defined it closes stdout/err/in and opens this in 
+   out/err's place.  (stdin is closed so that sh scripts won't wait for it) */
+#undef NETSNMP_LOGFILE
+
+/* default system contact */
+#undef NETSNMP_SYS_CONTACT
+
+/* system location */
+#undef NETSNMP_SYS_LOC
+
+/* Use libwrap to handle allow/deny hosts? */
+#undef NETSNMP_USE_LIBWRAP
+
+/* Mib-2 tree Info */
+/* These are the system information variables. */
+
+#define NETSNMP_VERS_DESC   "unknown"             /* overridden at run time */
+#define NETSNMP_SYS_NAME    "unknown"             /* overridden at run time */
+
+/* comment out the second define to turn off functionality for any of
+   these: (See README for details) */
+
+/*   proc PROCESSNAME [MAX] [MIN] */
+#define NETSNMP_PROCMIBNUM 2
+
+/*   exec/shell NAME COMMAND      */
+#define NETSNMP_SHELLMIBNUM 8
+
+/*   swap MIN                     */
+#define NETSNMP_MEMMIBNUM 4
+
+/*   disk DISK MINSIZE            */
+#define NETSNMP_DISKMIBNUM 9
+
+/*   load 1 5 15                  */
+#define NETSNMP_LOADAVEMIBNUM 10
+
+/* which version are you using? This mibloc will tell you */
+#define NETSNMP_VERSIONMIBNUM 100
+
+/* Reports errors the agent runs into */
+/* (typically its "can't fork, no mem" problems) */
+#define NETSNMP_ERRORMIBNUM 101
+
+/* The sub id of EXTENSIBLEMIB returned to queries of
+   .iso.org.dod.internet.mgmt.mib-2.system.sysObjectID.0 */
+#define NETSNMP_AGENTID 250
+
+/* This ID is returned after the AGENTID above.  IE, the resulting
+   value returned by a query to sysObjectID is
+   EXTENSIBLEMIB.AGENTID.???, where ??? is defined below by OSTYPE */
+
+#define NETSNMP_HPUX9ID 1
+#define NETSNMP_SUNOS4ID 2 
+#define NETSNMP_SOLARISID 3
+#define NETSNMP_OSFID 4
+#define NETSNMP_ULTRIXID 5
+#define NETSNMP_HPUX10ID 6
+#define NETSNMP_NETBSD1ID 7
+#define NETSNMP_FREEBSDID 8
+#define NETSNMP_IRIXID 9
+#define NETSNMP_LINUXID 10
+#define NETSNMP_BSDIID 11
+#define NETSNMP_OPENBSDID 12
+#define NETSNMP_WIN32ID 13
+#define NETSNMP_HPUX11ID 14
+#define NETSNMP_AIXID 15
+#define NETSNMP_MACOSXID 16
+#define NETSNMP_UNKNOWNID 255
+
+#ifdef hpux9
+#define NETSNMP_OSTYPE NETSNMP_HPUX9ID
+#endif
+#ifdef hpux10
+#define NETSNMP_OSTYPE NETSNMP_HPUX10ID
+#endif
+#ifdef hpux11
+#define NETSNMP_OSTYPE NETSNMP_HPUX11ID
+#endif
+#ifdef sunos4
+#define NETSNMP_OSTYPE NETSNMP_SUNOS4ID
+#endif
+#ifdef solaris2
+#define NETSNMP_OSTYPE NETSNMP_SOLARISID
+#endif
+#if defined(osf3) || defined(osf4) || defined(osf5)
+#define NETSNMP_OSTYPE NETSNMP_OSFID
+#endif
+#ifdef ultrix4
+#define NETSNMP_OSTYPE NETSNMP_ULTRIXID
+#endif
+#if defined(netbsd1) || defined(netbsd2)
+#define NETSNMP_OSTYPE NETSNMP_NETBSD1ID
+#endif
+#if defined(__FreeBSD__)
+#define NETSNMP_OSTYPE NETSNMP_FREEBSDID
+#endif
+#if defined(irix6) || defined(irix5)
+#define NETSNMP_OSTYPE NETSNMP_IRIXID
+#endif
+#ifdef linux
+#define NETSNMP_OSTYPE NETSNMP_LINUXID
+#endif
+#if defined(bsdi2) || defined(bsdi3) || defined(bsdi4)
+#define NETSNMP_OSTYPE NETSNMP_BSDIID
+#endif
+#if defined(openbsd2) || defined(openbsd3) || defined(openbsd4)
+#define NETSNMP_OSTYPE NETSNMP_OPENBSDID
+#endif
+#ifdef WIN32
+#define NETSNMP_OSTYPE NETSNMP_WIN32ID
+#endif
+#if defined(aix3) || defined(aix4) || defined(aix5) || defined(aix6) || defined(aix7)
+#define NETSNMP_OSTYPE NETSNMP_AIXID
+#endif
+#if defined(darwin) && (darwin >= 8)
+#define NETSNMP_OSTYPE NETSNMP_MACOSXID
+#endif
+/* unknown */
+#ifndef NETSNMP_OSTYPE
+#define NETSNMP_OSTYPE NETSNMP_UNKNOWNID
+#endif
+
+/* The enterprise number has been assigned by the IANA group.   */
+/* Optionally, this may point to the location in the tree your  */
+/* company/organization has been allocated.                     */
+/* The assigned enterprise number for the NET_SNMP MIB modules. */
+#define NETSNMP_ENTERPRISE_OID			8072
+#define NETSNMP_ENTERPRISE_MIB			1,3,6,1,4,1,8072
+#define NETSNMP_ENTERPRISE_DOT_MIB		1.3.6.1.4.1.8072
+#define NETSNMP_ENTERPRISE_DOT_MIB_LENGTH	7
+
+/* The assigned enterprise number for sysObjectID. */
+#define NETSNMP_SYSTEM_MIB		1,3,6,1,4,1,8072,3,2,NETSNMP_OSTYPE
+#define NETSNMP_SYSTEM_DOT_MIB		1.3.6.1.4.1.8072.3.2.NETSNMP_OSTYPE
+#define NETSNMP_SYSTEM_DOT_MIB_LENGTH	10
+
+/* The assigned enterprise number for notifications. */
+#define NETSNMP_NOTIFICATION_MIB		1,3,6,1,4,1,8072,4
+#define NETSNMP_NOTIFICATION_DOT_MIB		1.3.6.1.4.1.8072.4
+#define NETSNMP_NOTIFICATION_DOT_MIB_LENGTH	8
+
+/* this is the location of the ucdavis mib tree.  It shouldn't be
+   changed, as the places it is used are expected to be constant
+   values or are directly tied to the UCD-SNMP-MIB. */
+#define NETSNMP_UCDAVIS_OID		2021
+#define NETSNMP_UCDAVIS_MIB		1,3,6,1,4,1,2021
+#define NETSNMP_UCDAVIS_DOT_MIB		1.3.6.1.4.1.2021
+#define NETSNMP_UCDAVIS_DOT_MIB_LENGTH	7
+
+/* how long to wait (seconds) for error querys before reseting the error trap.*/
+#define NETSNMP_ERRORTIMELENGTH 600 
+
+/* Exec command to fix PROC problems */
+/* %s will be replaced by the process name in error */
+
+/* #define NETSNMP_PROCFIXCMD "/usr/bin/perl /local/scripts/fixproc %s" */
+
+/* Exec command to fix EXEC problems */
+/* %s will be replaced by the exec/script name in error */
+
+/* #define NETSNMP_EXECFIXCMD "/usr/bin/perl /local/scripts/fixproc %s" */
+
+/* Should exec output Cashing be used (speeds up things greatly), and
+   if so, After how many seconds should the cache re-newed?  Note:
+   Don't define CASHETIME to disable cashing completely */
+
+#define NETSNMP_EXCACHETIME 30
+#define NETSNMP_CACHEFILE ".snmp-exec-cache"
+#define NETSNMP_MAXCACHESIZE (200*80)   /* roughly 200 lines max */
+
+/* misc defaults */
+
+/* default of 100 meg minimum if the minimum size is not specified in
+   the config file */
+#define NETSNMP_DEFDISKMINIMUMSPACE 100000
+
+/* default maximum load average before error */
+#define NETSNMP_DEFMAXLOADAVE 12.0
+
+/* max times to loop reading output from execs. */
+/* Because of sleep(1)s, this will also be time to wait (in seconds) for exec
+   to finish */
+#define NETSNMP_MAXREADCOUNT 100
+
+/* Set if snmpgets should block and never timeout */
+/* The original CMU code had this hardcoded as = 1 */
+#define NETSNMP_SNMPBLOCK 1
+
+/* How long to wait before restarting the agent after a snmpset to
+   EXTENSIBLEMIB.VERSIONMIBNUM.VERRESTARTAGENT.  This is
+   necessary to finish the snmpset reply before restarting. */
+#define NETSNMP_RESTARTSLEEP 5
+
+/* UNdefine to allow specifying zero-length community string */
+/* #define NETSNMP_NO_ZEROLENGTH_COMMUNITY 1 */
+
+/* define to exit the agent on a bad kernel read */
+/* #define NETSNMP_EXIT_ON_BAD_KLREAD  */
+
+/* Number of community strings to store */
+#define NETSNMP_NUM_COMMUNITIES	5
+
+/* internal define */
+#define NETSNMP_LASTFIELD -1
+
+/*  Pluggable transports.  */
+
+/*  This is defined if support for the UDP/IP transport domain is
+    available.   */
+#undef NETSNMP_TRANSPORT_UDP_DOMAIN
+
+/*  This is defined if support for the "callback" transport domain is
+    available.   */
+#undef NETSNMP_TRANSPORT_CALLBACK_DOMAIN
+
+/*  This is defined if support for the TCP/IP transport domain is
+    available.  */
+#undef NETSNMP_TRANSPORT_TCP_DOMAIN
+
+/*  This is defined if support for the Unix transport domain
+    (a.k.a. "local IPC") is available.  */
+#undef NETSNMP_TRANSPORT_UNIX_DOMAIN
+
+/*  This is defined if support for the AAL5 PVC transport domain is
+    available.  */
+#undef NETSNMP_TRANSPORT_AAL5PVC_DOMAIN
+
+/*  This is defined if support for the IPX transport domain is
+    available.  */
+#undef NETSNMP_TRANSPORT_IPX_DOMAIN
+
+/*  This is defined if support for the UDP/IPv6 transport domain is
+    available.  */
+#undef NETSNMP_TRANSPORT_UDPIPV6_DOMAIN
+
+/*  This is defined if support for the TCP/IPv6 transport domain is
+    available.  */
+#undef NETSNMP_TRANSPORT_TCPIPV6_DOMAIN
+
+/*  This is defined if support for the TLS transport domain is
+    available.   */
+#undef NETSNMP_TRANSPORT_TLSBASE_DOMAIN
+
+/*  This is defined if support for the Alias transport domain is
+    available.   */
+#undef NETSNMP_TRANSPORT_ALIAS_DOMAIN
+
+/*  This is defined if support for the SSH transport domain is
+    available.   */
+#undef NETSNMP_TRANSPORT_SSH_DOMAIN
+
+/*  This is defined if support for the DTLS/UDP transport domain is
+    available.   */
+#undef NETSNMP_TRANSPORT_DTLSUDP_DOMAIN
+
+/*  This is defined if support for the TLS/TCP transport domain is
+    available.   */
+#undef NETSNMP_TRANSPORT_TLSTCP_DOMAIN
+
+/*  This is defined if support for stdin/out transport domain is available.   */
+#undef NETSNMP_TRANSPORT_STD_DOMAIN
+
+/*  This is defined if support for the IPv4Base transport domain is available.   */
+#undef NETSNMP_TRANSPORT_IPV4BASE_DOMAIN
+
+/* define this if the USM security module is available */
+#undef NETSNMP_SECMOD_USM
+
+/* define this if the KSM (kerberos based snmp) security module is available */
+#undef NETSNMP_SECMOD_KSM
+
+/* define this if the local security module is available */
+#undef NETSNMP_SECMOD_LOCALSM
+
+/* define if configured as a "mini-agent" */
+#undef NETSNMP_MINI_AGENT
+
+/* this is the location of the net-snmp mib tree.  It shouldn't be
+   changed, as the places it is used are expected to be constant
+   values or are directly tied to the UCD-SNMP-MIB. */
+#define NETSNMP_OID		8072
+#define NETSNMP_MIB		1,3,6,1,4,1,8072
+#define NETSNMP_DOT_MIB		1.3.6.1.4.1.8072
+#define NETSNMP_DOT_MIB_LENGTH	7
+
+/* pattern for temporary file names */
+#define NETSNMP_TEMP_FILE_PATTERN "/tmp/snmpdXXXXXX"
+
+/*
+ * this must be before the system/machine includes, to allow them to
+ * override and turn off inlining. To do so, they should do the
+ * following:
+ *
+ *    #undef NETSNMP_ENABLE_INLINE
+ *    #define NETSNMP_ENABLE_INLINE 0
+ *
+ * A user having problems with their compiler can also turn off
+ * the use of inline by defining NETSNMP_NO_INLINE via their cflags:
+ *
+ *    -DNETSNMP_NO_INLINE
+ *
+ * Header and source files should only test against NETSNMP_USE_INLINE:
+ *
+ *   #ifdef NETSNMP_USE_INLINE
+ *   NETSNMP_INLINE function(int parm) { return parm -1; }
+ *   #endif
+ *
+ * Functions which should be static, regardless of whether or not inline
+ * is available or enabled should use the NETSNMP_STATIC_INLINE macro,
+ * like so:
+ *
+ *    NETSNMP_STATIC_INLINE function(int parm) { return parm -1; }
+ *
+ * NOT like this:
+ *
+ *    static NETSNMP_INLINE function(int parm) { return parm -1; }
+ *
+ */
+#ifdef NETSNMP_BROKEN_INLINE
+#   define NETSNMP_ENABLE_INLINE 0
+#else
+#   define NETSNMP_ENABLE_INLINE 1
+#endif
+
+#include NETSNMP_SYSTEM_INCLUDE_FILE
+#include NETSNMP_MACHINE_INCLUDE_FILE
+
+#if NETSNMP_ENABLE_INLINE && !defined(NETSNMP_NO_INLINE)
+#   define NETSNMP_USE_INLINE 1
+#   ifndef NETSNMP_INLINE
+#      define NETSNMP_INLINE inline
+#   endif
+#   ifndef NETSNMP_STATIC_INLINE
+#      define NETSNMP_STATIC_INLINE static inline
+#   endif
+#else
+#   define NETSNMP_INLINE 
+#   define NETSNMP_STATIC_INLINE static
+#endif
+
+#ifndef NETSNMP_IMPORT
+#  define NETSNMP_IMPORT extern
+#endif
+
+/* comment the next line if you are compiling with libsnmp.h 
+   and are not using the UC-Davis SNMP library. */
+#define UCD_SNMP_LIBRARY 1
+
+/* add in recent CMU library extensions (not complete) */
+#undef CMU_COMPATIBLE
+
+/* final conclusion on nlist usage */
+#if defined(HAVE_NLIST) && defined(HAVE_STRUCT_NLIST_N_VALUE) && !defined(NETSNMP_DONT_USE_NLIST) && !defined(NETSNMP_NO_KMEM_USAGE)
+#define NETSNMP_CAN_USE_NLIST
+#endif
+
+
+/* ********* NETSNMP_MARK_BEGIN_LEGACY_DEFINITIONS *********/
+/* 
+ * existing definitions prior to Net-SNMP 5.4
+ *
+ * do not add anything new here
+ *
+ */
+
+#ifndef NETSNMP_NO_LEGACY_DEFINITIONS
+
+#ifdef NETSNMP_DEFAULT_SNMP_VERSION
+# define DEFAULT_SNMP_VERSION NETSNMP_DEFAULT_SNMP_VERSION
+#endif
+
+#ifdef NETSNMP_SNMPV1
+# define SNMPV1 NETSNMP_SNMPV1
+#endif
+
+#ifdef NETSNMP_SNMPV2ANY
+# define SNMPV2ANY NETSNMP_SNMPV2ANY
+#endif
+
+#ifdef NETSNMP_SNMPV2AUTH
+# define SNMPV2AUTH NETSNMP_SNMPV2AUTH
+#endif
+
+#ifdef NETSNMP_DEFAULT_MIBS
+# define DEFAULT_MIBS NETSNMP_DEFAULT_MIBS
+#endif
+
+#ifdef NETSNMP_DEFAULT_MIBDIRS
+# define DEFAULT_MIBDIRS NETSNMP_DEFAULT_MIBDIRS
+#endif
+
+#ifdef NETSNMP_DEFAULT_MIBFILES
+# define DEFAULT_MIBFILES NETSNMP_DEFAULT_MIBFILES
+#endif
+
+#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES
+# define OPAQUE_SPECIAL_TYPES NETSNMP_WITH_OPAQUE_SPECIAL_TYPES
+#endif
+
+#ifdef NETSNMP_ENABLE_SCAPI_AUTHPRIV
+# define SCAPI_AUTHPRIV NETSNMP_ENABLE_SCAPI_AUTHPRIV
+#endif
+
+#ifdef NETSNMP_USE_INTERNAL_MD5
+# define USE_INTERNAL_MD5 NETSNMP_USE_INTERNAL_MD5
+#endif
+
+#ifdef NETSNMP_USE_PKCS11
+# define USE_PKCS NETSNMP_USE_PKCS11
+#endif
+
+#ifdef NETSNMP_USE_OPENSSL
+# define USE_OPENSSL NETSNMP_USE_OPENSSL
+#endif
+
+#ifdef NETSNMP_NO_DEBUGGING
+# define SNMP_NO_DEBUGGING NETSNMP_NO_DEBUGGING
+#endif
+
+#ifdef NETSNMP_ALWAYS_DEBUG
+# define SNMP_ALWAYS_DEBUG NETSNMP_ALWAYS_DEBUG
+#endif
+
+#ifdef NETSNMP_USE_REVERSE_ASNENCODING
+# define USE_REVERSE_ASNENCODING NETSNMP_USE_REVERSE_ASNENCODING
+#endif
+#ifdef NETSNMP_DEFAULT_ASNENCODING_DIRECTION
+# define DEFAULT_ASNENCODING_DIRECTION NETSNMP_DEFAULT_ASNENCODING_DIRECTION
+#endif
+
+#define PERSISTENT_DIRECTORY NETSNMP_PERSISTENT_DIRECTORY
+#define PERSISTENT_MASK NETSNMP_PERSISTENT_MASK
+#define AGENT_DIRECTORY_MODE NETSNMP_AGENT_DIRECTORY_MODE
+#define MAX_PERSISTENT_BACKUPS NETSNMP_MAX_PERSISTENT_BACKUPS
+#define SYSTEM_INCLUDE_FILE NETSNMP_SYSTEM_INCLUDE_FILE
+#define MACHINE_INCLUDE_FILE NETSNMP_MACHINE_INCLUDE_FILE
+
+#ifdef NETSNMP_DEFAULT_SERVER_SEND_BUF
+# define DEFAULT_SERVER_SEND_BUF NETSNMP_DEFAULT_SERVER_SEND_BUF
+#endif
+#ifdef NETSNMP_DEFAULT_SERVER_RECV_BUF
+# define DEFAULT_SERVER_RECV_BUF NETSNMP_DEFAULT_SERVER_RECV_BUF
+#endif
+#ifdef NETSNMP_DEFAULT_CLIENT_SEND_BUF
+# define DEFAULT_CLIENT_SEND_BUF NETSNMP_DEFAULT_CLIENT_SEND_BUF
+#endif
+#ifdef NETSNMP_DEFAULT_CLIENT_RECV_BUF
+# define DEFAULT_CLIENT_RECV_BUF NETSNMP_DEFAULT_CLIENT_RECV_BUF
+#endif
+
+#ifdef NETSNMP_LOGFILE
+# define LOGFILE NETSNMP_LOGFILE
+#endif
+
+#ifdef NETSNMP_SYS_CONTACT
+# define SYS_CONTACT NETSNMP_SYS_CONTACT
+#endif
+
+#ifdef NETSNMP_SYS_LOC
+# define SYS_LOC NETSNMP_SYS_LOC
+#endif
+
+#ifdef NETSNMP_USE_LIBWRAP
+# define USE_LIBWRAP NETSNMP_USE_LIBWRAP
+#endif
+
+#ifdef NETSNMP_ENABLE_TESTING_CODE 
+# define SNMP_TESTING_CODE NETSNMP_ENABLE_TESTING_CODE
+#endif
+
+#ifdef NETSNMP_NO_ROOT_ACCESS
+# define NO_ROOT_ACCESS NETSNMP_NO_ROOT_ACCESS
+#endif
+
+#ifdef NETSNMP_NO_KMEM_USAGE
+# define NO_KMEM_USAGE NETSNMP_NO_KMEM_USAGE
+#endif
+
+#ifdef NETSNMP_NO_DUMMY_VALUES
+# define NO_DUMMY_VALUES NETSNMP_NO_DUMMY_VALUES
+#endif
+
+#define VERS_DESC     NETSNMP_VERS_DESC
+#define SYS_NAME      NETSNMP_SYS_NAME
+
+#define PROCMIBNUM    NETSNMP_PROCMIBNUM
+#define SHELLMIBNUM   NETSNMP_SHELLMIBNUM
+#define MEMMIBNUM     NETSNMP_MEMMIBNUM
+#define DISKMIBNUM    NETSNMP_DISKMIBNUM
+
+#define LOADAVEMIBNUM NETSNMP_LOADAVEMIBNUM
+#define VERSIONMIBNUM NETSNMP_VERSIONMIBNUM
+#define ERRORMIBNUM   NETSNMP_ERRORMIBNUM
+#define AGENTID       NETSNMP_AGENTID
+
+#define HPUX9ID       NETSNMP_HPUX9ID
+#define SUNOS4ID      NETSNMP_SUNOS4ID
+#define SOLARISID     NETSNMP_SOLARISID
+#define OSFID         NETSNMP_OSFID
+#define ULTRIXID      NETSNMP_ULTRIXID
+#define HPUX10ID      NETSNMP_HPUX10ID
+#define NETBSD1ID     NETSNMP_NETBSD1ID
+#define FREEBSDID     NETSNMP_FREEBSDID
+#define IRIXID        NETSNMP_IRIXID
+#define LINUXID       NETSNMP_LINUXID
+#define BSDIID        NETSNMP_BSDIID
+#define OPENBSDID     NETSNMP_OPENBSDID
+#define WIN32ID       NETSNMP_WIN32ID
+#define HPUX11ID      NETSNMP_HPUX11ID
+#define AIXID         NETSNMP_AIXID
+#define MACOSXID      NETSNMP_MACOSXID
+#define UNKNOWNID     NETSNMP_UNKNOWNID
+
+#define ENTERPRISE_OID            NETSNMP_ENTERPRISE_OID
+#define ENTERPRISE_MIB            NETSNMP_ENTERPRISE_MIB
+#define ENTERPRISE_DOT_MIB        NETSNMP_ENTERPRISE_DOT_MIB
+#define ENTERPRISE_DOT_MIB_LENGTH NETSNMP_ENTERPRISE_DOT_MIB_LENGTH
+
+#define SYSTEM_MIB		  NETSNMP_SYSTEM_MIB
+#define SYSTEM_DOT_MIB		  NETSNMP_SYSTEM_DOT_MIB
+#define SYSTEM_DOT_MIB_LENGTH	  NETSNMP_SYSTEM_DOT_MIB_LENGTH
+
+#define NOTIFICATION_MIB	    NETSNMP_NOTIFICATION_MIB	
+#define NOTIFICATION_DOT_MIB	    NETSNMP_NOTIFICATION_DOT_MIB
+#define NOTIFICATION_DOT_MIB_LENGTH NETSNMP_NOTIFICATION_DOT_MIB_LENGTH
+
+#define UCDAVIS_OID		  NETSNMP_UCDAVIS_OID
+#define UCDAVIS_MIB		  NETSNMP_UCDAVIS_MIB
+#define UCDAVIS_DOT_MIB		  NETSNMP_UCDAVIS_DOT_MIB
+#define UCDAVIS_DOT_MIB_LENGTH	  NETSNMP_UCDAVIS_DOT_MIB_LENGTH
+
+#define ERRORTIMELENGTH NETSNMP_ERRORTIMELENGTH
+
+#ifdef NETSNMP_PROCFIXCMD
+# define PROCFIXCMD NETSNMP_PROCFIXCMD
+#endif
+
+#ifdef NETSNMP_EXECFIXCMD
+# define EXECFIXCMD NETSNMP_EXECFIXCMD
+#endif
+
+#define EXCACHETIME  NETSNMP_EXCACHETIME
+#define CACHEFILE    NETSNMP_CACHEFILE
+#define MAXCACHESIZE NETSNMP_MAXCACHESIZE
+
+#define DEFDISKMINIMUMSPACE NETSNMP_DEFDISKMINIMUMSPACE
+#define DEFMAXLOADAVE NETSNMP_DEFMAXLOADAVE
+#define MAXREADCOUNT NETSNMP_MAXREADCOUNT
+
+#define SNMPBLOCK NETSNMP_SNMPBLOCK
+#define RESTARTSLEEP NETSNMP_RESTARTSLEEP
+
+#define NUM_COMMUNITIES	NETSNMP_NUM_COMMUNITIES
+
+#ifdef NETSNMP_NO_ZEROLENGTH_COMMUNITY
+# define NO_ZEROLENGTH_COMMUNITY NETSNMP_NO_ZEROLENGTH_COMMUNITY
+#endif
+
+#ifdef NETSNMP_EXIT_ON_BAD_KLREAD
+# define EXIT_ON_BAD_KLREAD NETSNMP_EXIT_ON_BAD_KLREAD
+#endif
+
+#define LASTFIELD NETSNMP_LASTFIELD
+
+#define CONFIGURE_OPTIONS NETSNMP_CONFIGURE_OPTIONS
+
+#ifdef NETSNMP_TRANSPORT_UDP_DOMAIN
+# define SNMP_TRANSPORT_UDP_DOMAIN NETSNMP_TRANSPORT_UDP_DOMAIN
+#endif
+
+#ifdef NETSNMP_TRANSPORT_CALLBACK_DOMAIN
+# define SNMP_TRANSPORT_CALLBACK_DOMAIN NETSNMP_TRANSPORT_CALLBACK_DOMAIN
+#endif
+
+#ifdef NETSNMP_TRANSPORT_TCP_DOMAIN
+# define SNMP_TRANSPORT_TCP_DOMAIN NETSNMP_TRANSPORT_TCP_DOMAIN
+#endif
+
+#ifdef NETSNMP_TRANSPORT_UNIX_DOMAIN
+# define SNMP_TRANSPORT_UNIX_DOMAIN NETSNMP_TRANSPORT_UNIX_DOMAIN
+#endif
+
+#ifdef NETSNMP_TRANSPORT_AAL5PVC_DOMAIN
+# define SNMP_TRANSPORT_AAL5PVC_DOMAIN NETSNMP_TRANSPORT_AAL5PVC_DOMAIN
+#endif
+
+#ifdef NETSNMP_TRANSPORT_IPX_DOMAIN
+# define SNMP_TRANSPORT_IPX_DOMAIN NETSNMP_TRANSPORT_IPX_DOMAIN
+#endif
+
+#ifdef NETSNMP_TRANSPORT_UDPIPV6_DOMAIN
+# define SNMP_TRANSPORT_UDPIPV6_DOMAIN NETSNMP_TRANSPORT_UDPIPV6_DOMAIN
+#endif
+
+#ifdef NETSNMP_TRANSPORT_TCPIPV6_DOMAIN
+# define SNMP_TRANSPORT_TCPIPV6_DOMAIN NETSNMP_TRANSPORT_TCPIPV6_DOMAIN
+#endif
+
+#ifdef NETSNMP_TRANSPORT_TLS_DOMAIN
+# define SNMP_TRANSPORT_TLS_DOMAIN NETSNMP_TRANSPORT_TLS_DOMAIN
+#endif
+
+#ifdef NETSNMP_TRANSPORT_STD_DOMAIN
+# define SNMP_TRANSPORT_STD_DOMAIN NETSNMP_TRANSPORT_STD_DOMAIN
+#endif
+
+#ifdef NETSNMP_SECMOD_USM
+# define SNMP_SECMOD_USM NETSNMP_SECMOD_USM
+#endif
+
+#ifdef NETSNMP_SECMOD_KSM
+# define SNMP_SECMOD_KSM NETSNMP_SECMOD_KSM
+#endif
+
+#ifdef NETSNMP_SECMOD_LOCALSM 
+# define SNMP_SECMOD_LOCALSM NETSNMP_SECMOD_LOCALSM
+#endif
+
+#ifdef NETSNMP_REENTRANT
+# define NS_REENTRANT NETSNMP_REENTRANT
+#endif
+
+#ifdef NETSNMP_ENABLE_IPV6
+# define INET6 NETSNMP_ENABLE_IPV6
+#endif
+
+#ifdef NETSNMP_ENABLE_LOCAL_SMUX
+# define LOCAL_SMUX NETSNMP_ENABLE_LOCAL_SMUX
+#endif
+
+#ifdef NETSNMP_AGENTX_DOM_SOCK_ONLY
+# define AGENTX_DOM_SOCK_ONLY NETSNMP_AGENTX_DOM_SOCK_ONLY
+#endif
+
+#ifdef NETSNMP_SNMPTRAPD_DISABLE_AGENTX
+# define SNMPTRAPD_DISABLE_AGENTX
+#endif
+
+#ifdef NETSNMP_USE_KERBEROS_MIT
+# define MIT_NEW_CRYPTO NETSNMP_USE_KERBEROS_MIT
+#endif
+
+#ifdef NETSNMP_USE_KERBEROS_HEIMDAL
+# define HEIMDAL NETSNMP_USE_KERBEROS_HEIMDAL
+#endif
+
+#ifdef NETSNMP_AGENTX_SOCKET
+# define AGENTX_SOCKET NETSNMP_AGENTX_SOCKET
+#endif
+
+#ifdef NETSNMP_DISABLE_MIB_LOADING
+# define DISABLE_MIB_LOADING NETSNMP_DISABLE_MIB_LOADING
+#endif
+
+#ifdef NETSNMP_DISABLE_SNMPV1
+# define DISABLE_SNMPV1 NETSNMP_DISABLE_SNMPV1
+#endif
+
+#ifdef NETSNMP_DISABLE_SNMPV2C
+# define DISABLE_SNMPV2C NETSNMP_DISABLE_SNMPV2C
+#endif
+
+#ifdef NETSNMP_DISABLE_SET_SUPPORT
+# define DISABLE_SET_SUPPORT NETSNMP_DISABLE_SET_SUPPORT
+#endif
+
+#ifdef NETSNMP_DISABLE_DES
+# define DISABLE_DES NETSNMP_DISABLE_DES
+#endif
+
+#ifdef NETSNMP_DISABLE_MD5
+# define DISABLE_MD5 NETSNMP_DISABLE_MD5
+#endif
+
+#ifdef NETSNMP_DONT_USE_NLIST
+# define DONT_USE_NLIST NETSNMP_DONT_USE_NLIST
+#endif
+
+#ifdef NETSNMP_CAN_USE_NLIST
+# define CAN_USE_NLIST NETSNMP_CAN_USE_NLIST
+#endif
+
+#ifdef NETSNMP_CAN_USE_SYSCTL
+# define CAN_USE_SYSCTL NETSNMP_CAN_USE_SYSCTL
+#endif
+
+#endif /* NETSNMP_NO_LEGACY_DEFINITIONS */
+
+
+#endif /* NET_SNMP_CONFIG_H */
diff -rupN quagga-0.99.18//include/net-snmp/net-snmp-includes.h quaggasnmpTrap//include/net-snmp/net-snmp-includes.h
--- quagga-0.99.18//include/net-snmp/net-snmp-includes.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/net-snmp-includes.h	2010-01-24 03:41:03.000000000 -0800
@@ -0,0 +1,83 @@
+#ifndef NET_SNMP_INCLUDES_H
+#define NET_SNMP_INCLUDES_H
+
+    /**
+     *  Convenience header file to pull in the full
+     *     Net-SNMP library API in one go, together with
+     *     certain commonly-required system header files.
+     */
+
+
+    /*
+     *  Common system header requirements
+     */
+#include <stdio.h>
+#include <sys/types.h>
+#ifdef HAVE_STDINT_H
+#include <stdint.h>
+#endif
+
+#ifndef NET_SNMP_CONFIG_H
+#error "Please include <net-snmp/net-snmp-config.h> before this file"
+#endif
+
+#if HAVE_STRING_H
+#include <string.h>
+#else
+#include <strings.h>
+#endif
+
+#if HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#if HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>
+#endif
+
+#if TIME_WITH_SYS_TIME
+# include <sys/time.h>
+# include <time.h>
+#else
+# if HAVE_SYS_TIME_H
+#  include <sys/time.h>
+# else
+#  include <time.h>
+# endif
+#endif
+
+/*
+ * Must be right after system headers, but before library code for best usage 
+ */
+#if HAVE_DMALLOC_H
+#include <dmalloc.h>
+#endif
+
+  /*
+   * The check for missing 'in_addr_t' is handled
+   * within the main net-snmp-config.h file 
+   */
+
+
+    /*
+     *  The full Net-SNMP API
+     */
+#include <net-snmp/definitions.h>
+#include <net-snmp/types.h>
+
+#include <net-snmp/utilities.h>
+#include <net-snmp/session_api.h>
+#include <net-snmp/pdu_api.h>
+#include <net-snmp/mib_api.h>
+#include <net-snmp/varbind_api.h>
+#include <net-snmp/config_api.h>
+#include <net-snmp/output_api.h>
+#include <net-snmp/snmpv3_api.h>
+
+#ifdef CMU_COMPATIBLE
+#include <net-snmp/library/cmu_compat.h>
+#endif
+
+#endif                          /* NET_SNMP_INCLUDES_H */
diff -rupN quagga-0.99.18//include/net-snmp/openssl_md5.h quaggasnmpTrap//include/net-snmp/openssl_md5.h
--- quagga-0.99.18//include/net-snmp/openssl_md5.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/openssl_md5.h	2010-05-26 21:15:53.000000000 -0700
@@ -0,0 +1,116 @@
+/* crypto/md5/md5.h */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#ifndef HEADER_MD5_H
+#define HEADER_MD5_H
+
+#include <stddef.h>
+
+#ifdef  __cplusplus
+extern "C" {
+#endif
+
+#ifdef OPENSSL_NO_MD5
+#error MD5 is disabled.
+#endif
+
+/*
+ * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+ * ! MD5_LONG has to be at least 32 bits wide. If it's wider, then !
+ * ! MD5_LONG_LOG2 has to be defined along.			   !
+ * !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+ */
+
+#if defined(__LP32__)
+#define MD5_LONG unsigned long
+#elif defined(OPENSSL_SYS_CRAY) || defined(__ILP64__)
+#define MD5_LONG unsigned long
+#define MD5_LONG_LOG2 3
+/*
+ * _CRAY note. I could declare short, but I have no idea what impact
+ * does it have on performance on none-T3E machines. I could declare
+ * int, but at least on C90 sizeof(int) can be chosen at compile time.
+ * So I've chosen long...
+ *					<appro@fy.chalmers.se>
+ */
+#else
+#define MD5_LONG unsigned int
+#endif
+
+#define MD5_CBLOCK	64
+#define MD5_LBLOCK	(MD5_CBLOCK/4)
+#define MD5_DIGEST_LENGTH 16
+
+typedef struct MD5state_st
+	{
+	MD5_LONG A,B,C,D;
+	MD5_LONG Nl,Nh;
+	MD5_LONG data[MD5_LBLOCK];
+	unsigned int num;
+	} MD5_CTX;
+
+int MD5_Init(MD5_CTX *c);
+int MD5_Update(MD5_CTX *c, const void *data, size_t len);
+int MD5_Final(unsigned char *md, MD5_CTX *c);
+unsigned char *MD5(const unsigned char *d, size_t n, unsigned char *md);
+void MD5_Transform(MD5_CTX *c, const unsigned char *b);
+#ifdef  __cplusplus
+}
+#endif
+
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/output_api.h quaggasnmpTrap//include/net-snmp/output_api.h
--- quagga-0.99.18//include/net-snmp/output_api.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/output_api.h	2010-11-15 23:51:33.000000000 -0800
@@ -0,0 +1,157 @@
+#ifndef NET_SNMP_OUTPUT_API_H
+#define NET_SNMP_OUTPUT_API_H
+
+    /**
+     *  Library API routines concerned with logging and message output
+     *    (including error handling and debugging).
+     */
+
+#include <net-snmp/types.h>
+#include <stdarg.h>	/* for va_list */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+    /* Error reporting */
+    NETSNMP_IMPORT
+    void    snmp_error(netsnmp_session *sess, int *clib_errorno,
+                           int *snmp_errorno, char **errstring);
+    NETSNMP_IMPORT
+    void    snmp_sess_error(      void *sess, int *clib_errorno,
+                           int *snmp_errorno, char **errstring);
+
+    NETSNMP_IMPORT
+    const char *snmp_api_errstring(int snmp_errorno);  /*  library errors */
+    NETSNMP_IMPORT
+    const char     *snmp_errstring(int snmp_errorno);  /* protocol errors */
+
+    NETSNMP_IMPORT
+    void    snmp_perror(const char *msg);   /* for parsing errors only */
+
+    NETSNMP_IMPORT
+    void    snmp_sess_perror(const char *msg, netsnmp_session *sess);
+                                       /* for all other SNMP library errors */
+    NETSNMP_IMPORT
+    void    snmp_log_perror(const char *msg);
+                                       /* for system library errors */
+
+    /* Logging messages */
+
+#if !defined(__GNUC__) || __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 8)
+#define _LOG_ATTR
+#else
+#define _LOG_ATTR   __attribute__ ((__format__ (__printf__, 2, 3)))
+#endif
+
+    NETSNMP_IMPORT
+    int  snmp_log( int priority, const char *format, ...) _LOG_ATTR;
+    NETSNMP_IMPORT
+    int  snmp_vlog(int priority, const char *format, va_list ap);
+    NETSNMP_IMPORT
+    int  snmp_get_do_logging(    void);
+    NETSNMP_IMPORT
+    void netsnmp_logging_restart(void);
+    NETSNMP_IMPORT
+    void snmp_disable_log(       void);
+    NETSNMP_IMPORT
+    void shutdown_snmp_logging(  void);
+
+#undef _LOG_ATTR
+
+    /* Debug messages */
+#ifndef NETSNMP_NO_DEBUGGING
+#include <net-snmp/library/snmp_debug.h>	/* for internal macros */
+#define DEBUGMSG(x)        do {if (_DBG_IF_) {debugmsg x;} }while(0)
+#define DEBUGMSGT(x)       do {if (_DBG_IF_) {__DBGMSGT(x);} }while(0)
+#define DEBUGTRACE         do {if (_DBG_IF_) {__DBGTRACE;} }while(0)
+#define DEBUGTRACETOK(x)   do {if (_DBG_IF_) {__DBGTRACETOK(x);} }while(0)
+#define DEBUGMSGL(x)       do {if (_DBG_IF_) {__DBGMSGL(x);} }while(0)
+#define DEBUGMSGTL(x)      do {if (_DBG_IF_) {__DBGMSGTL(x);} }while(0)
+#define DEBUGMSGOID(x)     do {if (_DBG_IF_) {__DBGMSGOID(x);} }while(0)
+#define DEBUGMSGSUBOID(x)  do {if (_DBG_IF_) {__DBGMSGSUBOID(x);} }while(0)
+#define DEBUGMSGVAR(x)     do {if (_DBG_IF_) {__DBGMSGVAR(x);} }while(0)
+#define DEBUGMSGOIDRANGE(x) do {if (_DBG_IF_) {__DBGMSGOIDRANGE(x);} }while(0)
+#define DEBUGMSGHEX(x)     do {if (_DBG_IF_) {__DBGMSGHEX(x);} }while(0)
+#define DEBUGMSGHEXTLI(x)  do {if (_DBG_IF_) {__DBGMSGHEXTLI(x);} }while(0)
+#define DEBUGINDENTADD(x)  do {if (_DBG_IF_) {__DBGINDENTADD(x);} }while(0)
+#define DEBUGINDENTMORE()  do {if (_DBG_IF_) {__DBGINDENTMORE();} }while(0)
+#define DEBUGINDENTLESS()  do {if (_DBG_IF_) {__DBGINDENTLESS();} }while(0)
+#define DEBUGPRINTINDENT(token) \
+	do {if (_DBG_IF_) {__DBGPRINTINDENT(token);} }while(0)
+#define DEBUGDUMPHEADER(token,x) \
+	do {if (_DBG_IF_) {__DBGDUMPHEADER(token,x);} }while(0)
+#define DEBUGDUMPSECTION(token,x) \
+	do {if (_DBG_IF_) {__DBGDUMPSECTION(token,x);} }while(0)
+#define DEBUGDUMPSETUP(token,buf,len) \
+	do {if (_DBG_IF_) {__DBGDUMPSETUP(token,buf,len);} }while(0)
+#define DEBUGMSG_NC(x)  do { __DBGMSG_NC(x); }while(0)
+#define DEBUGMSGT_NC(x) do { __DBGMSGT_NC(x); }while(0)
+
+#else        /* NETSNMP_NO_DEBUGGING := enable streamlining of the code */
+
+#define DEBUGMSG(x)
+#define DEBUGMSGT(x)
+#define DEBUGTRACE
+#define DEBUGTRACETOK(x)
+#define DEBUGMSGL(x)
+#define DEBUGMSGTL(x)
+#define DEBUGMSGOID(x)
+#define DEBUGMSGSUBOID(x)
+#define DEBUGMSGVAR(x)
+#define DEBUGMSGOIDRANGE(x)
+#define DEBUGMSGHEX(x)
+#define DEBUGIF(x)        if(0)
+#define DEBUGDUMP(t,b,l,p)
+#define DEBUGINDENTMORE()
+#define DEBUGINDENTLESS()
+#define DEBUGINDENTADD(x)
+#define DEBUGMSGHEXTLI(x)
+#define DEBUGPRINTINDENT(token)
+#define DEBUGDUMPHEADER(token,x)
+#define DEBUGDUMPSECTION(token,x)
+#define DEBUGDUMPSETUP(token, buf, len)
+
+#define DEBUGMSG_NC(x)
+#define DEBUGMSGT_NC(x)
+
+#endif    /* NETSNMP_NO_DEBUGGING */
+
+    NETSNMP_IMPORT
+    void            debug_register_tokens(const char *tokens);
+    NETSNMP_IMPORT
+    int             debug_is_token_registered(const char *token);
+    NETSNMP_IMPORT
+    void            snmp_set_do_debugging(int);
+    NETSNMP_IMPORT
+    int             snmp_get_do_debugging(void);
+
+    /*
+     *    Having extracted the main ("public API") calls relevant
+     *  to this area of the Net-SNMP project, the next step is to
+     *  identify the related "public internal API" routines.
+     *
+     *    In due course, these should probably be gathered
+     *  together into a companion 'library/output_api.h' header file.
+     *  [Or some suitable name]
+     *
+     *    But for the time being, the expectation is that the
+     *  traditional headers that provided the above definitions
+     *  will probably also cover the relevant internal API calls.
+     *  Hence they are listed here:
+     */
+
+#ifdef __cplusplus
+}
+#endif
+
+#include <net-snmp/library/snmp_api.h>
+#include <net-snmp/library/snmp_client.h>
+#include <net-snmp/library/snmp_debug.h>
+#include <net-snmp/library/snmp_logging.h>
+
+#ifndef ERROR_MSG
+#define ERROR_MSG(string)	snmp_set_detail(string)
+#endif
+
+#endif                          /* NET_SNMP_OUTPUT_API_H */
diff -rupN quagga-0.99.18//include/net-snmp/pdu_api.h quaggasnmpTrap//include/net-snmp/pdu_api.h
--- quagga-0.99.18//include/net-snmp/pdu_api.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/pdu_api.h	2010-07-28 07:44:56.000000000 -0700
@@ -0,0 +1,46 @@
+#ifndef NET_SNMP_PDU_API_H
+#define NET_SNMP_PDU_API_H
+
+    /**
+     *  Library API routines concerned with SNMP PDUs.
+     */
+
+#include <net-snmp/types.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+NETSNMP_IMPORT
+netsnmp_pdu    *snmp_pdu_create(int type);
+NETSNMP_IMPORT
+netsnmp_pdu    *snmp_clone_pdu(netsnmp_pdu *pdu);
+NETSNMP_IMPORT
+netsnmp_pdu    *snmp_fix_pdu(  netsnmp_pdu *pdu, int idx);
+NETSNMP_IMPORT
+void            snmp_free_pdu( netsnmp_pdu *pdu);
+
+#ifdef __cplusplus
+}
+#endif
+
+    /*
+     *    Having extracted the main ("public API") calls relevant
+     *  to this area of the Net-SNMP project, the next step is to
+     *  identify the related "public internal API" routines.
+     *
+     *    In due course, these should probably be gathered
+     *  together into a companion 'library/pdu_api.h' header file.
+     *  [Or some suitable name]
+     *
+     *    But for the time being, the expectation is that the
+     *  traditional headers that provided the above definitions
+     *  will probably also cover the relevant internal API calls.
+     *  Hence they are listed here:
+     */
+
+#include <net-snmp/library/snmp_api.h>
+#include <net-snmp/library/snmp_client.h>
+#include <net-snmp/library/asn1.h>
+
+#endif                          /* NET_SNMP_PDU_API_H */
diff -rupN quagga-0.99.18//include/net-snmp/session_api.h quaggasnmpTrap//include/net-snmp/session_api.h
--- quagga-0.99.18//include/net-snmp/session_api.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/session_api.h	2010-10-20 03:34:13.000000000 -0700
@@ -0,0 +1,317 @@
+#ifndef NET_SNMP_SESSION_API_H
+#define NET_SNMP_SESSION_API_H
+
+    /**
+     *  Library API routines concerned with specifying and using SNMP "sessions"
+     *    including sending and receiving requests.
+     */
+
+#include <net-snmp/types.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    NETSNMP_IMPORT
+    void            snmp_sess_init(netsnmp_session *);
+
+    /*
+     * netsnmp_session *snmp_open(session)
+     *      netsnmp_session *session;
+     *
+     * Sets up the session with the snmp_session information provided
+     * by the user.  Then opens and binds the necessary UDP port.
+     * A handle to the created session is returned (this is different than
+     * the pointer passed to snmp_open()).  On any error, NULL is returned
+     * and snmp_errno is set to the appropriate error code.
+     */
+    NETSNMP_IMPORT
+    netsnmp_session *snmp_open(netsnmp_session *);
+
+    /*
+     * int snmp_close(session)
+     *     netsnmp_session *session;
+     *
+     * Close the input session.  Frees all data allocated for the session,
+     * dequeues any pending requests, and closes any sockets allocated for
+     * the session.  Returns 0 on error, 1 otherwise.
+     *
+     * snmp_close_sessions() does the same thing for all open sessions
+     */
+    NETSNMP_IMPORT
+    int             snmp_close(netsnmp_session *);
+    NETSNMP_IMPORT
+    int             snmp_close_sessions(void);
+
+
+    /*
+     * int snmp_send(session, pdu)
+     *     netsnmp_session *session;
+     *     netsnmp_pdu      *pdu;
+     *
+     * Sends the input pdu on the session after calling snmp_build to create
+     * a serialized packet.  If necessary, set some of the pdu data from the
+     * session defaults.  Add a request corresponding to this pdu to the list
+     * of outstanding requests on this session, then send the pdu.
+     * Returns the request id of the generated packet if applicable, otherwise 1.
+     * On any error, 0 is returned.
+     * The pdu is freed by snmp_send() unless a failure occured.
+     */
+    NETSNMP_IMPORT
+    int             snmp_send(netsnmp_session *, netsnmp_pdu *);
+
+    /*
+     * int snmp_async_send(session, pdu, callback, cb_data)
+     *     netsnmp_session *session;
+     *     netsnmp_pdu      *pdu;
+     *     netsnmp_callback callback;
+     *     void   *cb_data;
+     *
+     * Sends the input pdu on the session after calling snmp_build to create
+     * a serialized packet.  If necessary, set some of the pdu data from the
+     * session defaults.  Add a request corresponding to this pdu to the list
+     * of outstanding requests on this session and store callback and data,
+     * then send the pdu.
+     * Returns the request id of the generated packet if applicable, otherwise 1.
+     * On any error, 0 is returned.
+     * The pdu is freed by snmp_send() unless a failure occured.
+     */
+    NETSNMP_IMPORT
+    int             snmp_async_send(netsnmp_session *, netsnmp_pdu *,
+                                    netsnmp_callback, void *);
+
+
+    /*
+     * void snmp_read(fdset)
+     *     fd_set  *fdset;
+     *
+     * Checks to see if any of the fd's set in the fdset belong to
+     * snmp.  Each socket with it's fd set has a packet read from it
+     * and snmp_parse is called on the packet received.  The resulting pdu
+     * is passed to the callback routine for that session.  If the callback
+     * routine returns successfully, the pdu and it's request are deleted.
+     */
+    NETSNMP_IMPORT
+    void            snmp_read(fd_set *);
+
+    /*
+     * snmp_read2() is similar to snmp_read(), but accepts a pointer to a
+     * large file descriptor set instead of a pointer to a regular file
+     * descriptor set.
+     */
+    NETSNMP_IMPORT
+    void            snmp_read2(netsnmp_large_fd_set *);
+
+
+    NETSNMP_IMPORT
+    int             snmp_synch_response(netsnmp_session *, netsnmp_pdu *,
+                                        netsnmp_pdu **);
+
+    /*
+     * int snmp_select_info(numfds, fdset, timeout, block)
+     * int *numfds;
+     * fd_set   *fdset;
+     * struct timeval *timeout;
+     * int *block;
+     *
+     * Returns info about what snmp requires from a select statement.
+     * numfds is the number of fds in the list that are significant.
+     * All file descriptors opened for SNMP are OR'd into the fdset.
+     * If activity occurs on any of these file descriptors, snmp_read
+     * should be called with that file descriptor set.
+     *
+     * The timeout is the latest time that SNMP can wait for a timeout.  The
+     * select should be done with the minimum time between timeout and any other
+     * timeouts necessary.  This should be checked upon each invocation of select.
+     * If a timeout is received, snmp_timeout should be called to check if the
+     * timeout was for SNMP.  (snmp_timeout is idempotent)
+     *
+     * Block is 1 if the select is requested to block indefinitely, rather than
+     * time out.  If block is input as 1, the timeout value will be treated as
+     * undefined, but it must be available for setting in snmp_select_info.  On
+     * return, if block is true, the value of timeout will be undefined.
+     *
+     * snmp_select_info returns the number of open sockets.  (i.e. The number
+     * of sessions open)
+     */
+    NETSNMP_IMPORT
+    int             snmp_select_info(int *, fd_set *, struct timeval *,
+                                     int *);
+
+    /*
+     * snmp_select_info2() is similar to snmp_select_info(), but accepts a
+     * pointer to a large file descriptor set instead of a pointer to a
+     * regular file descriptor set.
+     */
+    NETSNMP_IMPORT
+    int             snmp_select_info2(int *, netsnmp_large_fd_set *,
+                                      struct timeval *, int *);
+
+    /*
+     * snmp_sess_select_info_flags() and
+     * snmp_sess_select_info2_flags() is similar to
+     * snmp_sess_select_info() and snmp_sess_select_info2(), but
+     * accepts a list of flags to control aspects of its behavior.
+     */
+#define NETSNMP_SELECT_NOFLAGS  0x00
+#define NETSNMP_SELECT_NOALARMS 0x01
+    NETSNMP_IMPORT
+    int             snmp_sess_select_info_flags(void *, int *, fd_set *,
+                                                struct timeval *, int *, int);
+    int             snmp_sess_select_info2_flags(void *, int *,
+                                                 netsnmp_large_fd_set *,
+                                                 struct timeval *, int *, int);
+
+    /*
+     * void snmp_timeout();
+     *
+     * snmp_timeout should be called whenever the timeout from snmp_select_info
+     * expires, but it is idempotent, so snmp_timeout can be polled (probably a
+     * cpu expensive proposition).  snmp_timeout checks to see if any of the
+     * sessions have an outstanding request that has timed out.  If it finds one
+     * (or more), and that pdu has more retries available, a new packet is formed
+     * from the pdu and is resent.  If there are no more retries available, the
+     * callback for the session is used to alert the user of the timeout.
+     */
+
+    NETSNMP_IMPORT
+    void            snmp_timeout(void);
+
+    /*
+     * single session API.
+     *
+     * These functions perform similar actions as snmp_XX functions,
+     * but operate on a single session only.
+     *
+     * Synopsis:
+     
+     void * sessp;
+     netsnmp_session session, *ss;
+     netsnmp_pdu *pdu, *response;
+     
+     snmp_sess_init(&session);
+     session.retries = ...
+     session.remote_port = ...
+     sessp = snmp_sess_open(&session);
+     ss = snmp_sess_session(sessp);
+     if (ss == NULL)
+     exit(1);
+     ...
+     if (ss->community) free(ss->community);
+     ss->community = strdup(gateway);
+     ss->community_len = strlen(gateway);
+     ...
+     snmp_sess_synch_response(sessp, pdu, &response);
+     ...
+     snmp_sess_close(sessp);
+     
+     * See also:
+     * snmp_sess_synch_response, in snmp_client.h.
+     
+     * Notes:
+     *  1. Invoke snmp_sess_session after snmp_sess_open.
+     *  2. snmp_sess_session return value is an opaque pointer.
+     *  3. Do NOT free memory returned by snmp_sess_session.
+     *  4. Replace snmp_send(ss,pdu) with snmp_sess_send(sessp,pdu)
+     */
+
+    NETSNMP_IMPORT
+    void           *snmp_sess_open(netsnmp_session *);
+    NETSNMP_IMPORT
+    void           *snmp_sess_pointer(netsnmp_session *);
+    NETSNMP_IMPORT
+    netsnmp_session *snmp_sess_session(void *);
+    NETSNMP_IMPORT
+    netsnmp_session *snmp_sess_session_lookup(void *);
+
+
+    /*
+     * use return value from snmp_sess_open as void * parameter 
+     */
+
+    NETSNMP_IMPORT
+    int             snmp_sess_send(void *, netsnmp_pdu *);
+    NETSNMP_IMPORT
+    int             snmp_sess_async_send(void *, netsnmp_pdu *,
+                                         netsnmp_callback, void *);
+    NETSNMP_IMPORT
+    int             snmp_sess_select_info(void *, int *, fd_set *,
+                                          struct timeval *, int *);
+    NETSNMP_IMPORT
+    int             snmp_sess_select_info2(void *, int *,
+					   netsnmp_large_fd_set *,
+                                           struct timeval *, int *);
+    /*
+     * Returns 0 if success, -1 if fail.
+     */
+    NETSNMP_IMPORT
+    int             snmp_sess_read(void *, fd_set *);
+    /*
+     * Similar to snmp_sess_read(), but accepts a pointer to a large file
+     * descriptor set instead of a pointer to a file descriptor set.
+     */
+    NETSNMP_IMPORT
+    int             snmp_sess_read2(void *,
+                                    netsnmp_large_fd_set *);
+    NETSNMP_IMPORT
+    void            snmp_sess_timeout(void *);
+    NETSNMP_IMPORT
+    int             snmp_sess_close(void *);
+
+    NETSNMP_IMPORT
+    int             snmp_sess_synch_response(void *, netsnmp_pdu *,
+                                             netsnmp_pdu **);
+
+#ifdef __cplusplus
+}
+#endif
+
+
+    /*
+     *    Having extracted the main ("public API") calls relevant
+     *  to this area of the Net-SNMP project, the next step is to
+     *  identify the related "public internal API" routines.
+     *
+     *    In due course, these should probably be gathered
+     *  together into a companion 'library/session_api.h' header file.
+     *  [Or some suitable name]
+     *
+     *    But for the time being, the expectation is that the
+     *  traditional headers that provided the above definitions
+     *  will probably also cover the relevant internal API calls.
+     *  Hence they are listed here:
+     */
+
+#include <net-snmp/library/snmp_api.h>
+#include <net-snmp/library/snmp_client.h>
+#include <net-snmp/library/asn1.h>
+#include <net-snmp/library/callback.h>
+
+#include <net-snmp/library/snmp_transport.h>
+#include <net-snmp/library/snmp_service.h>
+#include <net-snmp/library/snmpCallbackDomain.h>
+#ifdef NETSNMP_TRANSPORT_UNIX_DOMAIN
+#include <net-snmp/library/snmpUnixDomain.h>
+#endif
+#ifdef NETSNMP_TRANSPORT_UDP_DOMAIN
+#include <net-snmp/library/snmpUDPDomain.h>
+#endif
+#ifdef NETSNMP_TRANSPORT_TCP_DOMAIN
+#include <net-snmp/library/snmpTCPDomain.h>
+#endif
+#ifdef NETSNMP_TRANSPORT_UDPIPV6_DOMAIN
+#include <net-snmp/library/snmpUDPIPv6Domain.h>
+#endif
+#ifdef NETSNMP_TRANSPORT_TCPIPV6_DOMAIN
+#include <net-snmp/library/snmpTCPIPv6Domain.h>
+#endif
+#ifdef NETSNMP_TRANSPORT_IPX_DOMAIN
+#include <net-snmp/library/snmpIPXDomain.h>
+#endif
+#ifdef NETSNMP_TRANSPORT_AAL5PVC_DOMAIN
+#include <net-snmp/library/snmpAAL5PVCDomain.h>
+#endif
+
+#include <net-snmp/library/ucd_compat.h>
+
+#endif                          /* NET_SNMP_SESSION_API_H */
diff -rupN quagga-0.99.18//include/net-snmp/snmpv3_api.h quaggasnmpTrap//include/net-snmp/snmpv3_api.h
--- quagga-0.99.18//include/net-snmp/snmpv3_api.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/snmpv3_api.h	2006-09-14 17:48:50.000000000 -0700
@@ -0,0 +1,38 @@
+#ifndef NET_SNMP_SNMPV3_H
+#define NET_SNMP_SNMPV3_H
+
+    /**
+     *  Library API routines concerned with SNMPv3 handling.
+     *
+     *  Most of these would typically not be used directly,
+     *     but be invoked via version-independent API routines.
+     */
+
+#include <net-snmp/types.h>
+
+    /*
+     *  For the initial release, this will just refer to the
+     *  relevant UCD header files.
+     *    In due course, the routines relevant to this area of the
+     *  API will be identified, and listed here directly.
+     *
+     *  But for the time being, this header file is a placeholder,
+     *  to allow application writers to adopt the new header file names.
+     */
+
+#include <net-snmp/library/snmp_api.h>
+
+#include <net-snmp/library/callback.h>
+#include <net-snmp/library/snmpv3.h>
+#include <net-snmp/library/transform_oids.h>
+#include <net-snmp/library/keytools.h>
+#include <net-snmp/library/scapi.h>
+#include <net-snmp/library/lcd_time.h>
+#ifdef NETSNMP_USE_INTERNAL_MD5
+#include <net-snmp/library/md5.h>
+#endif
+
+#include <net-snmp/library/snmp_secmod.h>
+#include <net-snmp/library/snmpv3-security-includes.h>
+
+#endif                          /* NET_SNMP_SNMPV3_H */
diff -rupN quagga-0.99.18//include/net-snmp/system/aix.h quaggasnmpTrap//include/net-snmp/system/aix.h
--- quagga-0.99.18//include/net-snmp/system/aix.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/aix.h	2009-09-14 15:18:24.000000000 -0700
@@ -0,0 +1,27 @@
+#include <net-snmp/system/generic.h>
+#include <sys/select.h>
+#undef TOTAL_MEMORY_SYMBOL
+#undef NPROC_SYMBOL
+#undef RTHASHSIZE_SYMBOL
+#undef RTHOST_SYMBOL
+#undef RTNET_SYMBOL
+
+#undef RTTABLES_SYMBOL
+#define RTTABLES_SYMBOL "rt_tables"
+
+#undef ARPTAB_SIZE_SYMBOL
+#define ARPTAB_SIZE_SYMBOL "arptabsize"
+
+#undef ARPTAB_SYMBOL
+#define ARPTAB_SYMBOL "arptabnb"
+
+#ifndef __GNUC__
+#  undef NETSNMP_ENABLE_INLINE
+#  define NETSNMP_ENABLE_INLINE 0
+#endif
+
+/* define the extra mib modules that are supported */
+#define NETSNMP_INCLUDE_HOST_RESOURCES
+
+/* the legacy symbol NOACCESS clashes with the system headers. Remove it. */
+#define NETSNMP_NO_LEGACY_DEFINITIONS
diff -rupN quagga-0.99.18//include/net-snmp/system/bsd.h quaggasnmpTrap//include/net-snmp/system/bsd.h
--- quagga-0.99.18//include/net-snmp/system/bsd.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/bsd.h	2004-04-14 02:53:18.000000000 -0700
@@ -0,0 +1,20 @@
+#include <net-snmp/system/generic.h>
+
+/*
+ * the bsd route symbol adds an 's' at the end to this symbol name 
+ */
+#undef RTTABLES_SYMBOL
+#define RTTABLES_SYMBOL "rt_tables"
+
+/*
+ * BSD systems use a different method of looking up sockaddr_in values 
+ */
+#define NEED_KLGETSA 1
+
+/*
+ * ARP_Scan_Next needs a 4th ifIndex argument 
+ */
+#define ARP_SCAN_FOUR_ARGUMENTS 1
+
+#define UTMP_HAS_NO_TYPE 1
+#define UTMP_HAS_NO_PID 1
diff -rupN quagga-0.99.18//include/net-snmp/system/bsdi3.h quaggasnmpTrap//include/net-snmp/system/bsdi3.h
--- quagga-0.99.18//include/net-snmp/system/bsdi3.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/bsdi3.h	2006-08-17 16:14:20.000000000 -0700
@@ -0,0 +1,2 @@
+#include "bsdi.h"
+#define bsdi2 bsdi2             /* bsdi3 is a superset of bsdi2 */
diff -rupN quagga-0.99.18//include/net-snmp/system/bsdi4.h quaggasnmpTrap//include/net-snmp/system/bsdi4.h
--- quagga-0.99.18//include/net-snmp/system/bsdi4.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/bsdi4.h	2006-08-17 16:14:20.000000000 -0700
@@ -0,0 +1,11 @@
+#include "bsdi.h"
+#define bsdi2 bsdi2             /* bsdi4 is a superset of bsdi2 */
+#undef NPROC_SYMBOL
+#undef PROC_SYMBOL
+
+#define MNTTYPE_UFS	"ufs"
+#define BerkelyFS	1
+#define MNTTYPE_MSDOS	"msdos"
+#define MNTTYPE_ISO9660 "cd9660"
+#define MNTTYPE_NFS 	"nfs"
+#define MNTTYPE_MFS 	"mfs"
diff -rupN quagga-0.99.18//include/net-snmp/system/bsdi.h quaggasnmpTrap//include/net-snmp/system/bsdi.h
--- quagga-0.99.18//include/net-snmp/system/bsdi.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/bsdi.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,3 @@
+#include "bsd.h"
+
+#define CHECK_RT_FLAGS 1
diff -rupN quagga-0.99.18//include/net-snmp/system/cygwin.h quaggasnmpTrap//include/net-snmp/system/cygwin.h
--- quagga-0.99.18//include/net-snmp/system/cygwin.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/cygwin.h	2010-01-26 03:43:11.000000000 -0800
@@ -0,0 +1,12 @@
+#include <net-snmp/system/generic.h>
+
+/* got socklen_t? */
+#define HAVE_SOCKLEN_T 1
+
+#ifdef HAVE_STDINT_H
+#include <stdint.h>	/* uint32_t */
+#endif
+
+#undef bsdlike
+#undef MBSTAT_SYMBOL
+#undef TOTAL_MEMORY_SYMBOL
diff -rupN quagga-0.99.18//include/net-snmp/system/darwin10.h quaggasnmpTrap//include/net-snmp/system/darwin10.h
--- quagga-0.99.18//include/net-snmp/system/darwin10.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/darwin10.h	2010-07-31 16:50:43.000000000 -0700
@@ -0,0 +1,161 @@
+/*
+ * While Darwin 10 (aka, Mac OS X 10.6 Snow Leopard) is "BSD-like", it differs
+ * substantially enough to not warrant pretending it is a BSD flavor.
+ * This first section are the vestigal BSD remnants.
+ */
+/* Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ */
+/*
+ * Portions of this file are copyrighted by:
+ * Copyright (C) 2007 Apple, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
+/*
+ * BSD systems use a different method of looking up sockaddr_in values 
+ */
+/* #define NEED_KLGETSA 1 */
+
+/*
+ * ARP_Scan_Next needs a 4th ifIndex argument 
+ */
+#define ARP_SCAN_FOUR_ARGUMENTS 1
+
+#define CHECK_RT_FLAGS 1
+
+/*
+ * this is not good enough before freebsd3! 
+ */
+/* #undef HAVE_NET_IF_MIB_H */
+
+/*
+ * This section adds the relevant definitions from generic.h
+ * (a file we don't include here)
+ */
+
+/*
+ * udp_inpcb list symbol, e.g. for mibII/udpTable.c
+ */
+#define INP_NEXT_SYMBOL inp_next
+
+/*
+ * This section defines Mac OS X 10.5 (and later) specific additions.
+ */
+#define darwin 10
+#ifndef darwin10
+#   define darwin10 darwin
+#endif
+
+/*
+ * Mac OS X should only use the modern API and definitions.
+ */
+#ifndef NETSNMP_NO_LEGACY_DEFINITIONS
+#define NETSNMP_NO_LEGACY_DEFINITIONS 1
+#endif
+
+/*
+ * looks like the IFTable stuff works better than the mibII versions
+ */
+ 
+#define NETSNMP_INCLUDE_IFTABLE_REWRITES
+
+/*
+ * use new host resources files as well
+ */
+#define NETSNMP_INCLUDE_HRSWINST_REWRITES
+#define NETSNMP_INCLUDE_HRSWRUN_REWRITES
+#undef NETSNMP_INCLUDE_HRSWRUN_WRITE_SUPPORT
+#define NETSNMP_CAN_GET_DISK_LABEL 1
+
+/*
+ * Enabling this restricts the compiler to mostly public APIs.
+ */
+#ifndef __APPLE_API_STRICT_CONFORMANCE
+#define __APPLE_API_STRICT_CONFORMANCE 1
+#endif
+#ifndef __APPLE_API_UNSTABLE
+#define __APPLE_API_UNSTABLE 1
+#endif
+
+/*
+ * Darwin's tools are capable of building multiple architectures in one pass.
+ * As a result, platform definitions should be deferred until compile time.
+ */
+#ifdef BYTE_ORDER
+# undef WORDS_BIGENDIAN
+# if BYTE_ORDER == BIG_ENDIAN
+#  define WORDS_BIGENDIAN 1
+# endif
+#endif
+
+/*
+ * Darwin's tools are capable of building multiple architectures in one pass.
+ * As a result, platform definitions should be deferred until compile time.
+ */
+#ifdef BYTE_ORDER
+# undef WORDS_BIGENDIAN
+# if BYTE_ORDER == BIG_ENDIAN
+#  define WORDS_BIGENDIAN 1
+# endif
+#endif
+
+/*
+ * Although Darwin does have a kvm.h file, kvm_openfiles etc. always
+ * return null because /dev/kmem was removed completely in OS X 10.5.
+ */
+#undef HAVE_KVM_H
+#undef HAVE_KVM_GETPROCS
+#undef HAVE_KVM_OPENFILES
+
+/*
+ * Although Darwin does have an fstab.h file, getfsfile etc. always return null.
+ * At least, as of 5.3.
+ */
+#undef HAVE_FSTAB_H
+
+#define SWAPFILE_DIR "/private/var/vm"
+#define SWAPFILE_PREFIX "swapfile"
+
+/*
+ * These apparently used to be in netinet/tcp_timers.h, but went away in
+ * 10.4.2. Define them here til we find out a way to get the real values.
+ */
+#define TCPTV_MIN       (  1*PR_SLOWHZ)         /* minimum allowable value */
+#define TCPTV_REXMTMAX  ( 64*PR_SLOWHZ)         /* max allowable REXMT value */
+
+/*
+ * Because Mac OS X is built on Mach, it does not provide a BSD-compatible
+ * VM statistics API.
+ */
+#define USE_MACH_HOST_STATISTICS 1
+
+/*
+ * This tells code that manipulates IPv6 that the structures are unified,
+ * i.e., IPv4 and IPv6 use the same structs.
+ * This should eventually be replaced with a configure directive.
+ */
+/* #define USE_UNIFIED_IPV6_STRUCTS 1 */
+#undef STRUCT_in6pcb_HAS_inp_vflag
+
+/*
+ * utility macro used in several darwin specific files
+ */
+#define SNMP_CFRelease(x) do { if (x) { CFRelease(x); x = NULL; } } while(0)
+
+/*
+ * Mac OS X runs on both PPC and Intel hardware,
+ *   which handle udpTable index values differently
+ */
+#include <TargetConditionals.h>
+#ifdef TARGET_RT_LITTLE_ENDIAN
+#define UDP_ADDRESSES_IN_HOST_ORDER 1
+#endif
+
+/*
+ * as of 7/2010, openssl on darwin does not have sha256
+ */
+#define OPENSSL_NO_SHA256 1
+#define OPENSSL_NO_SHA512 1
diff -rupN quagga-0.99.18//include/net-snmp/system/darwin7.h quaggasnmpTrap//include/net-snmp/system/darwin7.h
--- quagga-0.99.18//include/net-snmp/system/darwin7.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/darwin7.h	2010-07-14 18:34:09.000000000 -0700
@@ -0,0 +1,20 @@
+#include <stdint.h>
+#include "freebsd4.h"
+#define darwin darwin
+/*
+ * Although Darwin does have an fstab.h file, getfsfile etc. always return null.
+ * At least, as of 5.3.
+ */
+#undef HAVE_FSTAB_H
+
+#define MBSTAT_SYMBOL "mbstat"
+#undef TOTAL_MEMORY_SYMBOL
+
+#define SWAPFILE_DIR "/private/var/vm"
+#define SWAPFILE_PREFIX "swapfile"
+
+/*
+ * as of 7/2010, openssl on darwin does not have sha256
+ */
+#define OPENSSL_NO_SHA256 1
+#define OPENSSL_NO_SHA512 1
diff -rupN quagga-0.99.18//include/net-snmp/system/darwin8.h quaggasnmpTrap//include/net-snmp/system/darwin8.h
--- quagga-0.99.18//include/net-snmp/system/darwin8.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/darwin8.h	2010-07-14 18:34:09.000000000 -0700
@@ -0,0 +1,107 @@
+/*
+ * While Darwin 8 (aka, Mac OS X 10.4 Tiger) is "BSD-like", it differs
+ * substantially enough to not warrant pretending it is a BSD flavor.
+ * This first section are the vestigal BSD remnants.
+ */
+
+/*
+ * BSD systems use a different method of looking up sockaddr_in values 
+ */
+/* #define NEED_KLGETSA 1 */
+
+/*
+ * ARP_Scan_Next needs a 4th ifIndex argument 
+ */
+#define ARP_SCAN_FOUR_ARGUMENTS 1
+
+#define CHECK_RT_FLAGS 1
+
+/*
+ * this is not good enough before freebsd3! 
+ */
+/* #undef HAVE_NET_IF_MIB_H */
+
+/*
+ * This section adds the relevant definitions from generic.h
+ * (a file we don't include here)
+ */
+
+/*
+ * udp_inpcb list symbol, e.g. for mibII/udpTable.c
+ */
+#define INP_NEXT_SYMBOL inp_next
+
+/*
+ * This section defines Mac OS X 10.4 (and later) specific additions.
+ */
+#define darwin 8
+
+/*
+ * Mac OS X should only use the modern API and definitions.
+ */
+#ifndef NETSNMP_NO_LEGACY_DEFINITIONS
+#define NETSNMP_NO_LEGACY_DEFINITIONS 1
+#endif
+
+/*
+ * (eventually) Enabling this forces the compiler to only use public APIs.
+ */
+/*#ifndef __APPLE_API_STRICT_CONFORMANCE
+ *#define __APPLE_API_STRICT_CONFORMANCE 1
+ *#endif
+ */
+
+/*
+ * Darwin's tools are capable of building multiple architectures in one pass.
+ * As a result, platform definitions should be deferred until compile time.
+ */
+#ifdef BYTE_ORDER
+# undef WORDS_BIGENDIAN
+# if BYTE_ORDER == BIG_ENDIAN
+#  define WORDS_BIGENDIAN 1
+# endif
+#endif
+
+/*
+ * Although Darwin does have a kvm.h file, kvm_openfiles etc. always
+ * return null because /dev/kmem was removed in OS X 10.4 for Intel.
+ */
+#undef HAVE_KVM_H
+#undef HAVE_KVM_GETPROCS
+#undef HAVE_KVM_OPENFILES
+
+/*
+ * Although Darwin does have an fstab.h file, getfsfile etc. always return null.
+ * At least, as of 5.3.
+ */
+#undef HAVE_FSTAB_H
+
+#define SWAPFILE_DIR "/private/var/vm"
+#define SWAPFILE_PREFIX "swapfile"
+
+/*
+ * These apparently used to be in netinet/tcp_timers.h, but went away in
+ * 10.4.2. Define them here til we find out a way to get the real values.
+ */
+#define TCPTV_MIN       (  1*PR_SLOWHZ)         /* minimum allowable value */
+#define TCPTV_REXMTMAX  ( 64*PR_SLOWHZ)         /* max allowable REXMT value */
+
+/*
+ * Because Mac OS X is built on Mach, it does not provide a BSD-compatible
+ * VM statistics API.
+ */
+#define USE_MACH_HOST_STATISTICS 1
+
+/*
+ * This tells code that manipulates IPv6 that the structures are unified,
+ * i.e., IPv4 and IPv6 use the same structs.
+ * This should eventually be replaced with a configure directive.
+ */
+/* #define USE_UNIFIED_IPV6_STRUCTS 1 */
+#undef STRUCT_in6pcb_HAS_inp_vflag
+
+/*
+ * as of 7/2010, openssl on darwin does not have sha256
+ */
+#define OPENSSL_NO_SHA256 1
+#define OPENSSL_NO_SHA512 1
diff -rupN quagga-0.99.18//include/net-snmp/system/darwin9.h quaggasnmpTrap//include/net-snmp/system/darwin9.h
--- quagga-0.99.18//include/net-snmp/system/darwin9.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/darwin9.h	2010-07-14 18:34:09.000000000 -0700
@@ -0,0 +1,161 @@
+/*
+ * While Darwin 9 (aka, Mac OS X 10.5 Leopard) is "BSD-like", it differs
+ * substantially enough to not warrant pretending it is a BSD flavor.
+ * This first section are the vestigal BSD remnants.
+ */
+/* Portions of this file are subject to the following copyright(s).  See
+ * the Net-SNMP's COPYING file for more details and other copyrights
+ * that may apply:
+ */
+/*
+ * Portions of this file are copyrighted by:
+ * Copyright (C) 2007 Apple, Inc. All rights reserved.
+ * Use is subject to license terms specified in the COPYING file
+ * distributed with the Net-SNMP package.
+ */
+
+/*
+ * BSD systems use a different method of looking up sockaddr_in values 
+ */
+/* #define NEED_KLGETSA 1 */
+
+/*
+ * ARP_Scan_Next needs a 4th ifIndex argument 
+ */
+#define ARP_SCAN_FOUR_ARGUMENTS 1
+
+#define CHECK_RT_FLAGS 1
+
+/*
+ * this is not good enough before freebsd3! 
+ */
+/* #undef HAVE_NET_IF_MIB_H */
+
+/*
+ * This section adds the relevant definitions from generic.h
+ * (a file we don't include here)
+ */
+
+/*
+ * udp_inpcb list symbol, e.g. for mibII/udpTable.c
+ */
+#define INP_NEXT_SYMBOL inp_next
+
+/*
+ * This section defines Mac OS X 10.5 (and later) specific additions.
+ */
+#define darwin 9
+#ifndef darwin9
+#   define darwin9 darwin
+#endif
+
+/*
+ * Mac OS X should only use the modern API and definitions.
+ */
+#ifndef NETSNMP_NO_LEGACY_DEFINITIONS
+#define NETSNMP_NO_LEGACY_DEFINITIONS 1
+#endif
+
+/*
+ * looks like the IFTable stuff works better than the mibII versions
+ */
+ 
+#define NETSNMP_INCLUDE_IFTABLE_REWRITES
+
+/*
+ * use new host resources files as well
+ */
+#define NETSNMP_INCLUDE_HRSWINST_REWRITES
+#define NETSNMP_INCLUDE_HRSWRUN_REWRITES
+#undef NETSNMP_INCLUDE_HRSWRUN_WRITE_SUPPORT
+#define NETSNMP_CAN_GET_DISK_LABEL 1
+
+/*
+ * Enabling this restricts the compiler to mostly public APIs.
+ */
+#ifndef __APPLE_API_STRICT_CONFORMANCE
+#define __APPLE_API_STRICT_CONFORMANCE 1
+#endif
+#ifndef __APPLE_API_UNSTABLE
+#define __APPLE_API_UNSTABLE 1
+#endif
+
+/*
+ * Darwin's tools are capable of building multiple architectures in one pass.
+ * As a result, platform definitions should be deferred until compile time.
+ */
+#ifdef BYTE_ORDER
+# undef WORDS_BIGENDIAN
+# if BYTE_ORDER == BIG_ENDIAN
+#  define WORDS_BIGENDIAN 1
+# endif
+#endif
+
+/*
+ * Darwin's tools are capable of building multiple architectures in one pass.
+ * As a result, platform definitions should be deferred until compile time.
+ */
+#ifdef BYTE_ORDER
+# undef WORDS_BIGENDIAN
+# if BYTE_ORDER == BIG_ENDIAN
+#  define WORDS_BIGENDIAN 1
+# endif
+#endif
+
+/*
+ * Although Darwin does have a kvm.h file, kvm_openfiles etc. always
+ * return null because /dev/kmem was removed completely in OS X 10.5.
+ */
+#undef HAVE_KVM_H
+#undef HAVE_KVM_GETPROCS
+#undef HAVE_KVM_OPENFILES
+
+/*
+ * Although Darwin does have an fstab.h file, getfsfile etc. always return null.
+ * At least, as of 5.3.
+ */
+#undef HAVE_FSTAB_H
+
+#define SWAPFILE_DIR "/private/var/vm"
+#define SWAPFILE_PREFIX "swapfile"
+
+/*
+ * These apparently used to be in netinet/tcp_timers.h, but went away in
+ * 10.4.2. Define them here til we find out a way to get the real values.
+ */
+#define TCPTV_MIN       (  1*PR_SLOWHZ)         /* minimum allowable value */
+#define TCPTV_REXMTMAX  ( 64*PR_SLOWHZ)         /* max allowable REXMT value */
+
+/*
+ * Because Mac OS X is built on Mach, it does not provide a BSD-compatible
+ * VM statistics API.
+ */
+#define USE_MACH_HOST_STATISTICS 1
+
+/*
+ * This tells code that manipulates IPv6 that the structures are unified,
+ * i.e., IPv4 and IPv6 use the same structs.
+ * This should eventually be replaced with a configure directive.
+ */
+/* #define USE_UNIFIED_IPV6_STRUCTS 1 */
+#undef STRUCT_in6pcb_HAS_inp_vflag
+
+/*
+ * utility macro used in several darwin specific files
+ */
+#define SNMP_CFRelease(x) do { if (x) { CFRelease(x); x = NULL; } } while(0)
+
+/*
+ * Mac OS X runs on both PPC and Intel hardware,
+ *   which handle udpTable index values differently
+ */
+#include <TargetConditionals.h>
+#ifdef TARGET_RT_LITTLE_ENDIAN
+#define UDP_ADDRESSES_IN_HOST_ORDER 1
+#endif
+
+/*
+ * as of 7/2010, openssl on darwin does not have sha256
+ */
+#define OPENSSL_NO_SHA256 1
+#define OPENSSL_NO_SHA512 1
diff -rupN quagga-0.99.18//include/net-snmp/system/darwin.h quaggasnmpTrap//include/net-snmp/system/darwin.h
--- quagga-0.99.18//include/net-snmp/system/darwin.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/darwin.h	2010-07-14 18:34:09.000000000 -0700
@@ -0,0 +1,13 @@
+#include "freebsd4.h"
+#define darwin darwin
+/*
+ * Although Darwin does have an fstab.h file, getfsfile etc. always return null.
+ * At least, as of 5.3.
+ */
+#undef HAVE_FSTAB_H
+
+/*
+ * as of 7/2010, openssl on darwin does not have sha256
+ */
+#define OPENSSL_NO_SHA256 1
+#define OPENSSL_NO_SHA512 1
diff -rupN quagga-0.99.18//include/net-snmp/system/dragonfly.h quaggasnmpTrap//include/net-snmp/system/dragonfly.h
--- quagga-0.99.18//include/net-snmp/system/dragonfly.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/dragonfly.h	2007-05-03 16:01:13.000000000 -0700
@@ -0,0 +1,24 @@
+#include "freebsd.h"
+
+/*
+ * dragonfly is a superset of freebsd4
+ */
+#define freebsd2 freebsd2
+#define freebsd3 freebsd3
+#define freebsd4 freebsd4
+
+#undef IFADDR_SYMBOL
+#define IFADDR_SYMBOL "in_ifaddrhead"
+
+#undef PROC_SYMBOL
+#define PROC_SYMBOL "allproc"
+
+#undef NPROC_SYMBOL
+#define NPROC_SYMBOL "nprocs"
+
+#undef TOTAL_MEMORY_SYMBOL
+
+#undef MBSTAT_SYMBOL
+
+#undef INP_NEXT_SYMBOL
+#define INP_NEXT_SYMBOL inp_next
diff -rupN quagga-0.99.18//include/net-snmp/system/dynix.h quaggasnmpTrap//include/net-snmp/system/dynix.h
--- quagga-0.99.18//include/net-snmp/system/dynix.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/dynix.h	2007-06-02 01:24:53.000000000 -0700
@@ -0,0 +1,106 @@
+/*
+ * dynix.h
+ * 
+ * Date Created: Sat Jan 12 10:50:50 BST 2002
+ * Author:       Patrick Hess  <phess@hds.com>
+ */
+
+#include <net-snmp/system/generic.h>
+
+/*
+ * from s/sysv.h 
+ */
+#define SYSV 1
+
+/*
+ * to make these changes work... 
+ */
+/*
+ * maybe I should have used _SEQUENT_ in all this code..  dunno 
+ */
+#define dynix dynix
+
+#undef TOTAL_MEMORY_SYMBOL
+#undef MBSTAT_SYMBOL
+
+/*
+ * Not enough alcohool in bloodstream [fmc] 
+ */
+#ifdef NPROC_SYMBOL
+#undef NPROC_SYMBOL
+#endif
+/*
+ * there might be a way to get NPROC...  this might work..  might not 
+ */
+/*
+ * #define NPROC_SYMBOL "procNPROC" 
+ */
+#ifdef PROC_SYMBOL
+#undef PROC_SYMBOL
+#endif
+
+/*
+ * These definitions date from early BSD-based headers,
+ *   and are included in modern NetBSD and OpenBSD distributions.
+ * As such, the relevant copyright probably resides with UCB.
+ */
+#ifndef TCPTV_MIN
+#define TCPTV_MIN       (1*PR_SLOWHZ)   /* minimum allowable value */
+#endif
+#ifndef TCPTV_REXMTMAX
+#define TCPTV_REXMTMAX  (64*PR_SLOWHZ)  /* max allowable REXMT value */
+#endif
+
+/*
+ * some of the system headers wanna include asm code...  let's not 
+ */
+#define __NO_ASM_MACRO 1
+
+/*
+ * Dynix doesn't seem to set this.  Guess I'll set it here 
+ */
+#ifndef L_SET
+#define L_SET   SEEK_SET
+#endif
+
+
+/*
+ * configure fails to detect these properly 
+ */
+/*
+ * lives in libnsl.so 
+ */
+#define HAVE_GETHOSTNAME 1
+
+/*
+ * outta place...  lives in /usr/include/sys 
+ */
+#define  HAVE_NET_IF_DL_H 1
+
+/*
+ * got this library...  dunno why configure didn't find it 
+ */
+#define HAVE_LIBNSL 1
+
+/*
+ * My Dynix box has nearly 400 filesystems and well over 50 disks 
+ */
+/*
+ * #define MAXDISKS 500  
+ */
+
+/*
+ * lives in libsocket.so 
+ */
+#define HAVE_GETHOSTBYNAME 1
+
+/*
+ * Might as well include this here, since a significant
+ * number of files seem to need it.  DTS 
+ */
+#if HAVE_SYS_SELECT_H
+#include <sys/select.h>
+#endif
+
+/* define the extra mib modules that are supported */
+#define NETSNMP_INCLUDE_HOST_RESOURCES
diff -rupN quagga-0.99.18//include/net-snmp/system/freebsd2.h quaggasnmpTrap//include/net-snmp/system/freebsd2.h
--- quagga-0.99.18//include/net-snmp/system/freebsd2.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/freebsd2.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,10 @@
+#include "freebsd.h"
+
+/*
+ * this is not good enough before freebsd3! 
+ */
+#undef HAVE_NET_IF_MIB_H
+#undef PROC_SYMBOL
+#undef NPROC_SYMBOL
+#undef LOADAVE_SYMBOL
+#undef TOTAL_MEMORY_SYMBOL
diff -rupN quagga-0.99.18//include/net-snmp/system/freebsd3.h quaggasnmpTrap//include/net-snmp/system/freebsd3.h
--- quagga-0.99.18//include/net-snmp/system/freebsd3.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/freebsd3.h	2006-08-17 16:14:20.000000000 -0700
@@ -0,0 +1,11 @@
+#include "freebsd.h"
+
+#define freebsd2 freebsd2       /* freebsd3 is a superset of freebsd2 */
+
+#undef IFADDR_SYMBOL
+#define IFADDR_SYMBOL "in_ifaddrhead"
+
+#undef PROC_SYMBOL
+#undef NPROC_SYMBOL
+
+#undef TOTAL_MEMORY_SYMBOL
diff -rupN quagga-0.99.18//include/net-snmp/system/freebsd4.h quaggasnmpTrap//include/net-snmp/system/freebsd4.h
--- quagga-0.99.18//include/net-snmp/system/freebsd4.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/freebsd4.h	2006-08-17 16:14:20.000000000 -0700
@@ -0,0 +1,23 @@
+#include "freebsd.h"
+
+/*
+ * freebsd4 is a superset of all since freebsd2
+ */
+#define freebsd2 freebsd2
+#define freebsd3 freebsd3
+
+#undef IFADDR_SYMBOL
+#define IFADDR_SYMBOL "in_ifaddrhead"
+
+#undef PROC_SYMBOL
+#define PROC_SYMBOL "allproc"
+
+#undef NPROC_SYMBOL
+#define NPROC_SYMBOL "nprocs"
+
+#undef TOTAL_MEMORY_SYMBOL
+
+#undef MBSTAT_SYMBOL
+
+#undef INP_NEXT_SYMBOL
+#define INP_NEXT_SYMBOL inp_next
diff -rupN quagga-0.99.18//include/net-snmp/system/freebsd5.h quaggasnmpTrap//include/net-snmp/system/freebsd5.h
--- quagga-0.99.18//include/net-snmp/system/freebsd5.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/freebsd5.h	2007-05-28 16:30:21.000000000 -0700
@@ -0,0 +1,8 @@
+/* freebsd5 is a superset of freebsd4 */
+#include "freebsd4.h"
+#define freebsd4 freebsd4
+
+/* don't define _KERNEL on FreeBSD 5.3 even if configure thinks we need it */
+#ifdef freebsd5
+#undef NETSNMP_IFNET_NEEDS_KERNEL
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/system/freebsd6.h quaggasnmpTrap//include/net-snmp/system/freebsd6.h
--- quagga-0.99.18//include/net-snmp/system/freebsd6.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/freebsd6.h	2006-08-17 16:14:20.000000000 -0700
@@ -0,0 +1,3 @@
+/* freebsd6 is a superset of freebsd5 */
+#include "freebsd5.h"
+#define freebsd5 freebsd5
diff -rupN quagga-0.99.18//include/net-snmp/system/freebsd7.h quaggasnmpTrap//include/net-snmp/system/freebsd7.h
--- quagga-0.99.18//include/net-snmp/system/freebsd7.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/freebsd7.h	2007-05-24 13:51:50.000000000 -0700
@@ -0,0 +1,3 @@
+/* freebsd7 is a superset of freebsd6 */
+#include "freebsd6.h"
+#define freebsd6 freebsd6
diff -rupN quagga-0.99.18//include/net-snmp/system/freebsd8.h quaggasnmpTrap//include/net-snmp/system/freebsd8.h
--- quagga-0.99.18//include/net-snmp/system/freebsd8.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/freebsd8.h	2010-02-14 11:29:08.000000000 -0800
@@ -0,0 +1,4 @@
+/* freebsd8 is a superset of freebsd4 */
+#include "freebsd4.h"
+#define freebsd4 freebsd4
+#define freebsd5 freebsd5
diff -rupN quagga-0.99.18//include/net-snmp/system/freebsd.h quaggasnmpTrap//include/net-snmp/system/freebsd.h
--- quagga-0.99.18//include/net-snmp/system/freebsd.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/freebsd.h	2007-06-21 07:01:08.000000000 -0700
@@ -0,0 +1,27 @@
+#include "bsd.h"
+
+#define CHECK_RT_FLAGS 1
+
+/*
+ * udp_inpcb list symbol 
+ */
+#undef INP_NEXT_SYMBOL
+#define INP_NEXT_SYMBOL inp_list.le_next
+
+#undef INP_PREV_SYMBOL
+#define INP_PREV_SYMBOL inp_list.le_prev
+
+#undef TCP_TTL_SYMBOL
+#define TCP_TTL_SYMBOL "ip_defttl"
+
+#ifdef _PATH_UTMP
+#define UTMP_FILE _PATH_UTMP
+#else
+#define UTMP_FILE "/var/run/utmp"
+#endif
+
+#define UDP_ADDRESSES_IN_HOST_ORDER 1
+
+/* define the extra mib modules that are supported */
+#define NETSNMP_INCLUDE_HOST_RESOURCES
+#define NETSNMP_INCLUDE_IFTABLE_REWRITES
diff -rupN quagga-0.99.18//include/net-snmp/system/generic.h quaggasnmpTrap//include/net-snmp/system/generic.h
--- quagga-0.99.18//include/net-snmp/system/generic.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/generic.h	2006-08-17 16:14:20.000000000 -0700
@@ -0,0 +1,74 @@
+
+#define bsdlike bsdlike
+
+/*
+ * nlist symbols in ip.c 
+ */
+#define IPSTAT_SYMBOL "ipstat"
+#define IP_FORWARDING_SYMBOL "ipforwarding"
+#define TCP_TTL_SYMBOL "tcpDefaultTTL"
+
+/*
+ * nlist symbols in interfaces.c 
+ */
+#define IFNET_SYMBOL "ifnet"
+#define IFADDR_SYMBOL "in_ifaddr"
+
+/*
+ * nlist symbols in at.c 
+ */
+#define ARPTAB_SYMBOL "arptab"
+#define ARPTAB_SIZE_SYMBOL "arptab_size"
+
+/*
+ * load average lookup symbol 
+ */
+#define LOADAVE_SYMBOL "avenrun"
+
+/*
+ * nlist symbols in hr_proc.c and memory.c 
+ */
+#define PHYSMEM_SYMBOL "physmem"
+#define TOTAL_MEMORY_SYMBOL "total"
+#define MBSTAT_SYMBOL "mbstat"
+#define SWDEVT_SYMBOL "swdevt"
+#define FSWDEVT_SYMBOL "fswdevt"
+#define NSWAPFS_SYMBOL "nswapfs"
+#define NSWAPDEV_SYMBOL "nswapdev"
+
+/*
+ * process nlist symbols. 
+ */
+#define NPROC_SYMBOL "nproc"
+#define PROC_SYMBOL "proc"
+
+/*
+ * icmp.c nlist symbols 
+ */
+#define ICMPSTAT_SYMBOL "icmpstat"
+
+/*
+ * tcp.c nlist symbols 
+ */
+#define TCPSTAT_SYMBOL "tcpstat"
+#define TCP_SYMBOL "tcb"
+
+/*
+ * upd.c nlist symbols 
+ */
+#define UDPSTAT_SYMBOL "udpstat"
+#define UDB_SYMBOL "udb"
+
+/*
+ * var_route.c nlist symbols 
+ */
+#define RTTABLES_SYMBOL "rt_table"
+#define RTHASHSIZE_SYMBOL "rthashsize"
+#define RTHOST_SYMBOL "rthost"
+#define RTNET_SYMBOL "rtnet"
+
+/*
+ * udp_inpcb list symbol 
+ */
+#define INP_NEXT_SYMBOL inp_next
+#define INP_PREV_SYMBOL inp_prev
diff -rupN quagga-0.99.18//include/net-snmp/system/hpux.h quaggasnmpTrap//include/net-snmp/system/hpux.h
--- quagga-0.99.18//include/net-snmp/system/hpux.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/hpux.h	2010-01-05 02:11:39.000000000 -0800
@@ -0,0 +1,94 @@
+#include "sysv.h"
+
+#undef hpux
+#define hpux hpux
+
+#ifdef hpux11
+#define NETSNMP_DONT_USE_NLIST 1
+#endif
+
+/* 
+ * HP-UX needs _REENTRANT defined to pick up strtok_r.
+ * Otherwise, at least for 64-bit code, strtok_r will not work 
+ * and will make net-snmp segfault.
+ */
+#define _REENTRANT 1
+
+#undef TCP_TTL_SYMBOL
+#ifndef hpux11
+#define TCP_TTL_SYMBOL "ipDefaultTTL"
+#endif
+
+#ifndef hpux11
+/*
+ * hpux specific 
+ */
+#define MIB_IPCOUNTER_SYMBOL "MIB_ipcounter"
+#define MIB_TCPCOUNTER_SYMBOL "MIB_tcpcounter"
+#define MIB_UDPCOUNTER_SYMBOL "MIB_udpcounter"
+#endif
+
+#undef ARPTAB_SYMBOL
+#ifndef hpux11
+#define ARPTAB_SYMBOL "arphd"
+#endif
+#undef ARPTAB_SIZE_SYMBOL
+#ifndef hpux11
+#define ARPTAB_SIZE_SYMBOL "arptab_nb"
+#endif
+
+#if defined(hpux10) || defined(hpux11)
+#undef SWDEVT_SYMBOL
+#undef FSWDEVT_SYMBOL
+#undef NSWAPFS_SYMBOL
+#undef NSWAPDEV_SYMBOL
+#undef LOADAVE_SYMBOL
+#undef PROC_SYMBOL
+#undef NPROC_SYMBOL
+#undef TOTAL_MEMORY_SYMBOL
+#undef MBSTAT_SYMBOL
+#endif
+
+#ifdef hpux11
+#undef IPSTAT_SYMBOL
+#undef TCP_SYMBOL
+#undef TCPSTAT_SYMBOL
+#undef UDB_SYMBOL
+#undef UDPSTAT_SYMBOL
+#undef ICMPSTAT_SYMBOL
+#undef IP_FORWARDING_SYMBOL
+#undef RTTABLES_SYMBOL
+#undef RTHASHSIZE_SYMBOL
+#undef RTHOST_SYMBOL
+#undef RTNET_SYMBOL
+
+#undef PHYSMEM_SYMBOL
+#endif
+
+/*
+ * ARP_Scan_Next needs a 4th ifIndex argument 
+ */
+#define ARP_SCAN_FOUR_ARGUMENTS
+
+#define rt_pad1 rt_refcnt
+
+/*
+ * disable inline for non-gcc compiler
+ */
+#ifndef __GNUC__
+#  undef NETSNMP_ENABLE_INLINE
+#  define NETSNMP_ENABLE_INLINE 0
+#endif
+
+/*
+ * prevent sigaction being redefined to cma_sigaction
+ * (causing build errors on HP-UX 10.20, at least)
+ */
+#ifdef hpux10
+#ifndef _CMA_NOWRAPPERS_
+#  define _CMA_NOWRAPPERS_ 1
+#endif
+#endif
+
+/* define the extra mib modules that are supported */
+#define NETSNMP_INCLUDE_HOST_RESOURCES
diff -rupN quagga-0.99.18//include/net-snmp/system/irix.h quaggasnmpTrap//include/net-snmp/system/irix.h
--- quagga-0.99.18//include/net-snmp/system/irix.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/irix.h	2007-05-28 16:30:21.000000000 -0700
@@ -0,0 +1,33 @@
+/*
+ * irix.h
+ * 
+ * Date Created:   Mon Feb 16 22:19:39 1998
+ * Initial Author: Simon Leinen  <simon@switch.ch>
+ */
+
+#include <net-snmp/system/generic.h>
+
+#undef TCP_TTL_SYMBOL
+#define TCP_TTL_SYMBOL "tcp_ttl"
+
+#undef IPSTAT_SYMBOL
+#define NO_DOUBLE_ICMPSTAT
+#undef ICMPSTAT_SYMBOL
+#undef TCPSTAT_SYMBOL
+#undef UDPSTAT_SYMBOL
+
+#define ARP_SCAN_FOUR_ARGUMENTS 1
+
+#define _KMEMUSER 1
+
+/*
+ * don't define _KERNEL before including sys/unistd.h 
+ */
+#define NETSNMP_IFNET_NEEDS_KERNEL_LATE  1
+
+#define STREAM_NEEDS_KERNEL_ISLANDS
+
+#ifndef __GNUC__
+#  undef NETSNMP_ENABLE_INLINE
+#  define NETSNMP_ENABLE_INLINE 0
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/system/kfreebsd.h quaggasnmpTrap//include/net-snmp/system/kfreebsd.h
--- quagga-0.99.18//include/net-snmp/system/kfreebsd.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/kfreebsd.h	2007-01-02 09:23:54.000000000 -0800
@@ -0,0 +1,9 @@
+#include "freebsd6.h"
+#define freebsd6 freebsd6
+
+#include <osreldate.h>
+#define __FreeBSD_version __FreeBSD_kernel_version
+
+#include <sys/queue.h>
+#include <sys/_types.h>
+
diff -rupN quagga-0.99.18//include/net-snmp/system/linux.h quaggasnmpTrap//include/net-snmp/system/linux.h
--- quagga-0.99.18//include/net-snmp/system/linux.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/linux.h	2006-09-14 07:51:53.000000000 -0700
@@ -0,0 +1,23 @@
+#include "sysv.h"
+
+#define NETSNMP_DONT_USE_NLIST 1
+
+#undef NPROC_SYMBOL
+
+#undef bsdlike
+
+#define ARP_SCAN_FOUR_ARGUMENTS
+
+/* uncomment this to read process names from /proc/X/cmdline (like <= 5.0) */
+/* #define USE_PROC_CMDLINE */
+
+/*
+ * red hat >= 5.0 doesn't have this 
+ */
+#ifndef MNTTYPE_PROC
+#define MNTTYPE_PROC "proc"
+#endif
+
+/* define the extra mib modules that are supported */
+#define NETSNMP_INCLUDE_HOST_RESOURCES
+#define NETSNMP_INCLUDE_IFTABLE_REWRITES
diff -rupN quagga-0.99.18//include/net-snmp/system/mingw32.h quaggasnmpTrap//include/net-snmp/system/mingw32.h
--- quagga-0.99.18//include/net-snmp/system/mingw32.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/mingw32.h	2010-01-23 09:00:41.000000000 -0800
@@ -0,0 +1,93 @@
+/*
+ * The Win32 API is maintained by the MinGW developers.
+ * The licensing for the Win32 API is defined in the
+ * MinGW file README.w32api, which states:
+
+   "Unless otherwise stated in individual source files,
+
+    THIS SOFTWARE IS NOT COPYRIGHTED
+
+    This source code is offered for use in the public domain.  You may use,
+    modify or distribute it freely.
+
+    This source code is distributed in the hope that it will be useful but
+    WITHOUT ANY WARRANTY.  ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY
+    DISCLAIMED.  This includes but is not limited to warranties of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+ 
+ */
+
+/*
+ * Make the getnameinfo() function available.
+ * Note: according to MSDN getnameinfo() is available in ws2_32 on Windows 2000
+ * and above. MinGW only makes getnameinfo() visible when setting _WIN32_WINNT
+ * to 0x0501 (Windows XP) or higher, which is a bug in the MinGW 5.1.6 headers.
+ */
+#define _WIN32_WINNT 0x0501
+
+#include <net-snmp/system/generic.h>
+
+#ifdef HAVE_STDINT_H
+#include <stdint.h>	/* uint32_t */
+#endif
+
+#undef bsdlike
+#undef MBSTAT_SYMBOL
+#undef TOTAL_MEMORY_SYMBOL
+#undef HAVE_GETOPT_H
+#undef HAVE_SOCKET
+#undef HAVE_SIGNAL
+
+/* Define if you have the gettimeofday function.  */
+#define HAVE_GETTIMEOFDAY 1
+
+/* Define if you have the gethostbyname function.  */
+#define HAVE_GETHOSTBYNAME 1
+
+/* Define if you have the gethostname function.  */
+#define HAVE_GETHOSTNAME 1
+
+/* Define if you have raise() instead of alarm() */
+#define HAVE_RAISE 1
+
+/* Define if you have the socket function.  */
+#define HAVE_SOCKET 1
+
+/* Define to 1 if you have the `execv' function. */
+#undef HAVE_EXECV
+
+/* Define to 1 if you have the `fork' function. */
+#undef HAVE_FORK
+
+/*
+ * I'm sure there is a cleaner way to do this.
+ * Probably should be in net_snmp_config.h and
+ * set during config.
+ */
+#ifndef LOG_DAEMON
+#define	LOG_DAEMON	(3<<3)	/* System daemons */
+#endif
+
+/* got socklen_t? */
+#define HAVE_SOCKLEN_T 1
+
+/* This was taken from the win32 config file - see licensing information above */
+#define EADDRINUSE		WSAEADDRINUSE
+
+/*
+ * File io stuff. Odd that this is not defined by MinGW.
+ * Maybe there is an M$ish way to do it.
+ */
+#define	F_SETFL		4
+#define	O_NONBLOCK	0x4000  /* non blocking I/O (POSIX style) */
+
+#ifndef HAVE_STRUCT_TIMEZONE_TZ_DSTTIME
+/*
+ * Older MinGW versions do not have struct timezone, so define it here.
+ */
+struct timezone {
+	int tz_minuteswest;
+	int tz_dsttime;
+};
+#endif
+
diff -rupN quagga-0.99.18//include/net-snmp/system/mingw32msvc.h quaggasnmpTrap//include/net-snmp/system/mingw32msvc.h
--- quagga-0.99.18//include/net-snmp/system/mingw32msvc.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/mingw32msvc.h	2006-08-17 16:14:20.000000000 -0700
@@ -0,0 +1,10 @@
+/*
+ * This header is here to accomodate cross compiling for
+ * Microsoft Windows on a linux host using MinGW. All changes
+ * should be made to mingw32.h - Andy
+ */
+#ifndef mingw32
+#define mingw32 mingw32
+#endif
+
+#include "mingw32.h"
diff -rupN quagga-0.99.18//include/net-snmp/system/mips.h quaggasnmpTrap//include/net-snmp/system/mips.h
--- quagga-0.99.18//include/net-snmp/system/mips.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/mips.h	2006-09-12 15:35:42.000000000 -0700
@@ -0,0 +1,4 @@
+
+#define NETSNMP_DONT_USE_NLIST 1
+
+#undef bsdlike
diff -rupN quagga-0.99.18//include/net-snmp/system/netbsd.h quaggasnmpTrap//include/net-snmp/system/netbsd.h
--- quagga-0.99.18//include/net-snmp/system/netbsd.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/netbsd.h	2009-04-09 01:48:32.000000000 -0700
@@ -0,0 +1,43 @@
+#include "bsd.h"
+
+#include <sys/param.h>
+
+#define PCB_TABLE 1
+#undef TCP_SYMBOL
+#define TCP_SYMBOL "tcbtable"
+#undef TCP_TTL_SYMBOL
+#define TCP_TTL_SYMBOL "ip_defttl"
+#undef UDB_SYMBOL
+#define UDB_SYMBOL "udbtable"
+#undef NPROC_SYMBOL
+#undef PROC_SYMBOL
+
+#define MBPOOL_SYMBOL	"mbpool"
+#define MCLPOOL_SYMBOL	"mclpool"
+
+/*
+ * inp_next symbol 
+ */
+#undef INP_NEXT_SYMBOL
+#define INP_NEXT_SYMBOL inp_queue.cqe_next
+#undef INP_PREV_SYMBOL
+#define INP_PREV_SYMBOL inp_queue.cqe_prev
+#define HAVE_INPCBTABLE 1
+
+#if __NetBSD_Version__ >= 106300000       /* NetBSD 1.6ZD */            
+#undef IFADDR_SYMBOL
+#define IFADDR_SYMBOL "in_ifaddrhead"
+#undef TOTAL_MEMORY_SYMBOL
+#endif
+
+#define UTMP_FILE _PATH_UTMP
+
+#define UDP_ADDRESSES_IN_HOST_ORDER 1
+
+#ifndef netbsd1
+# define netbsd1 netbsd1
+#endif
+
+/* define the extra mib modules that are supported */
+#define NETSNMP_INCLUDE_HOST_RESOURCES
+#define NETSNMP_INCLUDE_IFTABLE_REWRITES
diff -rupN quagga-0.99.18//include/net-snmp/system/nto-qnx6.h quaggasnmpTrap//include/net-snmp/system/nto-qnx6.h
--- quagga-0.99.18//include/net-snmp/system/nto-qnx6.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/nto-qnx6.h	2010-08-19 14:10:59.000000000 -0700
@@ -0,0 +1,35 @@
+#include "bsd.h"
+
+#include <sys/param.h>
+
+#define PCB_TABLE 1
+#undef TCP_SYMBOL
+#define TCP_SYMBOL "tcbtable"
+#undef TCP_TTL_SYMBOL
+#define TCP_TTL_SYMBOL "ip_defttl"
+#undef UDB_SYMBOL
+#define UDB_SYMBOL "udbtable"
+#undef NPROC_SYMBOL
+#undef PROC_SYMBOL
+
+#define MBPOOL_SYMBOL	"mbpool"
+#define MCLPOOL_SYMBOL	"mclpool"
+
+/*
+ * inp_next symbol 
+ */
+#undef INP_NEXT_SYMBOL
+#define INP_NEXT_SYMBOL inp_queue.cqe_next
+#undef INP_PREV_SYMBOL
+#define INP_PREV_SYMBOL inp_queue.cqe_prev
+#define HAVE_INPCBTABLE 1
+
+#undef IFADDR_SYMBOL
+#define IFADDR_SYMBOL "in_ifaddrhead"
+
+#define UTMP_FILE _PATH_UTMP
+
+#define UDP_ADDRESSES_IN_HOST_ORDER 1
+
+/* define the extra mib modules that are supported */
+/* #define NETSNMP_INCLUDE_HOST_RESOURCES */
diff -rupN quagga-0.99.18//include/net-snmp/system/openbsd.h quaggasnmpTrap//include/net-snmp/system/openbsd.h
--- quagga-0.99.18//include/net-snmp/system/openbsd.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/openbsd.h	2007-06-21 07:01:08.000000000 -0700
@@ -0,0 +1,17 @@
+#include "netbsd.h"
+
+#define netbsd1 netbsd1         /* we're really close to this */
+#define UVM
+
+#undef MBPOOL_SYMBOL
+#undef MCLPOOL_SYMBOL
+#undef TOTAL_MEMORY_SYMBOL
+
+/* at least OpenBSD/SPARC 3.7 doesn't define this */
+#ifndef UINT32_MAX
+#define UINT32_MAX	(4294967295U)
+#endif
+
+/* define the extra mib modules that are supported */
+#define NETSNMP_INCLUDE_HOST_RESOURCES
+#define NETSNMP_INCLUDE_IFTABLE_REWRITES
diff -rupN quagga-0.99.18//include/net-snmp/system/osf5.h quaggasnmpTrap//include/net-snmp/system/osf5.h
--- quagga-0.99.18//include/net-snmp/system/osf5.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/osf5.h	2006-10-16 07:54:00.000000000 -0700
@@ -0,0 +1,28 @@
+#include <net-snmp/system/generic.h>
+
+#define osf4 osf4
+
+/* Needed by <sys/socket.h> to give us the correct sockaddr structures */
+#ifndef _SOCKADDR_LEN
+#define _SOCKADDR_LEN
+#endif
+
+#undef TCP_TTL_SYMBOL
+#define TCP_TTL_SYMBOL "tcp_ttl"
+
+/* var_route.c nlist symbols */
+#undef RTTABLES_SYMBOL
+#define RTTABLES_SYMBOL "rtable"
+#undef RTHASHSIZE_SYMBOL
+#define RTHASHSIZE_SYMBOL "rhash_size"
+
+#undef ARPTAB_SIZE_SYMBOL
+
+#ifndef __GNUC__
+#  undef NETSNMP_ENABLE_INLINE
+#  define NETSNMP_ENABLE_INLINE 0
+#endif
+
+#ifndef UINT32_MAX
+#  define UINT32_MAX UINT_MAX
+#endif
diff -rupN quagga-0.99.18//include/net-snmp/system/solaris2.3.h quaggasnmpTrap//include/net-snmp/system/solaris2.3.h
--- quagga-0.99.18//include/net-snmp/system/solaris2.3.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/solaris2.3.h	2006-08-14 15:57:16.000000000 -0700
@@ -0,0 +1 @@
+#include "solaris2.5.h"
diff -rupN quagga-0.99.18//include/net-snmp/system/solaris2.4.h quaggasnmpTrap//include/net-snmp/system/solaris2.4.h
--- quagga-0.99.18//include/net-snmp/system/solaris2.4.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/solaris2.4.h	2006-08-14 15:57:16.000000000 -0700
@@ -0,0 +1 @@
+#include "solaris2.5.h"
diff -rupN quagga-0.99.18//include/net-snmp/system/solaris2.5.h quaggasnmpTrap//include/net-snmp/system/solaris2.5.h
--- quagga-0.99.18//include/net-snmp/system/solaris2.5.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/solaris2.5.h	2006-09-12 15:35:42.000000000 -0700
@@ -0,0 +1,4 @@
+#include "solaris.h"
+#undef _SLASH_PROC_METHOD_
+#undef NETSNMP_DONT_USE_NLIST
+
diff -rupN quagga-0.99.18//include/net-snmp/system/solaris2.6.h quaggasnmpTrap//include/net-snmp/system/solaris2.6.h
--- quagga-0.99.18//include/net-snmp/system/solaris2.6.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/solaris2.6.h	2006-09-12 15:35:42.000000000 -0700
@@ -0,0 +1,2 @@
+#include "solaris.h"
+#undef NETSNMP_DONT_USE_NLIST
diff -rupN quagga-0.99.18//include/net-snmp/system/solaris.h quaggasnmpTrap//include/net-snmp/system/solaris.h
--- quagga-0.99.18//include/net-snmp/system/solaris.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/solaris.h	2008-11-24 11:09:12.000000000 -0800
@@ -0,0 +1,43 @@
+#include "sysv.h"
+
+#undef bsdlike
+#undef IP_FORWARDING_SYMBOL
+#undef ARPTAB_SYMBOL
+#define ARPTAB_SYMBOL "arptab_nb"
+#undef ARPTAB_SIZE_SYMBOL
+#define ARPTAB_SIZE_SYMBOL "arphd"
+#undef ICMPSTAT_SYMBOL
+#undef TCPSTAT_SYMBOL
+#undef TCP_SYMBOL
+#undef UDPSTAT_SYMBOL
+#undef UDB_SYMBOL
+#undef RTTABLES_SYMBOL
+#undef RTHASHSIZE_SYMBOL
+#undef RTHOST_SYMBOL
+#undef RTNET_SYMBOL
+#undef IPSTAT_SYMBOL
+#undef TCP_TTL_SYMBOL
+#undef PROC_SYMBOL
+#undef TOTAL_MEMORY_SYMBOL
+#undef MBSTAT_SYMBOL
+
+#define UDP_ADDRESSES_IN_HOST_ORDER 1
+#define UDP_PORTS_IN_HOST_ORDER 1
+#define TCP_PORTS_IN_HOST_ORDER 1
+
+/* define the extra mib modules that are supported */
+#define NETSNMP_INCLUDE_HOST_RESOURCES
+#define NETSNMP_INCLUDE_IFTABLE_REWRITES
+
+/* Solaris 2.6+ */
+#define _SLASH_PROC_METHOD_ 1
+
+/* Solaris 7+ */
+#define NETSNMP_DONT_USE_NLIST 1
+
+/*
+ * NEW_MIB_COMPLIANT is a define used in Solaris 10U4+ to enable additional
+ * MIB information (it affects the structs in <inet/mib2.h>)
+ */ 
+ 
+#define NEW_MIB_COMPLIANT
diff -rupN quagga-0.99.18//include/net-snmp/system/sunos.h quaggasnmpTrap//include/net-snmp/system/sunos.h
--- quagga-0.99.18//include/net-snmp/system/sunos.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/sunos.h	2004-04-14 02:53:18.000000000 -0700
@@ -0,0 +1,12 @@
+#include <net-snmp/system/generic.h>
+
+typedef int     ssize_t;
+
+#undef IP_FORWARDING_SYMBOL
+#define IP_FORWARDING_SYMBOL "ip_forwarding"
+
+#undef TCP_TTL_SYMBOL
+#define TCP_TTL_SYMBOL "tcp_ttl"
+
+#define UTMP_HAS_NO_TYPE 1
+#define UTMP_FILE "/etc/utmp"
diff -rupN quagga-0.99.18//include/net-snmp/system/svr5.h quaggasnmpTrap//include/net-snmp/system/svr5.h
--- quagga-0.99.18//include/net-snmp/system/svr5.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/svr5.h	2009-02-05 14:56:23.000000000 -0800
@@ -0,0 +1,20 @@
+/*
+ * used to minimally build SCO UnixWare 7.1.0 using CCS 3.2 compiler - YMMV 
+ */
+
+#include <net-snmp/system/generic.h>
+
+/*
+ * using CCS "cc", "configure" does not find this item 
+ */
+#define HAVE_GETHOSTBYNAME 1
+
+/*
+ * lie about this next define to avoid sa_len and sa_family MACROS !! 
+ */
+#define HAVE_STRUCT_SOCKADDR_SA_UNION_SA_GENERIC_SA_FAMILY2 1
+
+/*
+ * this header requires queue_t, not easily done without kernel headers 
+ */
+#undef HAVE_NETINET_IN_PCB_H
diff -rupN quagga-0.99.18//include/net-snmp/system/sysv.h quaggasnmpTrap//include/net-snmp/system/sysv.h
--- quagga-0.99.18//include/net-snmp/system/sysv.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/sysv.h	2004-04-14 02:53:18.000000000 -0700
@@ -0,0 +1,2 @@
+#include <net-snmp/system/generic.h>
+#define SYSV 1
diff -rupN quagga-0.99.18//include/net-snmp/system/ultrix4.h quaggasnmpTrap//include/net-snmp/system/ultrix4.h
--- quagga-0.99.18//include/net-snmp/system/ultrix4.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/system/ultrix4.h	2004-04-14 02:53:18.000000000 -0700
@@ -0,0 +1,9 @@
+#include <net-snmp/system/generic.h>
+#include <sys/types.h>
+
+typedef int     ssize_t;
+
+#undef TCP_TTL_SYMBOL
+#define TCP_TTL_SYMBOL "tcp_ttl"
+
+#undef RTTABLES_SYMBOL
diff -rupN quagga-0.99.18//include/net-snmp/types.h quaggasnmpTrap//include/net-snmp/types.h
--- quagga-0.99.18//include/net-snmp/types.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/types.h	2010-05-12 12:43:32.000000000 -0700
@@ -0,0 +1,414 @@
+#ifndef NET_SNMP_TYPES_H
+#define NET_SNMP_TYPES_H
+
+    /**
+     *  Definitions of data structures, used within the library API.
+     */
+
+#include <stdio.h>
+
+#ifndef NET_SNMP_CONFIG_H
+#error "Please include <net-snmp/net-snmp-config.h> before this file"
+#endif
+
+                        /*
+                         * For 'timeval' 
+                         */
+#if TIME_WITH_SYS_TIME
+# include <sys/time.h>
+# include <time.h>
+#else
+# if HAVE_SYS_TIME_H
+#  include <sys/time.h>
+# else
+#  include <time.h>
+# endif
+#endif
+
+#ifdef HAVE_INTTYPES_H
+#include <inttypes.h>
+#endif
+#include <sys/types.h>
+#if ! defined(_WINSOCKAPI_) && ! defined(_WINSOCK_H)
+/*
+ * If neither the Microsoft winsock header file nor the MinGW winsock header
+ * file has already been included, do this now.
+ */
+# if defined(HAVE_WINSOCK2_H) && defined(HAVE_WS2TCPIP_H)
+#  if !defined(HAVE_WIN32_PLATFORM_SDK) && _MSC_VER -0 <= 1200 \
+    && _WIN32_WINNT -0 >= 0x0400
+    /*
+     * When using the MSVC 6 header files, including <winsock2.h> when
+     * _WIN32_WINNT >= 0x0400 results in a compilation error. Hence include
+     * <windows.h> instead, because <winsock2.h> is included from inside
+     * <windows.h> when _WIN32_WINNT >= 0x0400. The SDK version of <windows.h>
+     * does not include <winsock2.h> however.
+     */
+#   include <windows.h>
+#  else
+#   include <winsock2.h>
+#  endif
+#   include <ws2tcpip.h>
+# elif defined(HAVE_WINSOCK_H)
+#  include <winsock.h>
+# endif
+#endif
+
+#if HAVE_NETINET_IN_H
+#include <netinet/in.h>		/* For definition of in_addr_t */
+#endif
+
+#include <net-snmp/library/oid.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef HAVE_SOCKLEN_T
+typedef u_int socklen_t;
+#endif
+
+#ifndef HAVE_IN_ADDR_T
+  /*
+   * The type in_addr_t must match the type of sockaddr_in::sin_addr.
+   * For MSVC and MinGW32, this is u_long.
+   */
+typedef u_long in_addr_t;
+#endif
+
+#ifndef HAVE_SSIZE_T
+#if defined(__INT_MAX__) && __INT_MAX__ == 2147483647
+typedef int ssize_t;
+#else
+typedef long ssize_t;
+#endif
+#endif
+
+#ifndef HAVE_NFDS_T
+typedef unsigned long int nfds_t;
+#endif
+
+    /*
+     *  For the initial release, this will just refer to the
+     *  relevant UCD header files.
+     *    In due course, the types and structures relevant to the
+     *  Net-SNMP API will be identified, and defined here directly.
+     *
+     *  But for the time being, this header file is primarily a placeholder,
+     *  to allow application writers to adopt the new header file names.
+     */
+
+typedef union {
+   long           *integer;
+   u_char         *string;
+   oid            *objid;
+   u_char         *bitstring;
+   struct counter64 *counter64;
+#ifdef NETSNMP_WITH_OPAQUE_SPECIAL_TYPES
+   float          *floatVal;
+   double         *doubleVal;
+   /*
+    * t_union *unionVal; 
+    */
+#endif                          /* NETSNMP_WITH_OPAQUE_SPECIAL_TYPES */
+} netsnmp_vardata;
+
+
+#define MAX_OID_LEN	    128 /* max subid's in an oid */
+
+/** @typedef struct variable_list netsnmp_variable_list
+ * Typedefs the variable_list struct into netsnmp_variable_list */
+/** @struct variable_list
+ * The netsnmp variable list binding structure, it's typedef'd to
+ * netsnmp_variable_list.
+ */
+typedef struct variable_list {
+   /** NULL for last variable */
+   struct variable_list *next_variable;    
+   /** Object identifier of variable */
+   oid            *name;   
+   /** number of subid's in name */
+   size_t          name_length;    
+   /** ASN type of variable */
+   u_char          type;   
+   /** value of variable */
+    netsnmp_vardata val;
+   /** the length of the value to be copied into buf */
+   size_t          val_len;
+   /** buffer to hold the OID */
+   oid             name_loc[MAX_OID_LEN];  
+   /** 90 percentile < 40. */
+   u_char          buf[40];
+   /** (Opaque) hook for additional data */
+   void           *data;
+   /** callback to free above */
+   void            (*dataFreeHook)(void *);    
+   int             index;
+} netsnmp_variable_list;
+
+
+/** @typedef struct snmp_pdu to netsnmp_pdu
+ * Typedefs the snmp_pdu struct into netsnmp_pdu */
+/** @struct snmp_pdu
+ * The snmp protocol data unit.
+ */	
+typedef struct snmp_pdu {
+
+#define non_repeaters	errstat
+#define max_repetitions errindex
+
+    /*
+     * Protocol-version independent fields
+     */
+    /** snmp version */
+    long            version;
+    /** Type of this PDU */	
+    int             command;
+    /** Request id - note: not incremented on retries */
+    long            reqid;  
+    /** Message id for V3 messages note: incremented for each retry */
+    long            msgid;
+    /** Unique ID for incoming transactions */
+    long            transid;
+    /** Session id for AgentX messages */
+    long            sessid;
+    /** Error status (non_repeaters in GetBulk) */
+    long            errstat;
+    /** Error index (max_repetitions in GetBulk) */
+    long            errindex;       
+    /** Uptime */
+    u_long          time;   
+    u_long          flags;
+
+    int             securityModel;
+    /** noAuthNoPriv, authNoPriv, authPriv */
+    int             securityLevel;  
+    int             msgParseModel;
+
+    /**
+     * Transport-specific opaque data.  This replaces the IP-centric address
+     * field.  
+     */
+    
+    void           *transport_data;
+    int             transport_data_length;
+
+    /**
+     * The actual transport domain.  This SHOULD NOT BE FREE()D.  
+     */
+
+    const oid      *tDomain;
+    size_t          tDomainLen;
+
+    netsnmp_variable_list *variables;
+
+
+    /*
+     * SNMPv1 & SNMPv2c fields
+     */
+    /** community for outgoing requests. */
+    u_char         *community;
+    /** length of community name. */
+    size_t          community_len;  
+
+    /*
+     * Trap information
+     */
+    /** System OID */
+    oid            *enterprise;     
+    size_t          enterprise_length;
+    /** trap type */
+    long            trap_type;
+    /** specific type */
+    long            specific_type;
+    /** This is ONLY used for v1 TRAPs  */
+    unsigned char   agent_addr[4];  
+
+    /*
+     *  SNMPv3 fields
+     */
+    /** context snmpEngineID */
+    u_char         *contextEngineID;
+    /** Length of contextEngineID */
+    size_t          contextEngineIDLen;     
+    /** authoritative contextName */
+    char           *contextName;
+    /** Length of contextName */
+    size_t          contextNameLen;
+    /** authoritative snmpEngineID for security */
+    u_char         *securityEngineID;
+    /** Length of securityEngineID */
+    size_t          securityEngineIDLen;    
+    /** on behalf of this principal */
+    char           *securityName;
+    /** Length of securityName. */
+    size_t          securityNameLen;        
+    
+    /*
+     * AgentX fields
+     *      (also uses SNMPv1 community field)
+     */
+    int             priority;
+    int             range_subid;
+    
+    void           *securityStateRef;
+} netsnmp_pdu;
+
+
+/** @typedef struct snmp_session netsnmp_session
+ * Typedefs the snmp_session struct intonetsnmp_session */
+        struct snmp_session;
+typedef struct snmp_session netsnmp_session;
+
+#define USM_AUTH_KU_LEN     32
+#define USM_PRIV_KU_LEN     32
+
+typedef int        (*snmp_callback) (int, netsnmp_session *, int,
+                                          netsnmp_pdu *, void *);
+typedef int     (*netsnmp_callback) (int, netsnmp_session *, int,
+                                          netsnmp_pdu *, void *);
+
+struct netsnmp_container_s;
+
+/** @struct snmp_session
+ * The snmp session structure.
+ */
+struct snmp_session {
+    /*
+     * Protocol-version independent fields
+     */
+    /** snmp version */
+    long            version;
+    /** Number of retries before timeout. */
+    int             retries;
+    /** Number of uS until first timeout, then exponential backoff */
+    long            timeout;        
+    u_long          flags;
+    struct snmp_session *subsession;
+    struct snmp_session *next;
+
+    /** name or address of default peer (may include transport specifier and/or port number) */
+    char           *peername;
+    /** UDP port number of peer. (NO LONGER USED - USE peername INSTEAD) */
+    u_short         remote_port;
+    /** My Domain name or dotted IP address, 0 for default */
+    char           *localname;
+    /** My UDP port number, 0 for default, picked randomly */
+    u_short         local_port;     
+    /**
+     * Authentication function or NULL if null authentication is used 
+     */
+    u_char         *(*authenticator) (u_char *, size_t *, u_char *, size_t);
+    /** Function to interpret incoming data */
+    netsnmp_callback callback;      
+    /**
+     * Pointer to data that the callback function may consider important 
+     */
+    void           *callback_magic;
+    /** copy of system errno */
+    int             s_errno;
+    /** copy of library errno */
+    int             s_snmp_errno;   
+    /** Session id - AgentX only */
+    long            sessid; 
+
+    /*
+     * SNMPv1 & SNMPv2c fields
+     */
+    /** community for outgoing requests. */
+    u_char         *community;
+    /** Length of community name. */
+    size_t          community_len;  
+    /**  Largest message to try to receive.  */
+    size_t          rcvMsgMaxSize;
+    /**  Largest message to try to send.  */
+    size_t          sndMsgMaxSize;  
+
+    /*
+     * SNMPv3 fields
+     */
+    /** are we the authoritative engine? */
+    u_char          isAuthoritative;
+    /** authoritative snmpEngineID */
+    u_char         *contextEngineID;
+    /** Length of contextEngineID */
+    size_t          contextEngineIDLen;     
+    /** initial engineBoots for remote engine */
+    u_int           engineBoots;
+    /** initial engineTime for remote engine */
+    u_int           engineTime;
+    /** authoritative contextName */
+    char           *contextName;
+    /** Length of contextName */
+    size_t          contextNameLen;
+    /** authoritative snmpEngineID */
+    u_char         *securityEngineID;
+    /** Length of contextEngineID */
+    size_t          securityEngineIDLen;    
+    /** on behalf of this principal */
+    char           *securityName;
+    /** Length of securityName. */
+    size_t          securityNameLen;
+
+    /** auth protocol oid */
+    oid            *securityAuthProto;
+    /** Length of auth protocol oid */
+    size_t          securityAuthProtoLen;
+    /** Ku for auth protocol XXX */
+    u_char          securityAuthKey[USM_AUTH_KU_LEN];       
+    /** Length of Ku for auth protocol */
+    size_t          securityAuthKeyLen;
+    /** Kul for auth protocol */
+    u_char          *securityAuthLocalKey;       
+    /** Length of Kul for auth protocol XXX */
+    size_t          securityAuthLocalKeyLen;       
+
+    /** priv protocol oid */
+    oid            *securityPrivProto;
+    /** Length of priv protocol oid */
+    size_t          securityPrivProtoLen;
+    /** Ku for privacy protocol XXX */
+    u_char          securityPrivKey[USM_PRIV_KU_LEN];       
+    /** Length of Ku for priv protocol */
+    size_t          securityPrivKeyLen;
+    /** Kul for priv protocol */
+    u_char          *securityPrivLocalKey;       
+    /** Length of Kul for priv protocol XXX */
+    size_t          securityPrivLocalKeyLen;       
+
+    /** snmp security model, v1, v2c, usm */
+    int             securityModel;
+    /** noAuthNoPriv, authNoPriv, authPriv */
+    int             securityLevel;  
+    /** target param name */
+    char           *paramName;
+
+    /**
+     * security module specific 
+     */
+    void           *securityInfo;
+
+    /**
+     * transport specific configuration 
+     */
+   struct netsnmp_container_s *transport_configuration;
+
+    /**
+     * use as you want data 
+     *
+     *     used by 'SNMP_FLAGS_RESP_CALLBACK' handling in the agent
+     * XXX: or should we add a new field into this structure?
+     */
+    void           *myvoid;
+};
+
+
+#include <net-snmp/library/types.h>
+#include <net-snmp/definitions.h>
+#include <net-snmp/library/snmp_api.h>
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif                          /* NET_SNMP_TYPES_H */
diff -rupN quagga-0.99.18//include/net-snmp/utilities.h quaggasnmpTrap//include/net-snmp/utilities.h
--- quagga-0.99.18//include/net-snmp/utilities.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/utilities.h	2004-02-02 23:17:31.000000000 -0800
@@ -0,0 +1,63 @@
+#ifndef NET_SNMP_UTILITIES_H
+#define NET_SNMP_UTILITIES_H
+
+    /**
+     *  Library API routines not specifically concerned with SNMP directly,
+     *    but used more generally within the library, agent and other applications.
+     *
+     *  This also includes "standard" system routines, which are missing on
+     *    particular O/S distributiones.
+     */
+
+#ifndef NET_SNMP_CONFIG_H
+#error "Please include <net-snmp/net-snmp-config.h> before this file"
+#endif
+
+#include <net-snmp/types.h>
+
+    /*
+     *  For the initial release, this will just refer to the
+     *  relevant UCD header files.
+     *    In due course, the routines relevant to this area of the
+     *  API will be identified, and listed here directly.
+     *
+     *  But for the time being, this header file is a placeholder,
+     *  to allow application writers to adopt the new header file names.
+     */
+
+#include <net-snmp/library/snmp_api.h>
+#include <net-snmp/library/snmp_client.h>
+#if HAVE_GETOPT_H
+#include <getopt.h>
+#else
+#include <net-snmp/library/getopt.h>
+#endif
+
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h>         /* for in_addr_t */
+#endif
+#include <net-snmp/library/system.h>
+#include <net-snmp/library/tools.h>
+#include <net-snmp/library/asn1.h>      /* for counter64 */
+#include <net-snmp/library/int64.h>
+
+#include <net-snmp/library/mt_support.h>
+/*  #include <net-snmp/library/snmp_locking.h>  */
+#include <net-snmp/library/snmp_alarm.h>
+#include <net-snmp/library/callback.h>
+#include <net-snmp/library/data_list.h>
+#include <net-snmp/library/oid_stash.h>
+#include <net-snmp/library/snmp.h>
+#include <net-snmp/library/snmp_impl.h>
+#include <net-snmp/library/snmp-tc.h>
+#include <net-snmp/library/check_varbind.h>
+#include <net-snmp/library/container.h>
+#include <net-snmp/library/container_binary_array.h>
+#include <net-snmp/library/container_list_ssll.h>
+#include <net-snmp/library/container_iterator.h>
+
+#include <net-snmp/library/snmp_assert.h>
+
+#include <net-snmp/version.h>
+
+#endif                          /* NET_SNMP_UTILITIES_H */
diff -rupN quagga-0.99.18//include/net-snmp/varbind_api.h quaggasnmpTrap//include/net-snmp/varbind_api.h
--- quagga-0.99.18//include/net-snmp/varbind_api.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/varbind_api.h	2010-07-28 07:44:56.000000000 -0700
@@ -0,0 +1,105 @@
+#ifndef NET_SNMP_VARBIND_API_H
+#define NET_SNMP_VARBIND_API_H
+
+    /**
+     *  Library API routines concerned with variable bindings and values.
+     */
+
+#include <net-snmp/types.h>
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+    /* Creation */
+    NETSNMP_IMPORT
+    netsnmp_variable_list *
+       snmp_pdu_add_variable(netsnmp_pdu *pdu,
+                                 const oid * name, size_t name_length,
+                                 u_char type,
+                                 const void * value, size_t len);
+    NETSNMP_IMPORT
+    netsnmp_variable_list *
+       snmp_varlist_add_variable(netsnmp_variable_list ** varlist,
+                                 const oid * name, size_t name_length,
+                                 u_char type,
+                                 const void * value, size_t len);
+    NETSNMP_IMPORT
+    netsnmp_variable_list *
+       snmp_add_null_var(netsnmp_pdu *pdu,
+                                 const oid * name, size_t name_length);
+    NETSNMP_IMPORT
+    netsnmp_variable_list *
+       snmp_clone_varbind(netsnmp_variable_list * varlist);
+
+    /* Setting Values */
+    NETSNMP_IMPORT
+    int             snmp_set_var_objid(netsnmp_variable_list * var,
+                                       const oid * name, size_t name_length);
+    NETSNMP_IMPORT
+    int             snmp_set_var_value(netsnmp_variable_list * var,
+                                       const void * value, size_t len);
+    NETSNMP_IMPORT
+    int             snmp_set_var_typed_value(netsnmp_variable_list * var,
+                                       u_char type,
+                                       const void * value, size_t len);
+    NETSNMP_IMPORT
+    int             snmp_set_var_typed_integer(netsnmp_variable_list * var,
+                                       u_char type, long val);
+
+     /* Output */
+    NETSNMP_IMPORT
+    void            print_variable(const oid * objid, size_t objidlen,
+                                   const netsnmp_variable_list * variable);
+    NETSNMP_IMPORT
+    void           fprint_variable(FILE * fp,
+                                   const oid * objid, size_t objidlen,
+                                   const netsnmp_variable_list * variable);
+    NETSNMP_IMPORT
+    int           snprint_variable(char *buf, size_t buf_len,
+                                   const oid * objid, size_t objidlen,
+                                   const netsnmp_variable_list * variable);
+
+    NETSNMP_IMPORT
+    void             print_value(const oid * objid, size_t objidlen,
+                                 const netsnmp_variable_list * variable);
+    NETSNMP_IMPORT
+    void            fprint_value(FILE * fp,
+                                 const oid * objid, size_t objidlen,
+                                 const netsnmp_variable_list * variable);
+    NETSNMP_IMPORT
+    int            snprint_value(char *buf, size_t buf_len,
+                                 const oid * objid, size_t objidlen,
+                                 const netsnmp_variable_list * variable);
+
+           /* See mib_api.h for {,f,sn}print_objid */
+
+    /* Deletion */
+    NETSNMP_IMPORT
+    void            snmp_free_var(    netsnmp_variable_list *var);     /* frees just this one */
+    NETSNMP_IMPORT
+    void            snmp_free_varbind(netsnmp_variable_list *varlist); /* frees all in list */
+
+#ifdef __cplusplus
+}
+#endif
+
+    /*
+     *    Having extracted the main ("public API") calls relevant
+     *  to this area of the Net-SNMP project, the next step is to
+     *  identify the related "public internal API" routines.
+     *
+     *    In due course, these should probably be gathered
+     *  together into a companion 'library/varbind_api.h' header file.
+     *  [Or some suitable name]
+     *
+     *    But for the time being, the expectation is that the
+     *  traditional headers that provided the above definitions
+     *  will probably also cover the relevant internal API calls.
+     *  Hence they are listed here:
+     */
+#include <net-snmp/library/snmp_api.h>
+#include <net-snmp/library/snmp_client.h>
+#include <net-snmp/library/mib.h>
+
+#endif                          /* NET_SNMP_VARBIND_API_H */
diff -rupN quagga-0.99.18//include/net-snmp/version.h quaggasnmpTrap//include/net-snmp/version.h
--- quagga-0.99.18//include/net-snmp/version.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/net-snmp/version.h	2010-02-27 05:11:15.000000000 -0800
@@ -0,0 +1,18 @@
+#ifndef NET_SNMP_VERSION_H
+#define NET_SNMP_VERSION_H
+
+#ifdef __cplusplus
+extern          "C" {
+#endif
+
+#ifdef UCD_COMPATIBLE
+    extern const char *NetSnmpVersionInfo;
+#endif
+
+    NETSNMP_IMPORT
+    const char     *netsnmp_get_version(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif                          /* NET_SNMP_VERSION_H */
diff -rupN quagga-0.99.18//include/ucd-snmp/agent_index.h quaggasnmpTrap//include/ucd-snmp/agent_index.h
--- quagga-0.99.18//include/ucd-snmp/agent_index.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/agent_index.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/agent/agent_index.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/agent_read_config.h quaggasnmpTrap//include/ucd-snmp/agent_read_config.h
--- quagga-0.99.18//include/ucd-snmp/agent_read_config.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/agent_read_config.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/agent/agent_read_config.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/agent_registry.h quaggasnmpTrap//include/ucd-snmp/agent_registry.h
--- quagga-0.99.18//include/ucd-snmp/agent_registry.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/agent_registry.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/agent/agent_registry.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/agent_trap.h quaggasnmpTrap//include/ucd-snmp/agent_trap.h
--- quagga-0.99.18//include/ucd-snmp/agent_trap.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/agent_trap.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/agent/agent_trap.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/asn1.h quaggasnmpTrap//include/ucd-snmp/asn1.h
--- quagga-0.99.18//include/ucd-snmp/asn1.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/asn1.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/asn1.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/auto_nlist.h quaggasnmpTrap//include/ucd-snmp/auto_nlist.h
--- quagga-0.99.18//include/ucd-snmp/auto_nlist.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/auto_nlist.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/agent/auto_nlist.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/callback.h quaggasnmpTrap//include/ucd-snmp/callback.h
--- quagga-0.99.18//include/ucd-snmp/callback.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/callback.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/callback.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/default_store.h quaggasnmpTrap//include/ucd-snmp/default_store.h
--- quagga-0.99.18//include/ucd-snmp/default_store.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/default_store.h	2002-05-21 01:20:04.000000000 -0700
@@ -0,0 +1,88 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/default_store.h>
+
+/*  Compatibility definitions -- see above header for meaningful comments.  */
+
+#define DS_MAX_IDS			NETSNMP_DS_MAX_IDS
+#define DS_MAX_SUBIDS			NETSNMP_DS_MAX_SUBIDS
+
+#define DS_LIBRARY_ID			NETSNMP_DS_LIBRARY_ID
+#define DS_APPLICATION_ID		NETSNMP_DS_APPLICATION_ID
+#define DS_TOKEN_ID			NETSNMP_DS_TOKEN_ID
+
+#define DS_LIB_MIB_ERRORS		NETSNMP_DS_LIB_MIB_ERRORS
+#define DS_LIB_SAVE_MIB_DESCRS		NETSNMP_DS_LIB_SAVE_MIB_DESCRS
+#define DS_LIB_MIB_COMMENT_TERM		NETSNMP_DS_LIB_MIB_COMMENT_TERM
+#define DS_LIB_MIB_PARSE_LABEL		NETSNMP_DS_LIB_MIB_PARSE_LABEL
+#define DS_LIB_DUMP_PACKET		NETSNMP_DS_LIB_DUMP_PACKET
+#define DS_LIB_LOG_TIMESTAMP		NETSNMP_DS_LIB_LOG_TIMESTAMP
+#define DS_LIB_DONT_READ_CONFIGS	NETSNMP_DS_LIB_DONT_READ_CONFIGS
+#define DS_LIB_MIB_REPLACE		NETSNMP_DS_LIB_MIB_REPLACE
+#define DS_LIB_PRINT_NUMERIC_ENUM	NETSNMP_DS_LIB_PRINT_NUMERIC_ENUM
+#define DS_LIB_PRINT_NUMERIC_OIDS	NETSNMP_DS_LIB_PRINT_NUMERIC_OIDS
+#define DS_LIB_DONT_BREAKDOWN_OIDS	NETSNMP_DS_LIB_DONT_BREAKDOWN_OIDS
+#define DS_LIB_ALARM_DONT_USE_SIG 	NETSNMP_DS_LIB_ALARM_DONT_USE_SIG
+#define DS_LIB_PRINT_FULL_OID 		NETSNMP_DS_LIB_PRINT_FULL_OID
+#define DS_LIB_QUICK_PRINT 		NETSNMP_DS_LIB_QUICK_PRINT
+#define DS_LIB_RANDOM_ACCESS 		NETSNMP_DS_LIB_RANDOM_ACCESS
+#define DS_LIB_REGEX_ACCESS 		NETSNMP_DS_LIB_REGEX_ACCESS
+#define DS_LIB_DONT_CHECK_RANGE 	NETSNMP_DS_LIB_DONT_CHECK_RANGE
+#define DS_LIB_NO_TOKEN_WARNINGS 	NETSNMP_DS_LIB_NO_TOKEN_WARNINGS
+#define DS_LIB_NUMERIC_TIMETICKS 	NETSNMP_DS_LIB_NUMERIC_TIMETICKS
+#define DS_LIB_ESCAPE_QUOTES 		NETSNMP_DS_LIB_ESCAPE_QUOTES
+#define DS_LIB_REVERSE_ENCODE 		NETSNMP_DS_LIB_REVERSE_ENCODE
+#define DS_LIB_PRINT_BARE_VALUE 	NETSNMP_DS_LIB_PRINT_BARE_VALUE
+#define DS_LIB_EXTENDED_INDEX 		NETSNMP_DS_LIB_EXTENDED_INDEX
+#define DS_LIB_PRINT_HEX_TEXT 		NETSNMP_DS_LIB_PRINT_HEX_TEXT
+
+#define DS_LIB_MIB_WARNINGS		NETSNMP_DS_LIB_MIB_WARNINGS
+#define DS_LIB_SECLEVEL			NETSNMP_DS_LIB_SECLEVEL
+#define DS_LIB_SNMPVERSION		NETSNMP_DS_LIB_SNMPVERSION
+#define DS_LIB_DEFAULT_PORT		NETSNMP_DS_LIB_DEFAULT_PORT
+#define DS_LIB_PRINT_SUFFIX_ONLY	NETSNMP_DS_LIB_PRINT_SUFFIX_ONLY
+
+#define DS_LIB_SECNAME			NETSNMP_DS_LIB_SECNAME
+#define DS_LIB_CONTEXT			NETSNMP_DS_LIB_CONTEXT
+#define DS_LIB_PASSPHRASE		NETSNMP_DS_LIB_PASSPHRASE
+#define DS_LIB_AUTHPASSPHRASE		NETSNMP_DS_LIB_AUTHPASSPHRASE
+#define DS_LIB_PRIVPASSPHRASE		NETSNMP_DS_LIB_PRIVPASSPHRASE
+#define DS_LIB_OPTIONALCONFIG		NETSNMP_DS_LIB_OPTIONALCONFIG
+#define DS_LIB_APPTYPE			NETSNMP_DS_LIB_APPTYPE
+#define DS_LIB_COMMUNITY		NETSNMP_DS_LIB_COMMUNITY
+#define DS_LIB_PERSISTENT_DIR		NETSNMP_DS_LIB_PERSISTENT_DIR
+#define DS_LIB_CONFIGURATION_DIR	NETSNMP_DS_LIB_CONFIGURATION_DIR
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int	ds_set_boolean		(int storeid, int which, int value);
+int	ds_get_boolean		(int storeid, int which);
+int	ds_toggle_boolean	(int storeid, int which);
+
+int	ds_set_int		(int storeid, int which, int value);
+int	ds_get_int		(int storeid, int which);
+
+int	ds_set_string		(int storeid, int which, const char *value);
+char   *ds_get_string		(int storeid, int which);
+
+int 	ds_set_void		(int storeid, int which, void *value);
+void   *ds_get_void		(int storeid, int which);
+
+int	ds_register_config	(u_char type, const char *ftype,
+				 const char *token, int storeid, int which);
+int	ds_register_premib	(u_char type, const char *ftype,
+				 const char *token, int storeid, int which);
+
+void	ds_shutdown		(void);
+
+#ifdef __cplusplus
+}
+#endif
+
+#else /* UCD_COMPATIBLE */
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/ds_agent.h quaggasnmpTrap//include/ucd-snmp/ds_agent.h
--- quagga-0.99.18//include/ucd-snmp/ds_agent.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/ds_agent.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/agent/ds_agent.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/header_complex.h quaggasnmpTrap//include/ucd-snmp/header_complex.h
--- quagga-0.99.18//include/ucd-snmp/header_complex.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/header_complex.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/agent/header_complex.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/int64.h quaggasnmpTrap//include/ucd-snmp/int64.h
--- quagga-0.99.18//include/ucd-snmp/int64.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/int64.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/int64.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/keytools.h quaggasnmpTrap//include/ucd-snmp/keytools.h
--- quagga-0.99.18//include/ucd-snmp/keytools.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/keytools.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/keytools.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/mib.h quaggasnmpTrap//include/ucd-snmp/mib.h
--- quagga-0.99.18//include/ucd-snmp/mib.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/mib.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/mib.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/mibincl.h quaggasnmpTrap//include/ucd-snmp/mibincl.h
--- quagga-0.99.18//include/ucd-snmp/mibincl.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/mibincl.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/mibincl.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/mib_module_config.h quaggasnmpTrap//include/ucd-snmp/mib_module_config.h
--- quagga-0.99.18//include/ucd-snmp/mib_module_config.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/mib_module_config.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/agent/mib_module_config.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/parse.h quaggasnmpTrap//include/ucd-snmp/parse.h
--- quagga-0.99.18//include/ucd-snmp/parse.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/parse.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/parse.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/read_config.h quaggasnmpTrap//include/ucd-snmp/read_config.h
--- quagga-0.99.18//include/ucd-snmp/read_config.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/read_config.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/read_config.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/README quaggasnmpTrap//include/ucd-snmp/README
--- quagga-0.99.18//include/ucd-snmp/README	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/README	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,3 @@
+This directory contains compatibility include files to make the newer
+work of the net-snmp code still work with code written for the
+ucd-snmp package.
diff -rupN quagga-0.99.18//include/ucd-snmp/scapi.h quaggasnmpTrap//include/ucd-snmp/scapi.h
--- quagga-0.99.18//include/ucd-snmp/scapi.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/scapi.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/scapi.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/snmp_agent.h quaggasnmpTrap//include/ucd-snmp/snmp_agent.h
--- quagga-0.99.18//include/ucd-snmp/snmp_agent.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/snmp_agent.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/agent/snmp_agent.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/snmp_alarm.h quaggasnmpTrap//include/ucd-snmp/snmp_alarm.h
--- quagga-0.99.18//include/ucd-snmp/snmp_alarm.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/snmp_alarm.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/snmp_alarm.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/snmp_api.h quaggasnmpTrap//include/ucd-snmp/snmp_api.h
--- quagga-0.99.18//include/ucd-snmp/snmp_api.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/snmp_api.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/snmp_api.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/snmp_client.h quaggasnmpTrap//include/ucd-snmp/snmp_client.h
--- quagga-0.99.18//include/ucd-snmp/snmp_client.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/snmp_client.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/snmp_client.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/snmp_debug.h quaggasnmpTrap//include/ucd-snmp/snmp_debug.h
--- quagga-0.99.18//include/ucd-snmp/snmp_debug.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/snmp_debug.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/snmp_debug.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/snmp.h quaggasnmpTrap//include/ucd-snmp/snmp.h
--- quagga-0.99.18//include/ucd-snmp/snmp.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/snmp.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/snmp.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/snmp_impl.h quaggasnmpTrap//include/ucd-snmp/snmp_impl.h
--- quagga-0.99.18//include/ucd-snmp/snmp_impl.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/snmp_impl.h	2004-10-07 19:31:34.000000000 -0700
@@ -0,0 +1,11 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/types.h>
+#include <net-snmp/library/snmp_impl.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/snmp_logging.h quaggasnmpTrap//include/ucd-snmp/snmp_logging.h
--- quagga-0.99.18//include/ucd-snmp/snmp_logging.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/snmp_logging.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/snmp_logging.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/snmp_parse_args.h quaggasnmpTrap//include/ucd-snmp/snmp_parse_args.h
--- quagga-0.99.18//include/ucd-snmp/snmp_parse_args.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/snmp_parse_args.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/snmp_parse_args.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/snmp-tc.h quaggasnmpTrap//include/ucd-snmp/snmp-tc.h
--- quagga-0.99.18//include/ucd-snmp/snmp-tc.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/snmp-tc.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/snmp-tc.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/snmpusm.h quaggasnmpTrap//include/ucd-snmp/snmpusm.h
--- quagga-0.99.18//include/ucd-snmp/snmpusm.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/snmpusm.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/snmpusm.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/snmpv3.h quaggasnmpTrap//include/ucd-snmp/snmpv3.h
--- quagga-0.99.18//include/ucd-snmp/snmpv3.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/snmpv3.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/snmpv3.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/snmp_vars.h quaggasnmpTrap//include/ucd-snmp/snmp_vars.h
--- quagga-0.99.18//include/ucd-snmp/snmp_vars.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/snmp_vars.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/snmp_vars.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/struct.h quaggasnmpTrap//include/ucd-snmp/struct.h
--- quagga-0.99.18//include/ucd-snmp/struct.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/struct.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/agent/struct.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/system.h quaggasnmpTrap//include/ucd-snmp/system.h
--- quagga-0.99.18//include/ucd-snmp/system.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/system.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/system.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/tools.h quaggasnmpTrap//include/ucd-snmp/tools.h
--- quagga-0.99.18//include/ucd-snmp/tools.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/tools.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/tools.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/transform_oids.h quaggasnmpTrap//include/ucd-snmp/transform_oids.h
--- quagga-0.99.18//include/ucd-snmp/transform_oids.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/transform_oids.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/library/transform_oids.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/ucd-snmp-agent-includes.h quaggasnmpTrap//include/ucd-snmp/ucd-snmp-agent-includes.h
--- quagga-0.99.18//include/ucd-snmp/ucd-snmp-agent-includes.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/ucd-snmp-agent-includes.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/ucd-snmp-config.h quaggasnmpTrap//include/ucd-snmp/ucd-snmp-config.h
--- quagga-0.99.18//include/ucd-snmp/ucd-snmp-config.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/ucd-snmp-config.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,2 @@
+#define UCD_COMPATIBLE
+#include <net-snmp/net-snmp-config.h>
diff -rupN quagga-0.99.18//include/ucd-snmp/ucd-snmp-includes.h quaggasnmpTrap//include/ucd-snmp/ucd-snmp-includes.h
--- quagga-0.99.18//include/ucd-snmp/ucd-snmp-includes.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/ucd-snmp-includes.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/net-snmp-includes.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/util_funcs.h quaggasnmpTrap//include/ucd-snmp/util_funcs.h
--- quagga-0.99.18//include/ucd-snmp/util_funcs.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/util_funcs.h	2007-02-26 06:38:46.000000000 -0800
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/agent/util_funcs.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/var_struct.h quaggasnmpTrap//include/ucd-snmp/var_struct.h
--- quagga-0.99.18//include/ucd-snmp/var_struct.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/var_struct.h	2002-04-20 00:30:29.000000000 -0700
@@ -0,0 +1,9 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/agent/var_struct.h>
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
diff -rupN quagga-0.99.18//include/ucd-snmp/version.h quaggasnmpTrap//include/ucd-snmp/version.h
--- quagga-0.99.18//include/ucd-snmp/version.h	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//include/ucd-snmp/version.h	2004-04-20 20:48:51.000000000 -0700
@@ -0,0 +1,11 @@
+#ifdef UCD_COMPATIBLE
+
+#include <net-snmp/version.h>
+
+#define VersionInfo NetSnmpVersionInfo
+
+#else
+
+#error "Please update your headers or configure using --enable-ucd-snmp-compatibility"
+
+#endif
Los archivos binarios quagga-0.99.18//lib/libsnmp.a y quaggasnmpTrap//lib/libsnmp.a son distintos
diff -rupN quagga-0.99.18//lib/libsnmp.la quaggasnmpTrap//lib/libsnmp.la
--- quagga-0.99.18//lib/libsnmp.la	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//lib/libsnmp.la	2010-08-25 10:39:00.000000000 -0700
@@ -0,0 +1,41 @@
+# libsnmp.la - a libtool library file
+# Generated by ltmain.sh (GNU libtool) 2.2.6b Debian-2.2.6b-2ubuntu1
+#
+# Please DO NOT delete this file!
+# It is necessary for linking the library.
+
+# The name that we can dlopen(3).
+dlname='libsnmp.so.15'
+
+# Names of this library.
+library_names='libsnmp.so.15.1.2 libsnmp.so.15 libsnmp.so'
+
+# The name of the static archive.
+old_library='libsnmp.a'
+
+# Linker flags that can not go in dependency_libs.
+inherited_linker_flags=''
+
+# Libraries that this one depends upon.
+dependency_libs=' -lcrypto'
+
+# Names of additional weak libraries provided by this library
+weak_library_names=''
+
+# Version information for libsnmp.
+current=16
+age=1
+revision=2
+
+# Is this an already installed library?
+installed=yes
+
+# Should we warn about portability when linking against -modules?
+shouldnotlink=no
+
+# Files to dlopen/dlpreopen
+dlopen=''
+dlpreopen=''
+
+# Directory that this library needs to be installed in:
+libdir='/usr/lib'
Los archivos binarios quagga-0.99.18//lib/libsnmp.so y quaggasnmpTrap//lib/libsnmp.so son distintos
Los archivos binarios quagga-0.99.18//lib/libsnmp.so.15 y quaggasnmpTrap//lib/libsnmp.so.15 son distintos
Los archivos binarios quagga-0.99.18//lib/libsnmp.so.15.1.2 y quaggasnmpTrap//lib/libsnmp.so.15.1.2 son distintos
diff -rupN quagga-0.99.18//lib/sendsnmptrap.c quaggasnmpTrap//lib/sendsnmptrap.c
--- quagga-0.99.18//lib/sendsnmptrap.c	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//lib/sendsnmptrap.c	2011-04-11 05:09:28.000000000 -0700
@@ -0,0 +1,387 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ * Send SNMP Trap to a network entity.
+ *
+ * New file in Quagga, added by QUAGGA snmpTRAP VERSION.
+ * Contains all the essential to send a trap with params about a IP-route.
+ * This is a mix between SNMP functions and custom functions by QUAGGA snmpTRAP VERSION.
+ * The SNMP functions are from NET-SNMP suite, specifically from: net-snmp/apps/snmptrap.c.
+ * 			Copyright 1989, 1991, 1992 by Carnegie Mellon University
+ * 			All Rights Reserved.
+ *			More info about copyright in README-Quagga-snmpTrap.txt.
+ * In this version of Quagga, this unit is used to send a trap when a IP-route is added or deleted to the kernel.
+ * For more info, read README-Quagga-snmpTrap.txt
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
+ * Copyright (C) 1997, 98, 99, 2001 Kunihiro Ishiguro
+ *
+ * This file is part of GNU Zebra.
+ *
+ * GNU Zebra is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * GNU Zebra is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Zebra; see the file COPYING.  If not, write to the Free
+ * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.  
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#if HAVE_SYS_SELECT_H
+#include <sys/select.h>
+#endif
+#if HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+#if HAVE_NETDB_H
+#include <netdb.h>
+#endif
+#if HAVE_ARPA_INET_H
+#include <arpa/inet.h>
+#endif
+
+#include <net-snmp/net-snmp-includes.h>
+
+/*Global params*/
+    oid             objid_enterprise[] = { 1, 3, 6, 1, 4, 1, 3, 1, 1 };
+    oid             objid_sysdescr[] = { 1, 3, 6, 1, 2, 1, 1, 1, 0 };
+    oid             objid_sysuptime[] = { 1, 3, 6, 1, 2, 1, 1, 3, 0 };
+    oid             objid_snmptrap[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };
+    netsnmp_session session, *ss;
+    netsnmp_pdu    *pdu;
+    oid             name[MAX_OID_LEN];
+    size_t          name_length;
+    int             status;
+    int             arg;
+    int             exitval = 0;
+    char *enterprise = "0", *trapGenerico = "6", *trapEspecifico = "1.3.6.1.2.1.4";
+    char *trapoid = "1.3.6.1.2.1.4";			/*ip OID = iso.org.dod.internet.mgmt.mib-2.ip*/
+    char	   *route_info_trap = "0.0";		/*default value: ip.21.1.13 = OID = 0.0*/
+    in_addr_t      *pdu_in_addr_t;
+
+/*PROTOTYPES*/
+int snmp_input(int operation,netsnmp_session * session,int reqid, netsnmp_pdu *pdu, void *magic);
+char *getNetMask(char **mask, const u_char prefixlen);
+int build_and_send(char **str_ip, char **ifindex_num, char **metric_num, 
+	    	char **nexthop_value, char **routeType, char **protocol, char **netmask);
+int send_trap(const struct prefix_ipv4 *p, const unsigned int ifindex,const u_int32_t metric, 
+		const struct in_addr *nexthop, char *routeType, char *protocol, char *version, char *dest, char	*community);
+
+
+/* Dumb function needed in main function.
+ * It is a legacy from Net-SNMP
+ */
+int
+snmp_input(int operation,
+           netsnmp_session * session,
+           int reqid, netsnmp_pdu *pdu, void *magic)
+{
+    return 1;
+}
+
+/* Get the netmask format to char with dots from CIDR format
+ * Params:      mask: a string with the netmask in dots format.
+ *         prefixlen: the netmask in CIDR format
+ * Return:      mask: a string in format xxx.xxx.xxx.xxx. 
+ */
+char *getNetMask(char **mask, const u_char prefixlen){
+    *mask=malloc(sizeof(char)*15);
+    memset( *mask, '\0', sizeof(*mask) );
+    int m = prefixlen / 8;
+    int aux = prefixlen;
+    while(aux>=8){
+	strcat(*mask,"255.");
+	aux=aux-8;
+    }
+    if(aux!=0){
+	int acum = 128, n = 0;
+	char *valor= malloc(sizeof(int));
+	m++;
+	while(aux>0){
+		n+=acum;
+		acum=acum/2;
+		aux--;
+	}
+	snprintf(valor,sizeof(int),"%d",n);
+	strcat(*mask,valor);
+	free(valor);
+	if(m<4)
+		strcat(*mask,".");
+    }
+    /*fill with '0'*/
+    while(m<4){
+	if(m==3)
+		strcat(*mask,"0");
+	else
+		strcat(*mask,"0.");
+		m++;
+    }
+    return *mask;
+}
+
+/* Build the snmp packet (PDU), with all variables that inform about a route.
+ * Add to the pdu (global variable) the incoming and some global params.
+ * Finally, the pdu is sent.
+ * Params: str_ip: IP address.
+ *         ifindex: interface index, the route str_ip was learned by this interface.
+ *         metric_num: metric value of the route that is called str_ip.
+ *         nexthop_value: the next hop if we want to achieve this route (str_ip).
+ *         routeType: 
+ * return: -1,  if there is an error when conf file is reading
+ * 		or if there are incorrect commands.
+ * return: 0 , if there is no command, so the TRAPS are disabled.
+ * return: n > 0, the number of commands.
+ */
+int 
+build_and_send(char **str_ip, char **ifindex_num, char **metric_num, 
+	    char **nexthop_value, char **routeType, char **protocol, char **netmask){
+
+    	char *dot=".";
+	/*ipRoutedest = 1.3.6.1.2.1.4.21.1.1*/
+	char *str_routeDest = calloc (strlen(*str_ip)+strlen("1.3.6.1.2.1.4.21.1.1")+1, sizeof(char));
+	strcat(strcat(strcat(str_routeDest,"1.3.6.1.2.1.4.21.1.1"),dot),*str_ip);
+	/*ipRouteIfIndex = 1.3.6.1.2.1.4.21.1.2*/
+	char *str_ifindex = calloc(strlen(*str_ip)+strlen("1.3.6.1.2.1.4.21.1.2")+1, sizeof(char));
+	strcat(strcat(strcat(str_ifindex,"1.3.6.1.2.1.4.21.1.2"),dot),*str_ip);
+	/*ipRouteMetric1 = 1.3.6.1.2.1.4.21.1.3*/
+	char *str_metric = calloc(strlen(*str_ip)+strlen("1.3.6.1.2.1.4.21.1.3")+1, sizeof(char));
+	strcat(strcat(strcat(str_metric,"1.3.6.1.2.1.4.21.1.3"),dot), *str_ip);
+	/*ipRouteNextHop = 1.3.6.1.2.1.4.21.1.7*/
+	char *str_nexthop = calloc(strlen(*str_ip)+strlen("1.3.6.1.2.1.4.21.1.7")+1, sizeof(char));
+	strcat(strcat(strcat(str_nexthop,"1.3.6.1.2.1.4.21.1.7"),dot),*str_ip);
+	/*ipRouteType = 1.3.6.1.2.1.4.21.1.8*/
+	char *str_routeType = calloc(strlen(*str_ip)+strlen("1.3.6.1.2.1.4.21.1.8")+1, sizeof(char));
+	strcat(strcat(strcat(str_routeType,"1.3.6.1.2.1.4.21.1.8"),dot),*str_ip);
+	/*ipRouteProto = 1.3.6.1.2.1.4.21.1.9*/
+	char *str_proto = calloc(strlen(*str_ip)+strlen("1.3.6.1.2.1.4.21.1.9")+1, sizeof(char));
+	strcat(strcat(strcat(str_proto,"1.3.6.1.2.1.4.21.1.9"),dot),*str_ip);
+	/*ipRouteMask = 1.3.6.1.2.1.4.21.1.11*/
+	char *str_netmask = calloc(strlen(*str_ip)+strlen("1.3.6.1.2.1.4.21.1.11")+1, sizeof(char));
+	strcat(strcat(strcat(str_netmask,"1.3.6.1.2.1.4.21.1.11"),dot),*str_ip);
+	/*ipRouteInfo = 1.3.6.1.2.1.4.21.1.13*/
+	char *str_info = calloc(strlen(*str_ip)+strlen("1.3.6.1.2.1.4.21.1.13")+1, sizeof(char));
+	strcat(strcat(strcat(str_info,"1.3.6.1.2.1.4.21.1.13"),dot),*str_ip);
+	
+	char* oid_type_value[]={str_routeDest, "a", *str_ip, str_ifindex, "i", *ifindex_num, 
+				str_metric, "i", *metric_num, str_nexthop,"a", *nexthop_value, 
+				str_routeType, "i", *routeType, str_proto,"i", *protocol, 
+				str_netmask, "a", *netmask, str_info, "o", route_info_trap};
+	int size_oid_type_value = sizeof(oid_type_value)/sizeof(int);
+	
+						/*adding values to the TRAP*/
+	arg=0;
+        while (arg < size_oid_type_value) {
+        arg = arg + 3;
+        if (arg > size_oid_type_value ) {
+            fprintf(stderr, "%s: Missing type/value for variable\n",oid_type_value[arg - 3]);
+            SOCK_CLEANUP;
+            //exit(1);
+	    return 1;
+        }
+        name_length = MAX_OID_LEN;
+        if (!snmp_parse_oid(oid_type_value[arg - 3], name, &name_length)) {
+            snmp_perror(oid_type_value[arg - 3]);
+            SOCK_CLEANUP;
+            //exit(1);
+	     return 1;
+        }
+        if (snmp_add_var
+            (pdu, name, name_length, oid_type_value[arg - 2][0],oid_type_value[arg - 1]) != 0) {
+            snmp_perror(oid_type_value[arg - 3]);
+            SOCK_CLEANUP;
+            //exit(1);
+	     return 1;
+        }
+    }
+    /*SEND AND CLOSE THE TRAP*/
+    
+    status = snmp_send(ss, pdu) == 0;
+    if (status) {
+        snmp_sess_perror("snmptrap", ss);
+        snmp_free_pdu(pdu);
+        exitval = 1;
+    } 
+    free(str_routeDest);
+    free(str_ifindex);
+    free(str_metric);
+    free(str_nexthop);
+    free(str_routeType);
+    free(str_proto);
+    free(str_netmask);
+    free(str_info);
+
+    snmp_close(ss);
+    snmp_shutdown("snmpapp");
+    SOCK_CLEANUP;
+
+    return exitval;
+}
+
+/* Main function to send the TRAP.
+ * Receives the params, makes the datagram (PDU) and sends it.
+ * 
+ * Params: p: IP address of the new route/net learned.
+ *         ifindex: interface index, the route/net was learned by this interface.
+ *         metric: metric value of the route.
+ *         nexthop: the next hop if we want to achieve this route/net.
+ *         routeType: The route was added or deleted.
+ *         protocol: Which routing protocol has learned the route/net.
+ *         version: SNMP version.
+ *         dest: Destination of the TRAP. Usually is the manager station.
+ *         community: Name of the SNMP community.
+ * return: -1,  if there is some error.
+ * return: 0 , everything is ok.
+ */
+int
+send_trap(const struct prefix_ipv4 *p, const unsigned int ifindex, const u_int32_t metric, 
+	    const struct in_addr *nexthop, char *routeType, char *protocol, char *version, char *dest, char *community){
+   
+    /*format IP address to char*/
+    char *str_ip = malloc(sizeof(char)*15);
+    char *aux = inet_ntoa(p->prefix);
+    strcpy(str_ip,aux);
+    /*format nexthop address to char*/
+    char *nexthop_value = malloc(sizeof(char)*15);
+    aux = inet_ntoa(*nexthop);
+    strcpy(nexthop_value,aux);
+
+    /*format ifindex to char*/
+    char *ifindex_num = malloc(sizeof(unsigned int));
+    sprintf(ifindex_num,"%d",ifindex);
+    /*format metric to char*/
+    char *metric_num = malloc(sizeof(int)*2);
+    sprintf(metric_num,"%d",metric);
+
+    /*format CIDR netmask to char with dots*/
+    char *netmask = NULL;
+    getNetMask(&netmask, p->prefixlen);
+
+    putenv(strdup("POSIXLY_CORRECT=1"));
+    /*initialize session*/
+    snmp_sess_init(&session);
+    init_snmp("snmpapp");
+    /*add version name*/
+    if(!strcmp(version,"v1"))
+    	session.version = SNMP_VERSION_1;
+    else
+	session.version = SNMP_VERSION_2c;
+    /*add community name*/
+    session.community = (unsigned char *)community;
+    session.community_len = strlen(community);
+    /*add destinity name*/
+    session.peername = dest;
+
+    SOCK_STARTUP;
+
+    session.callback = snmp_input;
+    session.callback_magic = NULL;
+
+    /*
+     * setup the local engineID which may be for either or both of the
+     * contextEngineID and/or the securityEngineID.
+     */
+    setup_engineID(NULL, NULL);
+
+    /* if we don't have a contextEngineID set via command line
+       arguments, use our internal engineID as the context. */
+    if (session.contextEngineIDLen == 0 ||
+        session.contextEngineID == NULL) {
+        session.contextEngineID =
+            snmpv3_generate_engineID(&session.contextEngineIDLen);
+    }
+
+    ss = snmp_add(&session,
+                  netsnmp_transport_open_client("snmptrap", session.peername),
+                  NULL, NULL);
+    if (ss == NULL) {
+        /*
+         * diagnose netsnmp_transport_open_client and snmp_add errors with
+         * the input netsnmp_session pointer
+         */
+        snmp_sess_perror("snmptrap", &session);
+	fprintf(stderr, "Failed to create session trap PDU\n");
+        SOCK_CLEANUP;
+	return 1;
+        //exit(1);
+    }
+	/*START: version 1*/							
+    if(!strcmp(version,"v1")){	
+        pdu = snmp_pdu_create(SNMP_MSG_TRAP);
+        if ( !pdu ) {
+            fprintf(stderr, "Failed to create trap PDU\n");
+            SOCK_CLEANUP;
+	    return 1;
+            //exit(1);
+        }
+        pdu_in_addr_t = (in_addr_t *) pdu->agent_addr;
+
+	/*enterprise section */
+	if (enterprise[0] == 0) {
+        	pdu->enterprise = (oid *) malloc(sizeof(objid_enterprise));
+        	memcpy(pdu->enterprise, objid_enterprise,sizeof(objid_enterprise));
+        	pdu->enterprise_length = sizeof(objid_enterprise) / sizeof(oid);
+	}
+	else{
+            name_length = MAX_OID_LEN;
+            if (!snmp_parse_oid(enterprise, name, &name_length)) {
+                snmp_perror(enterprise);
+                SOCK_CLEANUP;
+                //exit(1);
+		fprintf(stderr, "Failed to create trap PDU enterprise section\n");
+		return 1;
+            }
+            pdu->enterprise = (oid *) malloc(name_length * sizeof(oid));
+            memcpy(pdu->enterprise, name, name_length * sizeof(oid));
+            pdu->enterprise_length = name_length;
+        }
+	/*agent section*/
+        *pdu_in_addr_t = get_myaddr();
+	/*generic trap*/
+        pdu->trap_type = atoi(trapGenerico);
+	/*specific trap (generic must be = 6)*/
+        pdu->specific_type = atoi(trapEspecifico);
+	/*uptime*/
+        pdu->time = get_uptime();				
+            
+    }	/*END: version 1*/	
+	/*START: version 2*/
+    else{
+	long sysuptime;
+        char csysuptime[20];
+
+        pdu = snmp_pdu_create(SNMP_MSG_TRAP2);
+        if ( !pdu ) {
+            fprintf(stderr, "Failed to create notification PDU\n");
+            SOCK_CLEANUP;
+            //exit(1);
+	    return 1;
+        }
+        /*uptime*/
+        sysuptime = get_uptime();
+        sprintf(csysuptime, "%ld", sysuptime);
+        snmp_add_var(pdu, objid_sysuptime,sizeof(objid_sysuptime) / sizeof(oid), 't', csysuptime);
+        
+        if (snmp_add_var(pdu, objid_snmptrap, sizeof(objid_snmptrap) / sizeof(oid),'o', trapoid) != 0) {
+            snmp_perror(trapoid);
+            SOCK_CLEANUP;
+            //exit(1);
+	    return 1;
+        }
+    }	/*END: version 2*/
+
+	/*ADD VARIABLES TO THE TRAP AND SEND IT*/
+	int exit_value = build_and_send(&str_ip, &ifindex_num, &metric_num, &nexthop_value, &routeType, &protocol, &netmask);
+	free(str_ip);
+	free(ifindex_num);
+	free(metric_num);
+	free(nexthop_value);
+	free(netmask);
+    return exit_value;
+}
+
diff -rupN quagga-0.99.18//README quaggasnmpTrap//README
--- quagga-0.99.18//README	2011-03-21 02:43:52.000000000 -0700
+++ quaggasnmpTrap//README	2011-04-11 04:55:19.000000000 -0700
@@ -5,6 +5,8 @@ Currently Quagga supports BGP4, BGP4+, O
 RIPv2, and RIPng as well as very early support for IS-IS.
   
 See the file INSTALL.quagga.txt for building and installation instructions.
+
+See the file README-Quagga-snmpTRAP.txt to read the changes from original Quagga.
   
 See the file REPORTING-BUGS to report bugs.
   
diff -rupN quagga-0.99.18//README-Quagga-snmpTrap.txt quaggasnmpTrap//README-Quagga-snmpTrap.txt
--- quagga-0.99.18//README-Quagga-snmpTrap.txt	1969-12-31 16:00:00.000000000 -0800
+++ quaggasnmpTrap//README-Quagga-snmpTrap.txt	2011-06-07 12:07:48.000000000 -0700
@@ -0,0 +1,126 @@
+Quagga-snmpTrap-Version 0.99.18
+
+This is a normal Quagga but it has a new modification. It is able to send an alert (TRAP), when Zebra adds/deletes a route in kernel.
+
+All of this is a part of a senior year project raised to increase the capabilities of Quagga routing suite. At the same time, it pretends the suite can be understood with Simple Network Management Protocol, whose initials are SNMP, which is very extended and it is very used by networks managers. All without using proxy servers or proxy devices.
+
+The project consist in to give to Quagga the capability of sending alerts through SNMP, whenever the main daemon, Zebra, adds or removes routes to or from the device kernel where it is installed. These alerts are sent using a SNMP packet called TRAP, so network managers can get these automatically in the destination that they have configured.
+
+For the project, it was used the last version of Quagga, 0.99.18, although the changes are very extensibles and duly documented, so if future versions of oficial Quagga donÃÂ´t include these changes, the same improvement can be made without problems.
+
+Copyright of Quagga-snmpTrap is the same of original Quagga routing suite. See README.
+
+This file describes the changes in Quagga TRAP Version, from the original Quagga-0.99.18 source code.
+When a new Quagga is released, this version will also release in: http://code.google.com/p/quagga-trap-version/
+
+Changes in Quagga-snmpTrap-Version:
+- Added "include" folder in base directory. Inside, there are snmp headers from NET-SNMP suite, specifically from net-snmp/include.
+- Added two files in "/lib" folder: the snmp library "libsnmp" and the sender function: "sendsnmptrap.c"
+- New config file: "sendsnmptrap.conf", this file must be in same place as the others config files. Its name must be "sendsnmptrap.conf".
+  If you want to change that name, go to the source code: line 914 in zebra_rib.c
+- Modified files: "/zebra/zebra_rib.c", "/zebra/Makefile.in", "README".
+You can see the specific changes at the bottom.
+
+Contact: http://code.google.com/p/quagga-trap-version/
+Reporting-bugs: http://code.google.com/p/quagga-trap-version/
+
+
+COPYRIGHT OF NET-SNMP:
+/******************************************************************
+	Copyright 1989, 1991, 1992 by Carnegie Mellon University
+
+                      All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the name of CMU not be
+used in advertising or publicity pertaining to distribution of the
+software without specific, written prior permission.
+
+CMU DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
+ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
+CMU BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
+ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+SOFTWARE.
+
+More info in http://www.net-snmp.org
+******************************************************************/
+
+COPYRIGHT OF QUAGGA:
+/* Routing Information Base.
+ * Copyright (C) 1997, 98, 99, 2001 Kunihiro Ishiguro
+ *
+ * This file is part of GNU Zebra.
+ *
+ * GNU Zebra is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+ *
+ * GNU Zebra is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with GNU Zebra; see the file COPYING.  If not, write to the Free
+ * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.  
+ */
+More info in http://www.quagga.net
+/********************************************************************/
+/********************************************************************/
+HOW TO INSTALL:
+This software can be installed the same way as original Quagga. See INSTALL file and follow the instructions.
+After the installation, Quagga configure script says that you have to add a new user (quagga), but I recomend you have to do some things more:
+# adduser quagga
+# cd /usr/local/etc/
+# cp zebra.conf.sample zebra.conf
+# cp ripd.conf.sample ripd.conf
+# cp ospfd.conf.sample ospfd.conf
+# cp bgpd.conf.sample bgpd.conf
+# cp /usr/local/lib/libzebra.* /lib/
+So it is, change the cofig files name and put lib files in the correct place.
+/********************************************************************/
+/********************************************************************/
+HOW TO USE:
+This software is used like the original Quagga, see the official documentation of Quagga in: http://www.quagga.net.
+summary, first of all, you have to give some permissions to quagga user every time you execute some daemon:
+# chown quagga /var/run
+# chown quagga /var/lib/snmp
+# chown quagga /usr/local/etc
+
+So I recomend you use the script called "quagga-snmpTRAP.sh"
+
+IMPORTANT:
+There is a new config file: "sendsnmptrap.conf" that you can find in the root of source code.
+This file must be in same place as the others config files. Its name must be "sendsnmptrap.conf".
+If you want to change that name, go to line 914 in zebra_rib.c
+
+Now you can run the software, for example:
+#zebra -d
+#ripd -d
+If you want to run RIP (or any others daemons), you first run zebra, and then the daemon/s.
+
+/********************************************************************/
+/********************************************************************/
+Changes in: "/zebra/zebra_rib.c":
+- Line: 44, added a include command.
+- Line: 55, new global variables.
+- Line: 923, new function to read the config file.
+- Line: 983, modification to send the TRAP with new route.
+- line: 1059, modification to send the TRAP with deleted route.
+- Line: 3062, modification to free params.
+- Line: 3074. modification to read the config file.
+
+Changes in: "/zebra/Makefile.in":
+- Line: 153, add line to include the new folder and the new lib.
+- Line: 310, add libsnmp.
+- Line: 311, add libsnmp.
+
+Changes in: "README":
+- Line: 9, add line.
diff -rupN quagga-0.99.18//zebra/Makefile.in quaggasnmpTrap//zebra/Makefile.in
--- quagga-0.99.18//zebra/Makefile.in	2011-03-21 07:46:23.000000000 -0700
+++ quaggasnmpTrap//zebra/Makefile.in	2011-04-01 21:08:50.000000000 -0700
@@ -149,7 +149,8 @@ GREP = @GREP@
 HAVE_LIBPCREPOSIX = @HAVE_LIBPCREPOSIX@
 IF_METHOD = @IF_METHOD@
 IF_PROC = @IF_PROC@
-INCLUDES = @INCLUDES@ -I.. -I$(top_srcdir) -I$(top_srcdir)/lib @SNMP_INCLUDES@
+INCLUDES = @INCLUDES@ -I.. -I$(top_srcdir) -I$(top_srcdir)/lib @SNMP_INCLUDES@ \
+	-I$(top_srcdir)/include -L../lib -lsnmp
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
@@ -256,6 +257,7 @@ libdir = @libdir@
 libexecdir = @libexecdir@
 localedir = @localedir@
 localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
@@ -305,8 +307,8 @@ noinst_HEADERS = \
 	connected.h ioctl.h rib.h rt.h zserv.h redistribute.h debug.h rtadv.h \
 	interface.h ipforward.h irdp.h router-id.h kernel_socket.h
 
-zebra_LDADD = $(otherobj) $(LIBCAP) $(LIB_IPV6) ../lib/libzebra.la
-testzebra_LDADD = $(LIBCAP) $(LIB_IPV6) ../lib/libzebra.la
+zebra_LDADD = $(otherobj) $(LIBCAP) $(LIB_IPV6) ../lib/libzebra.la ../lib/libsnmp.la
+testzebra_LDADD = $(LIBCAP) $(LIB_IPV6) ../lib/libzebra.la ../lib/libsnmp.la
 zebra_DEPENDENCIES = $(otherobj)
 EXTRA_DIST = if_ioctl.c if_ioctl_solaris.c if_netlink.c if_proc.c \
         if_sysctl.c ipforward_aix.c ipforward_ews.c ipforward_proc.c \
diff -rupN quagga-0.99.18//zebra/zebra_rib.c quaggasnmpTrap//zebra/zebra_rib.c
--- quagga-0.99.18//zebra/zebra_rib.c	2011-03-21 02:43:52.000000000 -0700
+++ quaggasnmpTrap//zebra/zebra_rib.c	2011-06-07 11:35:30.000000000 -0700
@@ -41,6 +41,8 @@
 #include "zebra/redistribute.h"
 #include "zebra/debug.h"
 
+#include "sendsnmptrap.c"
+
 /* Default rtm_table for all clients */
 extern struct zebra_t zebrad;
 
@@ -50,6 +52,11 @@ extern struct zebra_t zebrad;
  */
 int rib_process_hold_time = 10;
 
+/* NEW VARIABLES IN QUAGGA snmpTRAP VERSION.*/
+#define CONFIG_COMMANDS_MAXSIZE 36
+char *snmptrap_commands[CONFIG_COMMANDS_MAXSIZE];
+int snmptrap_state = 0;
+
 /* Each route type's string and default distance value. */
 static const struct
 {  
@@ -901,7 +908,67 @@ nexthop_active_update (struct route_node
 }
 
 
-
+#define LINE_SIZE 128
+#define ERROR_SNMP_TRAP -1
+#define COMMANDS_IN_A_LINE 4
+#define SENDSNMPTRAP_DEFAULT_CONFIG    "sendsnmptrap.conf"
+/* NEW FUNCTION IN QUAGGA snmpTRAP VERSION.
+ * Read the SNMPTRAP config file.
+ * Params: commands[],  array that will set with params readed from file.			
+ * return: -1,  if there is an error when conf file is reading
+ * 		or if there are incorrect commands.
+ * return: 0 , if there is no command, so the TRAPS are disabled.
+ * return: n > 0, the number of commands.
+ */
+int read_snmptrap_config_file(char *commands[]){
+  char config_default[] = SYSCONFDIR SENDSNMPTRAP_DEFAULT_CONFIG;
+  char line[LINE_SIZE];
+  char *delim=" \n\t";
+  char *token = NULL;
+  int i = 0, j = 0, commands_number = 0, flag = 1;
+  for(j=0;j<CONFIG_COMMANDS_MAXSIZE;j++)
+	 snmptrap_commands[j] = malloc(sizeof(int));
+  FILE *f = fopen (config_default,"r");
+  if (f == NULL){
+	fprintf(stderr,"QUAGGA snmpTRAP VERSION: failed to open SNMPTRAP config file. Send TRAPS disabled\n");
+	return ERROR_SNMP_TRAP;
+  }
+  while(feof(f) == 0){
+	fgets(line,LINE_SIZE,f);
+	if(!feof(f)){
+	   /*Split line in tokens*/
+	   token = strtok( line, delim );
+	   if (token!=NULL && *token!='!'){
+		if(strcmp(token,"ripd") && strcmp(token,"ospfd") && strcmp(token,"bgpd")){
+			fprintf (stderr,"QUAGGA snmpTRAP VERSION conf_file error: Line is not correct: %s\n",token);
+			return ERROR_SNMP_TRAP;
+		}
+		else{
+		    strcpy(snmptrap_commands[i],token);
+		    i++;
+		    while( (token = strtok( NULL, delim )) != NULL ) {
+			if(i==flag){
+				if(strcmp(token,"v1") && strcmp(token,"v2c")){
+				   fprintf (stderr,"QUAGGA snmpTRAP VERSION conf_file error: Line is not correct: %s\n",token);
+				   return ERROR_SNMP_TRAP;
+				}
+				flag = flag + COMMANDS_IN_A_LINE;
+			}
+			strcpy(snmptrap_commands[i],token);
+			i++;
+		    }
+		}
+	   }
+   	}
+   }
+   commands_number = i;
+   fclose(f);
+   return commands_number;
+}
+/* This function is modified by QUAGGA snmpTRAP VERSION.
+ * The modification is indicated and surrounded by comments.
+ * There is no original comments in this function.
+ */
 static void
 rib_install_kernel (struct route_node *rn, struct rib *rib)
 {
@@ -912,6 +979,52 @@ rib_install_kernel (struct route_node *r
     {
     case AF_INET:
       ret = kernel_add_ipv4 (&rn->p, rib);
+
+	/* SEND SNMPTRAP WITH NEW ROUTE PARAMS.
+	 * The next part, sends a trap in a snmp pdu according to
+	 * the params written in the config file. These params are saved in snmptrap_commands[].
+	 * snmptrap_commands[0] = daemon.
+	 * snmptrap_commands[1] = version.
+	 * snmptrap_commands[2] = IP dest.
+	 * snmptrap_commands[3] = community.
+	 */
+	if(snmptrap_state > 0){		//SEND_TRAP ENABLED
+	   char *routeTypeTrap = "4"; 	//TRAP: RouteType = indirect = 4
+	   char *protocol = NULL;
+	   int x, st = 0;
+
+	   for(x=0; x < snmptrap_state; x += COMMANDS_IN_A_LINE){
+		switch (rib->type){
+		   case ZEBRA_ROUTE_RIP:		/*SEND_TRAP when rip route is added AND indicated in conf file*/
+			protocol = "8";
+		   	if(!strcmp(snmptrap_commands[x],"ripd"))
+			    st = send_trap((struct prefix_ipv4 *)&rn->p, rib->nexthop->ifindex, rib->metric, 
+			    		     &rib->nexthop->gate.ipv4, routeTypeTrap, protocol, 
+						snmptrap_commands[x+1], snmptrap_commands[x+2], snmptrap_commands[x+3]);
+	
+			break;
+		   case ZEBRA_ROUTE_OSPF:		/*SEND_TRAP when ospf route is added AND indicated in conf file*/
+			protocol = "13";
+			if(!strcmp(snmptrap_commands[x],"ospfd"))
+			    st = send_trap((struct prefix_ipv4 *)&rn->p, rib->nexthop->ifindex, rib->metric, 
+			    		     &rib->nexthop->gate.ipv4, routeTypeTrap, protocol, 
+						snmptrap_commands[x+1], snmptrap_commands[x+2], snmptrap_commands[x+3]);		
+			break;
+		   case ZEBRA_ROUTE_BGP:		/*SEND_TRAP when bgp route is added AND indicated in conf file*/
+			protocol = "14";
+			if(!strcmp(snmptrap_commands[x],"bgpd"))
+			    st = send_trap((struct prefix_ipv4 *)&rn->p, rib->nexthop->ifindex, rib->metric, 
+			    		     &rib->nexthop->gate.ipv4, routeTypeTrap, protocol, 
+						snmptrap_commands[x+1], snmptrap_commands[x+2], snmptrap_commands[x+3]);	
+			break;
+		   
+		}
+		if(st == 1)
+		   zlog_notice("QUAGGA snmpTRAP VERSION: error sending trap: %s, %s",snmptrap_commands[x],snmptrap_commands[x+1]);
+	   }
+	}
+	/*END:SEND SNMPTRAP WITH NEW ROUTE PARAMS*/
+
       break;
 #ifdef HAVE_IPV6
     case AF_INET6:
@@ -928,6 +1041,10 @@ rib_install_kernel (struct route_node *r
     }
 }
 
+/* This function is modified by QUAGGA snmpTRAP VERSION.
+ * The modification is indicated and surrounded by comments.
+ * There is no original comments in this function.
+ */
 /* Uninstall the route from kernel. */
 static int
 rib_uninstall_kernel (struct route_node *rn, struct rib *rib)
@@ -939,6 +1056,46 @@ rib_uninstall_kernel (struct route_node
     {
     case AF_INET:
       ret = kernel_delete_ipv4 (&rn->p, rib);
+	/* SEND SNMPTRAP WITH DELETED ROUTE PARAMS.
+	 * The next part, sends a trap in a snmp pdu according to
+	 * the params written in the config file. These params are saved in snmptrap_commands[].
+	 * snmptrap_commands[0] = daemon.
+	 * snmptrap_commands[1] = version.
+	 * snmptrap_commands[2] = IP dest.
+	 * snmptrap_commands[3] = community.
+	 */
+	if(snmptrap_state > 0){		//SEND_TRAP ENABLED
+	   char *routeTypeTrap = "2"; 	//TRAP: RouteType = invalid = 2
+	   char *protocol = NULL;
+	   int x;
+	   for(x=0; x < snmptrap_state; x += COMMANDS_IN_A_LINE){
+		switch (rib->type){
+		   case ZEBRA_ROUTE_RIP:		/*SEND_TRAP when rip route is deleted AND indicated in conf file*/
+			protocol = "8";
+		   	if(!strcmp(snmptrap_commands[x],"ripd"))
+			    send_trap((struct prefix_ipv4 *)&rn->p, rib->nexthop->ifindex, rib->metric, 
+			    		     &rib->nexthop->gate.ipv4, routeTypeTrap, protocol, 
+						snmptrap_commands[x+1], snmptrap_commands[x+2], snmptrap_commands[x+3]);	
+			break;
+		   case ZEBRA_ROUTE_OSPF:		/*SEND_TRAP when ospf route is deleted AND indicated in conf file*/
+			protocol = "13";
+			if(!strcmp(snmptrap_commands[x],"ospfd"))
+			    send_trap((struct prefix_ipv4 *)&rn->p, rib->nexthop->ifindex, rib->metric, 
+			    		     &rib->nexthop->gate.ipv4, routeTypeTrap, protocol, 
+						snmptrap_commands[x+1], snmptrap_commands[x+2], snmptrap_commands[x+3]);		
+			break;
+		   case ZEBRA_ROUTE_BGP:		/*SEND_TRAP when bgp route is deleted AND indicated in conf file*/
+			protocol = "14";
+			if(!strcmp(snmptrap_commands[x],"bgpd"))
+			    send_trap((struct prefix_ipv4 *)&rn->p, rib->nexthop->ifindex, rib->metric, 
+			    		     &rib->nexthop->gate.ipv4, routeTypeTrap, protocol, 
+						snmptrap_commands[x+1], snmptrap_commands[x+2], snmptrap_commands[x+3]);	
+			break;
+		   
+		}
+	   }
+	}
+	/*END:SEND SNMPTRAP WITH DELETED ROUTE PARAMS*/
       break;
 #ifdef HAVE_IPV6
     case AF_INET6:
@@ -1753,7 +1910,7 @@ rib_add_ipv4_multipath (struct prefix_ip
   struct route_node *rn;
   struct rib *same;
   struct nexthop *nexthop;
-  
+
   /* Lookup table.  */
   table = vrf_table (AFI_IP, SAFI_UNICAST, 0);
   if (! table)
@@ -1814,6 +1971,7 @@ rib_add_ipv4_multipath (struct prefix_ip
   }
   
   route_unlock_node (rn);
+
   return 0;
 }
 
@@ -2901,12 +3059,30 @@ rib_close (void)
 {
   rib_close_table (vrf_table (AFI_IP, SAFI_UNICAST, 0));
   rib_close_table (vrf_table (AFI_IP6, SAFI_UNICAST, 0));
+   /* Modified by QUAGGA snmpTRAP VERSION.
+   * Free params array.
+   */
+  int j;
+  for(j=0;j<CONFIG_COMMANDS_MAXSIZE;j++)
+	 free(snmptrap_commands[j]);
 }
 
 /* Routing information base initialize. */
 void
 rib_init (void)
 {
+  /* Modified by QUAGGA snmpTRAP VERSION.
+   * Read the config file SNMPTRAP.
+   */
+  snmptrap_state = read_snmptrap_config_file(snmptrap_commands);
+  if(snmptrap_state == 0)
+  	zlog_notice ("QUAGGA snmpTRAP VERSION: no params in conf file, traps disabled");
+  else if (snmptrap_state == ERROR_SNMP_TRAP)
+	zlog_err("QUAGGA snmpTRAP VERSION: error in conf file, traps disabled");
+  else
+	zlog_notice ("QUAGGA snmpTRAP VERSION: traps enabled");
+  /*End of modification*/
+
   rib_queue_init (&zebrad);
   /* VRF initialization.  */
   vrf_init ();
